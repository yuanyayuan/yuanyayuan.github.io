<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="工作中技术总结">
<meta property="og:type" content="website">
<meta property="og:title" content="Hikari的Java之路">
<meta property="og:url" content="https://yuanyayuan.github.io/index.html">
<meta property="og:site_name" content="Hikari的Java之路">
<meta property="og:description" content="工作中技术总结">
<meta property="og:locale">
<meta property="article:author" content="LiYuan">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yuanyayuan.github.io/"/>





  <title>Hikari的Java之路</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hikari的Java之路</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Hello,world</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%8C%E7%A9%BF%E9%80%8F%EF%BC%8C%E5%87%BB%E7%A9%BF%EF%BC%8C%E9%A2%84%E7%83%AD%EF%BC%8C%E6%9B%B4%E6%96%B0%EF%BC%8C%E9%99%8D%E7%BA%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%8C%E7%A9%BF%E9%80%8F%EF%BC%8C%E5%87%BB%E7%A9%BF%EF%BC%8C%E9%A2%84%E7%83%AD%EF%BC%8C%E6%9B%B4%E6%96%B0%EF%BC%8C%E9%99%8D%E7%BA%A7/" itemprop="url">redis缓存雪崩，穿透，击穿，预热，更新，降级</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T19:29:30+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="redis-雪崩："><a href="#redis-雪崩：" class="headerlink" title="redis 雪崩："></a>redis 雪崩：</h1><p>雪崩就是指缓存中<strong>大批量热点数据过期</strong>后系统涌入大量查询请求，因为<strong>大部分数据在Redis层已经失</strong>效，请求渗透到<strong>数据库层</strong>，大批量请求犹如洪水一般涌入，引起数据库压力造成查询堵塞甚至宕机。</p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.png" alt="image"></p>
<h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><ol>
<li>将缓存失效时间分散开，比如每个key的过期时间是随机，防止同一时间大量数据过期现象发生，这样不会出现同一时间全部请求都落在数据库层，如果缓存数据库是分布式部署，将热点数据均匀分布在不同Redis和数据库中，有效分担压力，别一个人扛。</li>
<li>简单粗暴，让Redis数据永不过期（如果业务准许，比如不用更新的名单类）。当然，如果业务数据准许的情况下可以，比如中奖名单用户，每期用户开奖后，名单不可能会变了，无需更新。</li>
<li>采用限流算法，限制请求流量，业务有损；</li>
<li>加锁访问，但是吞吐量会明显下降。</li>
<li>采购第三方Redis</li>
</ol>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A92.png" alt="image"></p>
<ol start="6">
<li>多缓存结合</li>
</ol>
<img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A93.png" style="zoom:33%;" />

<h1 id="击穿和穿透"><a href="#击穿和穿透" class="headerlink" title="击穿和穿透"></a>击穿和穿透</h1><h2 id="redis-穿透"><a href="#redis-穿透" class="headerlink" title="redis 穿透"></a>redis 穿透</h2><p>穿透是指绕过Reids，调用者发起的请求参数（key）在缓存和数据库中都不存在，通过不存在的key，成功穿透到系统底层，大规模不断发起不存在的key检索请求导致系统压力过大最后故障。</p>
<p>造成穿透的伪代码多为这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(redis.get(key) == <span class="keyword">null</span>)&#123;</span><br><span class="line">  <span class="comment">// redis数据不存在或已经过期 查询数据库</span></span><br><span class="line"> Object value = dao.query(key);</span><br><span class="line">  <span class="comment">// 重新将value刷入缓存。</span></span><br><span class="line">  redis.set(key);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> reids.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="以mall项目为例子"><a href="#以mall项目为例子" class="headerlink" title="以mall项目为例子"></a>以mall项目为例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;CategoryVO&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">String catsStr = redisOperator.get(<span class="string">&quot;subCat:&quot;</span> + rootCatId);</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isBlank(catsStr))&#123;</span><br><span class="line">    list = categoryService.getSubCatList(rootCatId);</span><br><span class="line">    redisOperator.set(<span class="string">&quot;subCat:&quot;</span> + rootCatId,JsonUtils.objectToJson(list));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    list = JsonUtils.jsonToList(catsStr,CategoryVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="攻击造成缓存穿透"><a href="#攻击造成缓存穿透" class="headerlink" title="攻击造成缓存穿透"></a>攻击造成缓存穿透</h3><p>不停地调用查询接口 查询 <strong>rootCatId == 99999</strong> 的子类造成不停查询数据库</p>
<h3 id="解决办法：-1"><a href="#解决办法：-1" class="headerlink" title="解决办法："></a>解决办法：</h3><ol>
<li><p>分布式布隆过滤器：布隆是BloomFilter音译过来的，Redis 自身支持BloomFilter。</p>
<p><strong>布隆过滤器缺点</strong>: 无法删除</p>
</li>
<li><p>返回空值：遇到数据库和Redis都查询不到的值，在Redis里set一个null value，过期时间很短，目的在于同一个key再次请求时直接返回null，避免穿透。</p>
</li>
<li><p>多级缓存。L1 为原始缓存（过期时间设置为短期），L2 为二级缓存（过期时间设置为长期）。L1 失效时可以继续访问 L2，避免同时失效。不过多了一级缓存，存储成本更高，而且多个缓存之间的数据一致性问题挑战也大。</p>
</li>
</ol>
<h2 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h2><p>BloomFilter：即布隆过滤器。可以用于检索一个元素是否在一个集合中。</p>
<h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><p>BloomFilter检索一个元素是否在一个集合中有一定的错误率（很低），但不会漏判。</p>
<ul>
<li><strong>如果判断一个key不在集合中，那一定不在</strong>。</li>
<li><strong>如果判断一个key存在，那不一定真的在</strong>。</li>
</ul>
<p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 <strong>“某样东西一定不存在或者可能存在”</strong>。</p>
<p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>基本思想是利用一个足够好的Hash函数将一个字符串映射到二进制位数组中的某一位，这样不管字符串如何长，都只有一位，因此存储空间就极大的提升了。但是不管hash函数如何高效，总是会存在Hash冲突，尤其是数据量变大的时候，而BloomFilter是利用多个不同的Hash函数来解决“冲突”，即一次采用多个Hash函数把数据映射到不同的位上，降低了冲突概率。如下图所示，</p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt="image">subCat:9999 会被误判为存在</p>
<p>如何根据输入元素个数n，确定位数组m的大小及Hash函数个数？已知文献证明，当Hash函数个数k=(ln2)*(m/n)时错误率最小。</p>
<p>BloomFilter有个缺点是不能删除数据，因为删除数据可能会影响到其它数据，有一些增强算法可以实现改功能，但代价比较大，不建议使用。</p>
<p>BloomFilter十分适合海量数据去重、过滤，尤其是当检测的字符串比较大时，极大地节省内存和存储空间，同时查询效率也十分高效。如果只是在内存使用，直接使用guava包的api即可；如果要做到分布式，结合Redis可以高效实现分布式的过滤效果。</p>
<h2 id="redis击穿"><a href="#redis击穿" class="headerlink" title="redis击穿"></a>redis击穿</h2><p>击穿和穿透概念类似，一般是指一个key被穿透，这个key是热点key，同一个key会被有成千上万次请求，比如微博热点排行榜，key是小时时间戳，value是个list的榜单。每个小时产生一个key，这个key会有百万QPS，如果这个key失效了，就像保险丝熔断，百万QPS直接压垮数据库。</p>
<h3 id="解决办法：-2"><a href="#解决办法：-2" class="headerlink" title="解决办法："></a>解决办法：</h3><p>业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。类似下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(key)</span> </span>&#123;</span><br><span class="line">    String value = redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">//代表缓存值过期</span></span><br><span class="line">        <span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line">        <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;  <span class="comment">//代表设置成功</span></span><br><span class="line">            value = db.get(key);</span><br><span class="line">            redis.set(key, value, expire_secs);</span><br><span class="line">            redis.del(key_mutex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">            sleep(<span class="number">50</span>);</span><br><span class="line">            get(key);  <span class="comment">//重试</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;      </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h1><p>缓存预热这个应该是一个比较常见的概念，相信都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p>解决思路：</p>
<p>1、直接写个缓存刷新页面，上线时手工操作下；</p>
<p>2、数据量不大，可以在项目启动的时候自动进行加载；</p>
<p>3、定时刷新缓存；</p>
<h1 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h1><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<p>（1）定时去清理过期的缓存；</p>
<p>（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</p>
<p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！</p>
<h1 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h1><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<p>（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p>
<p>（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</p>
<p>（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</p>
<p>（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/redis%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/redis%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5/" itemprop="url">redis缓存读写策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T16:43:29+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="如何保证缓存和数据库数据的一致性？-重要"><a href="#如何保证缓存和数据库数据的一致性？-重要" class="headerlink" title="如何保证缓存和数据库数据的一致性？(重要)"></a>如何保证缓存和数据库数据的一致性？(重要)</h1><p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p>
<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p>
<ol>
<li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li><strong>增加cache更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。</li>
</ol>
<h1 id="redis缓存读写策略"><a href="#redis缓存读写策略" class="headerlink" title="redis缓存读写策略"></a>redis缓存读写策略</h1><ul>
<li><p>Cache Aside （旁路缓存模式）</p>
<ul>
<li>先更新数据库，再更新缓存。这种做法最大的问题就是两个并发的写操作导致脏数据</li>
<li>先删除缓存，再更新数据库。这个逻辑是错误的，因为两个并发的读和写操作导致脏数据</li>
<li>先更新数据库，再删除缓存（在实际的系统中也推荐使用这种方式）</li>
</ul>
</li>
<li><p>Read/Write Through Pattern（读写穿透）</p>
</li>
<li><p>Write-behind caching（异步缓存写入）</p>
</li>
</ul>
<h2 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache Aside Pattern（旁路缓存模式）"></a>Cache Aside Pattern（旁路缓存模式）</h2><ul>
<li><p><strong>Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。</strong></p>
</li>
<li><p>Cache Aside Pattern 中服务端需要同时维系 DB 和 cache，并且是以 DB 的结果为准。</p>
</li>
<li><p>保证最终一致性的解决方案是缓存设置过期时间。</p>
</li>
</ul>
<h3 id="缓存读步骤"><a href="#缓存读步骤" class="headerlink" title="缓存读步骤"></a>缓存读步骤</h3><ul>
<li>从 cache 中读取数据，读取到就直接返回</li>
<li>cache中读取不到的话，就从 DB 中读取数据返回</li>
<li>再把数据放到 cache 中。</li>
</ul>
<img src="https://img-blog.csdnimg.cn/img_convert/a8c18b5f5b1aed03234bcbbd8c173a87.png" alt="img" style="zoom: 50%;" />

<h3 id="缓存写步骤"><a href="#缓存写步骤" class="headerlink" title="缓存写步骤"></a>缓存写步骤</h3><h4 id="方案一：先更新缓存，再更新数据库"><a href="#方案一：先更新缓存，再更新数据库" class="headerlink" title="方案一：先更新缓存，再更新数据库"></a>方案一：先更新缓存，再更新数据库</h4><p>不推荐。</p>
<ol>
<li>先更新缓存</li>
<li>若更新数据库失败，还需再更新缓存。</li>
</ol>
<h4 id="方案二：先更新数据库，再更新缓存"><a href="#方案二：先更新数据库，再更新缓存" class="headerlink" title="方案二：先更新数据库，再更新缓存"></a>方案二：先更新数据库，再更新缓存</h4><p>不推荐。</p>
<p>同时有请求A和请求B进行更新操作，请求A与B在不同线程，可能会出现：</p>
<ol>
<li>请求A更新了数据库</li>
<li>请求B更新了数据库</li>
<li>请求B更新了缓存</li>
<li>请求A更新了缓存</li>
</ol>
<p>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。</p>
<h4 id="方案三：先删除缓存，再更新数据库"><a href="#方案三：先删除缓存，再更新数据库" class="headerlink" title="方案三：先删除缓存，再更新数据库"></a>方案三：先删除缓存，再更新数据库</h4><p>有点问题。</p>
<p>有一个请求A进行更新操作，另一个请求B进行查询操作，可能会出现：</p>
<p>（1）、单个数据库</p>
<ol>
<li>请求A进行写操作，删除缓存</li>
<li>请求B查询发现缓存不存在</li>
<li>请求B去数据库查询得到旧值</li>
<li>请求B将旧值写入缓存</li>
<li>请求A将新值写入数据库</li>
</ol>
<p>（2）、读写分离架构</p>
<ol>
<li><p>请求A进行写操作，删除缓存</p>
</li>
<li><p>请求A将数据写入数据库了，</p>
</li>
<li><p>请求B查询缓存发现，缓存没有值</p>
</li>
<li><p>请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值</p>
</li>
<li><p>请求B将旧值写入缓存</p>
</li>
<li><p>数据库完成主从同步，从库变为新值</p>
</li>
</ol>
<p>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据</p>
<h5 id="解决方案：延时双删策略"><a href="#解决方案：延时双删策略" class="headerlink" title="解决方案：延时双删策略"></a>解决方案：延时双删策略</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void write(String key,Object data)&#123;</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">    db.updateData(data);</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先淘汰缓存</li>
<li>再写数据库（这两步和原来一样）</li>
<li>休眠1秒</li>
<li>再次淘汰缓存</li>
</ol>
<p>自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>
<p>对于MySQL读写分离架构，只是睡眠时间修改为在主从同步的延时时间基础上，加几百ms。</p>
<h4 id="方案四：先更新数据库，再删除缓存"><a href="#方案四：先更新数据库，再删除缓存" class="headerlink" title="方案四：先更新数据库，再删除缓存"></a>方案四：先更新数据库，再删除缓存</h4><img src="https://img-blog.csdnimg.cn/img_convert/5687fe759a1dac9ed9554d27e3a23b6d.png" alt="img" style="zoom:50%;" />

<p>极端情况有问题。</p>
<p>有一个请求A进行更新操作，另一个请求B进行查询操作，可能会出现：</p>
<ol>
<li>请求A查询数据库得到一个旧值</li>
<li>请求B将新值写入数据库</li>
<li>请求B删除缓存</li>
<li>请求A将查到的旧值写入缓存</li>
</ol>
<p>步骤2的<strong>写数据库操作比步骤1的读数据库操作耗时更短</strong>，才有可能使得步骤3先于步骤4。可是，数据库的<strong>读操作的速度远快于写操作</strong>的，因此步骤2耗时比步骤1更短，这一情形很难出现。</p>
<h5 id="解决方案：延时双删策略-1"><a href="#解决方案：延时双删策略-1" class="headerlink" title="解决方案：延时双删策略"></a>解决方案：延时双删策略</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void write(String key,Object data)&#123;</span><br><span class="line">    db.updateData(data);</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先写数据库</li>
<li>再淘汰缓存</li>
<li>休眠1秒</li>
<li>再次淘汰缓存</li>
</ol>
<h4 id="方案三与方案四还存在问题"><a href="#方案三与方案四还存在问题" class="headerlink" title="方案三与方案四还存在问题"></a>方案三与方案四还存在问题</h4><ul>
<li>问题一:同步双删导致并发降低</li>
<li>问题二:比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况。</li>
</ul>
<h5 id="问题一解决方案"><a href="#问题一解决方案" class="headerlink" title="问题一解决方案"></a>问题一解决方案</h5><p>异步。</p>
<h5 id="问题二解决方案"><a href="#问题二解决方案" class="headerlink" title="问题二解决方案"></a>问题二解决方案</h5><p>提供一个保障的重试机制。</p>
<h6 id="方案一：消息队列方式"><a href="#方案一：消息队列方式" class="headerlink" title="方案一：消息队列方式"></a>方案一：消息队列方式</h6><p>更新数据库数据<br>缓存因为种种问题删除失败<br>将需要删除的key发送至消息队列<br>自己消费消息，获得需要删除的key<br>继续重试删除操作，直到成功</p>
<p>业务线代码侵入较大。</p>
<h6 id="方案二：订阅binlong方式"><a href="#方案二：订阅binlong方式" class="headerlink" title="方案二：订阅binlong方式"></a>方案二：订阅binlong方式</h6><p>更新数据库数据<br>数据库会将操作信息写入binlog日志当中<br>订阅程序提取出所需要的数据以及key<br>另起一段非业务代码，获得该信息<br>尝试删除缓存操作，发现删除失败<br>将这些信息发送至消息队列<br>重新从消息队列中获得该数据，重试操作。</p>
<blockquote>
<p>订阅binlog程序在MySQL中有阿里开源的中间件叫canal。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试也可。</p>
</blockquote>
<p><strong>总结</strong></p>
<p>根据数据实时性要求，以及系统并发量考虑。</p>
<p>实时性不强，则可以选择设定缓存过期时间，先删缓存再更新数据库或先更新数据库再删缓存方案都可行。</p>
<p>实时性较强的，又有大并发量可以考虑延迟双删策略。</p>
<p>至于其他如请求串行化，放入同一个队列中依次执行的，复杂没必要。</p>
<h3 id="Cache-Aside-Pattern的缺陷"><a href="#Cache-Aside-Pattern的缺陷" class="headerlink" title="Cache Aside Pattern的缺陷"></a>Cache Aside Pattern的缺陷</h3><ul>
<li><p>缺陷1：首次请求数据一定不在 cache 的问题</p>
<p>解决办法：可以将热点数据可以提前放入cache 中。</p>
</li>
<li><p>写操作比较频繁的话导致cache中的数据会被频繁被删除，这样会影响缓存命中率 。</p>
<p>解决办法：</p>
<ul>
<li>数据库和缓存数据强一致场景 ：更新DB的时候同样更新cache，不过我们需要加一个锁/分布式锁来保证更新cache的时候不存在线程安全问题。</li>
<li>可以短暂地允许数据库和缓存数据不一致的场景 ：更新DB的时候同样更新cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li>
</ul>
</li>
</ul>
<h2 id="Read-Write-Through-Pattern（读写穿透）"><a href="#Read-Write-Through-Pattern（读写穿透）" class="headerlink" title="Read/Write Through Pattern（读写穿透）"></a>Read/Write Through Pattern（读写穿透）</h2><p>Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。</p>
<p>这种缓存读写策略在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为使用的分布式缓存 Redis 并没有提供 cache 将数据写入DB的功能。</p>
<p><strong>写（Write Through）：</strong></p>
<ul>
<li>先查 cache，cache 中不存在，直接更新 DB。</li>
<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（<strong>同步更新 cache 和 DB</strong>）。</li>
</ul>
<p>简单画了一张图帮助大家理解写的步骤。</p>
<p><img src="https://img-blog.csdnimg.cn/20210201100340808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70&ynotemdtimestamp=1617437153078" alt="img"></p>
<p><strong>读(Read Through)：</strong></p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回 。</li>
<li>读取不到的话，先从 DB 加载，写入到 cache 后返回响应。</li>
</ul>
<p>简单画了一张图帮助大家理解读的步骤。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9ada757c78614934aca11306f334638d.png?ynotemdtimestamp=1617437153078" alt="img"></p>
<p>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。</p>
<p>和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。</p>
<h1 id="Write-Behind-Pattern（异步缓存写入）"><a href="#Write-Behind-Pattern（异步缓存写入）" class="headerlink" title="Write Behind Pattern（异步缓存写入）"></a>Write Behind Pattern（异步缓存写入）</h1><p>Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 DB 的读写。</p>
<p>但是，两个又有很大的不同：<strong>Read/Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。</strong></p>
<p>很明显，这种方式对数据一致性带来了更大的挑战，比如cache数据可能还没异步更新DB的话，cache服务可能就就挂掉了。</p>
<p>这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 InnoDB Buffer Pool 机制都用到了这种策略。</p>
<p>Write Behind Pattern 下 DB 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/redis%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/redis%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/" itemprop="url">redis实际应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T16:32:57+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E5%BA%94%E7%94%A8/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis应用</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis-最适合的场景是什么？"><a href="#Redis-最适合的场景是什么？" class="headerlink" title="Redis 最适合的场景是什么？"></a>Redis 最适合的场景是什么？</h1><p>1、会话缓存（Session Cache）</p>
<p>最常用的一种使用 Redis 的情景是会话缓存（session cache）。用 Redis 缓存会话比其他存储（如 Memcached）的优势在于：Redis 提供持久化。</p>
<p>2、全页缓存（FPC）</p>
<p>除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。能帮助你以最快速度加载你曾浏览过的页面。</p>
<p>3、队列</p>
<p>Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push/pop 操作。</p>
<p>4，排行榜/计数器</p>
<p>Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的 10个用户，我们只需要像下面一样执行即可： 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES。</p>
<p>5、发布/订阅</p>
<p>最后（但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。在社交网络中甚至可以用 Redis 的发布/订阅功能来建立聊天系统！</p>
<h1 id="Redis-做异步队列（发布-订阅）"><a href="#Redis-做异步队列（发布-订阅）" class="headerlink" title="Redis 做异步队列（发布/订阅）"></a>Redis 做异步队列（发布/订阅）</h1><p>一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。</p>
<h2 id="可不可以不用-sleep-呢？"><a href="#可不可以不用-sleep-呢？" class="headerlink" title="可不可以不用 sleep 呢？"></a>可不可以不用 sleep 呢？</h2><p>list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。</p>
<h2 id="能不能生产一次消费多次呢？"><a href="#能不能生产一次消费多次呢？" class="headerlink" title="能不能生产一次消费多次呢？"></a>能不能生产一次消费多次呢？</h2><p>使用 pub/sub 主题订阅者模式，可以实现1:N 的消息队列。</p>
<h2 id="pub-sub-有什么缺点？"><a href="#pub-sub-有什么缺点？" class="headerlink" title="pub/sub 有什么缺点？"></a>pub/sub 有什么缺点？</h2><p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 RabbitMQ等。</p>
<h2 id="redis-如何实现延时队列？"><a href="#redis-如何实现延时队列？" class="headerlink" title="redis 如何实现延时队列？"></a>redis 如何实现延时队列？</h2><p>使用 sortedset，拿时间戳作为score，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。<br>40.使用过 Redis 分布式锁么，它是什么回事？</p>
<h1 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h1><p>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止忘记释放</p>
<h2 id="如果在setnx之后执行expire之前进程意外crash或者重启维护了，怎么办？"><a href="#如果在setnx之后执行expire之前进程意外crash或者重启维护了，怎么办？" class="headerlink" title="如果在setnx之后执行expire之前进程意外crash或者重启维护了，怎么办？"></a>如果在setnx之后执行expire之前进程意外crash或者重启维护了，怎么办？</h2><p>setnx和expire合成一条指令</p>
<h1 id="redis批量查询优化"><a href="#redis批量查询优化" class="headerlink" title="redis批量查询优化"></a>redis批量查询优化</h1><h1 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 大量key查询</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/getALot&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getALot</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; resutl = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String k:keys) &#123;</span><br><span class="line">        resutl.add(redisOperator.get(k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resutl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h1><h2 id="mget进行批量查询"><a href="#mget进行批量查询" class="headerlink" title="mget进行批量查询"></a>mget进行批量查询</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量查询 mget</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/mget&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">mget</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; keysList = Arrays.asList(keys);</span><br><span class="line">    <span class="keyword">return</span> redisOperator.mget(keysList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pipeline-进行批量查询"><a href="#pipeline-进行批量查询" class="headerlink" title="pipeline 进行批量查询"></a>pipeline 进行批量查询</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量查询 pipeline</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/batchGet&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">batchGet</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; keysList = Arrays.asList(keys);</span><br><span class="line">    <span class="keyword">return</span> redisOperator.batchGet(keysList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="redis热点数据问题"><a href="#redis热点数据问题" class="headerlink" title="redis热点数据问题"></a>redis热点数据问题</h1><h2 id="MySQL-里有-2000w-数据，Redis-中只存-20w-的数据，如何保证Redis-中的数据都是热点数据？"><a href="#MySQL-里有-2000w-数据，Redis-中只存-20w-的数据，如何保证Redis-中的数据都是热点数据？" class="headerlink" title="MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证Redis 中的数据都是热点数据？"></a>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证Redis 中的数据都是热点数据？</h2><p>限定 Redis 占用的内存，Redis 会根据自身数据淘汰策略，加载热数据到内存。 所以，计算一下 20W 数据大约占用的内存，然后设置一下 Redis 内存限制即可。</p>
<p>Redis存储数据会限制它内存大小，如果超过了最大内存容量，会触发数据淘汰策略</p>
<h2 id="由于内存限制，导致了Redis中只能存储最多1W条的数据信息，如何确保这1w条数据是最热门的数据？"><a href="#由于内存限制，导致了Redis中只能存储最多1W条的数据信息，如何确保这1w条数据是最热门的数据？" class="headerlink" title="由于内存限制，导致了Redis中只能存储最多1W条的数据信息，如何确保这1w条数据是最热门的数据？"></a>由于内存限制，导致了Redis中只能存储最多1W条的数据信息，如何确保这1w条数据是最热门的数据？</h2><h3 id="热点数据排序（点击次数）"><a href="#热点数据排序（点击次数）" class="headerlink" title="热点数据排序（点击次数）"></a>热点数据排序（点击次数）</h3><p>既然热门数据，那么就需要有排序，使用redis中的zset数据类型是很自然的想法。数据中的某个唯一字段作为zset中的value，而点击次数作为score，记为click_zset。这样就可选出最热门的数据。而数据，则直接用HashMap存储。</p>
<h3 id="热点数据时间（近期访问）"><a href="#热点数据时间（近期访问）" class="headerlink" title="热点数据时间（近期访问）"></a>热点数据时间（近期访问）</h3><p>既然只能存1w条数据且需要是热门数据，那么，点击次数是一方面，时效性也是一方面，如何保证？可以另起一个zset，数据的字段为value，而每次点击时更新当前时间戳为其score，记为time_zset这样，就可以记录时间。在后台跑一个任务，间隔一定时间段删除两个zset中长时间没有发生点击事件的键，并删除hash数据，为产生的新数据腾出数据空间。</p>
<h3 id="处理新热点数据"><a href="#处理新热点数据" class="headerlink" title="处理新热点数据"></a>处理新热点数据</h3><p>如果有空间，则保存到自己的hashmap，并将key存到两个zset中。 而没有空间时，就应该在click_zset中取出点击次数排在最前第1w位后面的键，删除对应的hash数据。然后看这1w个score的值，然后把key放入两个zset中即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/redis%E6%8C%87%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/redis%E6%8C%87%E4%BB%A4/" itemprop="url">redis指令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T16:32:25+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E5%BA%94%E7%94%A8/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis应用</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="redis指令"><a href="#redis指令" class="headerlink" title="redis指令"></a>redis指令</h1><ul>
<li>keys *：查看所有的key (不建议在生产上使用，有性能影响)</li>
<li>type key：key的类型</li>
<li>select index：切换数据库，总共默认16个</li>
<li>flushdb：删除当前下边db中的数据</li>
<li>flushall：删除所有db中的数据</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>string: 最简单的字符串类型键值对缓存，也是最基本的</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>get/set/del：查询/设置/删除</p>
</li>
<li><p>set rekey data：设置已经存在的key，会覆盖</p>
</li>
<li><p>setnx rekey data：设置已经存在的key，不会覆盖</p>
</li>
<li><p>set key value ex time：设置带过期时间的数据</p>
</li>
<li><p>expire key：设置过期时间</p>
</li>
<li><p>ttl：查看剩余时间，-1永不过期，-2过期</p>
</li>
<li><p>append key：合并字符串</p>
</li>
<li><p>strlen key：字符串长度</p>
</li>
<li><p>incr key：累加1</p>
</li>
<li><p>decr key：类减1</p>
</li>
<li><p>incrby key num：累加给定数值</p>
</li>
<li><p>decrby key num：累减给定数值</p>
</li>
<li><p>getrange key start end：截取数据，end=-1 代表到最后</p>
</li>
<li><p>setrange key start newdata：从start位置开始替换数据</p>
</li>
<li><p>mset：连续设值</p>
</li>
<li><p>mget：连续取值</p>
</li>
<li><p>msetnx：连续设置，如果存在则不设置</p>
</li>
</ul>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><h3 id="hash-1"><a href="#hash-1" class="headerlink" title="hash"></a>hash</h3><p>hash：类似map，存储结构化数据结构，比如存储一个对象（不能有嵌套对象）</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><ul>
<li>hset key property value：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt; hset user name imooc</span><br><span class="line">-&gt; 创建一个user对象，这个对象中包含name属性，name值为imooc</span><br></pre></td></tr></table></figure></li>
<li>hget user name：获得用户对象中name的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hmset：设置对象中的多个键值对</span><br><span class="line"> -&gt; hset user age 18 phone 139123123</span><br><span class="line"> hmsetnx：设置对象中的多个键值对，存在则不添加</span><br><span class="line"> -&gt; hset user age 18 phone 139123123</span><br></pre></td></tr></table></figure></li>
<li>hmget：获得对象中的多个属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt; hmget user age phone</span><br></pre></td></tr></table></figure></li>
<li>hgetall user：获得整个对象的内容</li>
<li>hincrby user age 2：累加属性</li>
<li>hincrbyfloat user age 2.2：累加属性</li>
<li>hlen user：有多少个属性</li>
<li>hexists user age：判断属性是否存在</li>
<li>hkeys user：获得所有属性</li>
<li>hvals user：获得所有值</li>
<li>hdel user：删除对象</li>
</ul>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h3 id="list-1"><a href="#list-1" class="headerlink" title="list"></a>list</h3><p>list：列表，[a, b, c, d, …]</p>
<h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><ul>
<li>lpush userList 1 2 3 4 5：构建一个list，从左边开始存入数据</li>
<li>rpush userList 1 2 3 4 5：构建一个list，从右边开始存入数据</li>
<li>lrange list start end：获得数据</li>
<li>lpop：从左侧开始拿出一个数据</li>
<li>rpop：从右侧开始拿出一个数据</li>
<li>llen list：list长度</li>
<li>lindex list index：获取list下标的值</li>
<li>lset list index value：把某个下标的值替换</li>
<li>linsert list before/after value：插入一个新的值</li>
<li>lrem list num value：删除几个相同数据</li>
<li>ltrim list start end：截取值，替换原来的list</li>
</ul>
<h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><h3 id="sorted-set："><a href="#sorted-set：" class="headerlink" title="sorted set："></a>sorted set：</h3><p>sorted set：排序的set，可以去重可以排序，比如可以根据用户积分做排名，积分作为set的一个数值，根据数值可以做排序。set中的每一个memeber都带有一个分数</p>
<h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>zadd zset 10 value1 20 value2 30 value3：设置member和对应的分数</p>
</li>
<li><p>zrange zset 0 -1：查看所有zset中的内容</p>
</li>
<li><p>zrange zset 0 -1 withscores：带有分数</p>
</li>
<li><p>zrank zset value：获得对应的下标</p>
</li>
<li><p>zscore zset value：获得对应的分数</p>
</li>
<li><p>zcard zset：统计个数</p>
</li>
<li><p>zcount zset 分数1 分数2：统计个数</p>
</li>
<li><p>zrangebyscore zset 分数1 分数2：查询分数之间的member(包含分数1 分数2)</p>
</li>
<li><p>zrangebyscore zset (分数1 (分数2：查询分数之间的member（不包含分数1 和 分数2）</p>
</li>
<li><p>zrangebyscore zset 分数1 分数2 limit start end：查询分数之间的member(包含分数1 分数2)，获得的结果集再次根据下标区间做查询</p>
</li>
<li><p>zrem zset value：删除member</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/" itemprop="url">redis内存淘汰机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T12:46:31+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis设置过期时间"><a href="#Redis设置过期时间" class="headerlink" title="Redis设置过期时间"></a>Redis设置过期时间</h1><ul>
<li>expire key time(以秒为单位)–这是最常用的方式</li>
<li>setex(String key, int seconds, String value)–字符串独有的方式</li>
</ul>
<p>注意：</p>
<ul>
<li>除了字符串自己独有设置过期时间的方法外，其他方法都需要依靠expire方法来设置时间</li>
<li>如果没有设置时间，那缓存就是永不过期</li>
<li>如果设置了过期时间，之后又想让缓存永不过期，使用persist key</li>
</ul>
<h1 id="Redis-给缓存数据设置过期时间有啥用？"><a href="#Redis-给缓存数据设置过期时间有啥用？" class="headerlink" title="Redis 给缓存数据设置过期时间有啥用？"></a>Redis 给缓存数据设置过期时间有啥用？</h1><p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？</p>
<p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接Out of memory。</p>
<p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong></p>
<p>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在1分钟内有效，用户登录的 token 可能只在 1 天内有效。</p>
<p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p>
<h1 id="Redis是如何判断数据是否过期的呢？"><a href="#Redis是如何判断数据是否过期的呢？" class="headerlink" title="Redis是如何判断数据是否过期的呢？"></a>Redis是如何判断数据是否过期的呢？</h1><p>Redis  通过一个叫做过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个key(键)，过期字典的值是一个long long类型的整数，这个整数保存了key所指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。 </p>
<h1 id="Redis-过期键的删除策略"><a href="#Redis-过期键的删除策略" class="headerlink" title="Redis 过期键的删除策略"></a>Redis 过期键的删除策略</h1><p>A、<strong>定期删除策略</strong>。用一个<strong>定时器</strong>来负责检查 key，过期则删除 key，注意这里并不是检查所有的 key 而是<strong>随机抽取进行检查</strong>。定期策略虽然让内存及时释放，但也会<strong>额外消耗 CPU 资源</strong>，通常 CPU 应该将时间尽量用于处理业务请求，而不是删除 key。</p>
<p>B、<strong>惰性删除策略</strong>。在你<strong>获取</strong>某个 key 的时候，redis 会检查一下，这个 key <strong>如果设置了过期时间那么是否过期了</strong>，如果<strong>过期</strong>则删除该 key。</p>
<hr>
<h1 id="Redis-的回收策略（淘汰策略）"><a href="#Redis-的回收策略（淘汰策略）" class="headerlink" title="Redis 的回收策略（淘汰策略）"></a>Redis 的回收策略（淘汰策略）</h1><h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2><p>如果<strong>定期删除没删除 key</strong>，然后也<strong>没及时去请求 key</strong>，即<strong>惰性删除也没生效</strong>，持续下去 redis 的内存会越来越高，当超过 redis 设置的内存最大使用量时，就会进行内存数据淘汰。redis 有 6 种淘汰策略：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>volatile-lru</td>
<td>从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td>volatile-ttl</td>
<td>从已设置过期时间的数据集中挑选将要过期的数据淘汰</td>
</tr>
<tr>
<td>volatile-random</td>
<td>从已设置过期时间的数据集中任意选择数据淘汰</td>
</tr>
<tr>
<td>allkeys-lru</td>
<td>从所有数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td>allkeys-random</td>
<td>从所有数据集中任意选择数据进行淘汰</td>
</tr>
<tr>
<td>noeviction</td>
<td>当内存不足以容纳新写入数据时，新写入操作会报错。很少使用</td>
</tr>
</tbody></table>
<blockquote>
<p>注意这里的 6 种机制，前缀 volatile 和 allkeys 用于区分淘汰数据的数据集是从已设置过期时间的数据集还是从全部数据集中选取，后面的 lru、ttl 以及 random 是三种不同的淘汰策略，再加上一种 no-enviction 永不回收的策略。其中最常使用的是 volatile-lru/allkeys-lru。</p>
</blockquote>
<ul>
<li>allkeys-lru：如果期望用户请求呈现幂律分布(power-law distribution)，也就是，期望一部分子集元素被访问得远比其他元素多时，可以使用allkeys-lru策略。在你不确定时这是一个好的选择</li>
<li>allkeys-random：如果期望是循环周期的访问，所有的键被连续扫描，或者期望请求符合平均分布(每个元素以相同的概率被访问)，可以使用allkeys-random策略。</li>
<li>volatile-ttl：如果你期望能让 Redis 通过使用你创建缓存对象的时候设置的TTL值，确定哪些对象应该是较好的清除候选项，可以使用volatile-ttl策略。</li>
</ul>
<p>另外值得注意的是，为键设置过期时间需要消耗内存，所以使用像allkeys-lru这样的策略会更高效，因为在内存压力下没有必要为键的回收设置过期时间。</p>
<h2 id="常用缓存数据淘汰策略"><a href="#常用缓存数据淘汰策略" class="headerlink" title="常用缓存数据淘汰策略"></a>常用缓存数据淘汰策略</h2><ul>
<li>FIFO（First In First Out）： 先进先出算法，即先放入缓存的先被移除。</li>
<li>LRU（Least Recently Used）： 最近最少使用算法，使用时间距离现在最久的那个被移除。</li>
<li>LFU（Least Frequently Used）： 最不常用算法，一定时间段内使用次数（频率）最少的那个被移除。</li>
</ul>
<h2 id="缓存数据更新策略"><a href="#缓存数据更新策略" class="headerlink" title="缓存数据更新策略"></a>缓存数据更新策略</h2><ul>
<li>定时任务从数据库直接更新缓存：适用于对时间不敏感的数据。</li>
<li>查询时写缓存，即查询优先查询缓存，若缓存未命中，查询数据库，将返回结果写入缓存，数据更新时先 delete缓存，再更新缓存。</li>
<li>MQ 消息异步更新缓存。</li>
</ul>
<h1 id="Redis采用的过期策略"><a href="#Redis采用的过期策略" class="headerlink" title="Redis采用的过期策略"></a>Redis采用的过期策略</h1><p>惰性删除+定期删除</p>
<ul>
<li>惰性删除流程<ul>
<li>在进行get或setnx等操作时，先检查key是否过期，</li>
<li>若过期，删除key，然后执行相应操作；</li>
<li>若没过期，直接执行相应操作</li>
</ul>
</li>
<li>定期删除流程（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）<ul>
<li>遍历每个数据库（就是redis.conf中配置的”database”数量，默认为16）<ul>
<li>检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）<ul>
<li>如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历</li>
<li>随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key</li>
<li>判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" itemprop="url">redis线程模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T01:19:02+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis单线程原理"><a href="#Redis单线程原理" class="headerlink" title="Redis单线程原理"></a>Redis单线程原理</h1><p>Redis是单进程，Redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。</p>
<h1 id="Redis的线程模型"><a href="#Redis的线程模型" class="headerlink" title="Redis的线程模型"></a>Redis的线程模型</h1><p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="image"></p>
<p><strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型</strong>，Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接， <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">多个 socket（客户端连接）</span><br><span class="line">IO 多路复用程序（支持多个客户端连接的关键）</span><br><span class="line">文件事件分派器（将 socket 关联到相应的事件处理器）</span><br><span class="line">事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</span><br></pre></td></tr></table></figure>

<h2 id="Redis-单线程模型详解"><a href="#Redis-单线程模型详解" class="headerlink" title="Redis 单线程模型详解"></a>Redis 单线程模型详解</h2><p><strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型</strong>，Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接， <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong></p>
<p>主要是包含 4 个部分：</p>
<ul>
<li>多个 socket（客户端连接）</li>
<li>IO 多路复用程序（支持多个客户端连接的关键）</li>
<li>文件事件分派器（将 socket 关联到相应的事件处理器）</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<h1 id="Redis-是单进程单线程的吗？为何它那么快那么高效？"><a href="#Redis-是单进程单线程的吗？为何它那么快那么高效？" class="headerlink" title="Redis 是单进程单线程的吗？为何它那么快那么高效？"></a>Redis 是单进程单线程的吗？为何它那么快那么高效？</h1><h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>Redis是单线程的，redis 利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。</p>
<h2 id="速度快"><a href="#速度快" class="headerlink" title="速度快"></a>速度快</h2><p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p>
<p>2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p>
<p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p>
<p>4、使用多路I/O复用模型，非阻塞IO；</p>
<p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p>
<hr>
<h1 id="redis为什么不采用多线程处理"><a href="#redis为什么不采用多线程处理" class="headerlink" title="redis为什么不采用多线程处理"></a>redis为什么不采用多线程处理</h1><ol>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的性能瓶颈不再 CPU ，主要在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ol>
<h2 id="Redis6-0-之后为何引入了多线程"><a href="#Redis6-0-之后为何引入了多线程" class="headerlink" title="Redis6.0 之后为何引入了多线程"></a>Redis6.0 之后为何引入了多线程</h2><p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了， 执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</p>
<h1 id="单线程处理的缺点？"><a href="#单线程处理的缺点？" class="headerlink" title="单线程处理的缺点？"></a>单线程处理的缺点？</h1><p>1.耗时的命令会导致并发的下降，不只是读并发，写并发也会下降</p>
<p>2.无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善</p>
<hr>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url">redis数据结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T01:18:46+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis-的数据类型？"><a href="#Redis-的数据类型？" class="headerlink" title="Redis 的数据类型？"></a>Redis 的数据类型？</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>键(key)——值(value) (字符串格式)</p>
<h4 id="动态字符串（Redis字符串的实现方式）"><a href="#动态字符串（Redis字符串的实现方式）" class="headerlink" title="动态字符串（Redis字符串的实现方式）"></a>动态字符串（Redis字符串的实现方式）</h4><p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * 保存字符串对象的结构  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span>  </span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度  </span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// buf 中剩余可用空间的长度  </span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;  </span><br><span class="line">    <span class="comment">// 数据空间  </span></span><br><span class="line">    <span class="keyword">char</span> buf[];  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>len 变量，用于记录buf 中已经使用的空间长度。</li>
<li>free 变量，用于记录buf 中还空余的空间，初次分配空间，一般没有空余，在对字符串修改的时候，会有剩余空间出现，这样做是为了杜绝C语言中缓冲区溢出的可能性，当我们需要对一个SDS进行修改的时候，Redis 会在执行拼接操作之前，预先检查给定SDS空间是否足够，如果不够，会先拓展SDS的空间，然后再执行拼接操作。</li>
<li>buf 字符数组，用于记录我们的字符串（记录Redis）。</li>
</ol>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>字符串拥有一些操作命令，如：</p>
<ul>
<li>get 获取值</li>
<li>set key value设置值</li>
<li>del 删除</li>
<li>incr key 加一</li>
<li>decr key 减一</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><p>计数器 string类型的<code>incr</code>和<code>decr</code>命令的作用是将key中储存的数字值<strong>加一/减一</strong>，这两个操作具有原子性，总能安全地进行加减操作</p>
<p> 因此可以用string类型进行计数，如微博的评论数、点赞数、分享数，抖音作品的收藏数，京东商品的销售量、评价数等。</p>
</li>
<li><p>分布式锁 String类型的<code>setnx</code>的作用是<strong>当key不存在时，设值并返回1，当key已经存在时，不设值并返回0</strong>，<strong>判断key是否存在</strong>和<strong>设值</strong>两个操作是原子性地执行的，因此可以用string类型作为分布式锁，返回1表示获得锁，返回0表示没有获得锁。</p>
<p> 例如，为了保证定时任务的高可用，往往会同时部署多个具备相同定时任务的服务，但是业务上只希望其中的某一台服务执行定时任务，当定时任务的时间点触发时，多个服务同时竞争一个分布式锁，获取到锁的执行定时任务，没获取到的放弃执行定时任务。</p>
<p> 定时任务执行完时通过del命令删除key即释放锁，如果担心del命令操作失败而导致锁一直未释放，可以通过expire命令给锁设置一个合理的自动过期时间，确保即使del命令失败，锁也能被释放。不过expire命令同样存在失败的可能性，如果你用的是Java语言，建议使用JedisCommands接口提供的<code>String set(String key, String value, String nxxx, String expx, long time)</code>方法，这个方法可以将setnx和expire原子性地执行，具体使用方式如下（相信其它语言的Redis客户端也应当提供了类似的方法）。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jedisCommands.set(<span class="string">&quot;IAmAKey&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, <span class="number">60</span>);<span class="comment">//如果&quot;IAmAKey&quot;不存	 在，则将其设值为1，同时设置60秒的自动过期时间</span></span><br></pre></td></tr></table></figure></li>
<li><p>限流</p>
</li>
<li><p>分布式Session</p>
</li>
<li><p>存储对象 利用JSON强大的兼容性、可读性和易用性，将对象转换为JSON字符串，再存储在string类型中，是个不错的选择，如用户信息、商品信息等。</p>
</li>
</ol>
<h2 id="列表-List"><a href="#列表-List" class="headerlink" title="列表(List)"></a>列表(List)</h2><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p>一个列表结构可以有序地存储多个字符串</p>
<h4 id="链表数据结构，List-底层结构"><a href="#链表数据结构，List-底层结构" class="headerlink" title="链表数据结构，List 底层结构"></a>链表数据结构，List 底层结构</h4><p>链表还是常规的普通双端链表，可以支持反向查找和遍历，更方便操作，通过增删节点来灵活地调整链表的长度，双端链表在Redis内部也是被多次使用：</p>
<ol>
<li>事务模块使用双端链表依序保存输入的命令。</li>
<li>服务器模块使用双端链表来保存多个客户端。</li>
<li>订阅/发送模块使用双端链表来保存订阅模式的多个客户端。</li>
<li>事件模块使用双端链表来保存时间事件（time event）。</li>
</ol>
<h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><ul>
<li>lpush list a b c d (从左添加元素)</li>
<li>rpush list 1 2 3 4 (从右边添加元素)</li>
<li>lrange list 0 -1 (从0 到 -1 元素查看：也就表示查看所有)</li>
<li>lpop list （从左边取，删除）</li>
<li>rpop list (从右边取，删除)</li>
</ul>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><p>消息队列 list类型的lpop和rpush（或者反过来，lpush和rpop）能实现队列的功能，故而可以用Redis的list类型实现简单的点对点的消息队列，但有更好的rabbitmq和kafka</p>
</li>
<li><p>排行榜 list类型的lrange命令可以分页查看队列中的数据。可将每隔一段时间计算一次的排行榜存储在list类型中，如京东每日的手机销量排行、学校每次月考学生的成绩排名、斗鱼年终盛典主播排名等。</p>
</li>
</ol>
<blockquote>
<p>排行榜，每日计算一次，存储在list类型中，接口访问时，通过page和size分页获取 </p>
</blockquote>
<img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/QQ%E9%9F%B3%E4%B9%90%E6%8E%92%E8%A1%8C%E6%A6%9C.png" style="zoom:50%;" />

<blockquote>
<p>但是，并不是所有的排行榜都能用list类型实现，只有定时计算的排行榜才适合使用list类型存储，与定时计算的排行榜相对应的是实时计算的排行榜，list类型不能支持实时计算的排行榜，实时计算的排行榜使用有序集合sorted set实现。</p>
</blockquote>
<ol start="3">
<li>最新列表 list类型的lpush命令和lrange命令能实现最新列表的功能，每次通过lpush命令往列表里插入新的元素，然后通过lrange命令读取最新的元素列表，如朋友圈的点赞列表、评论列表。</li>
</ol>
<blockquote>
<p>但是，并不是所有的最新列表都能用list类型实现， 因为对于频繁更新的列表，list类型的分页可能导致列表元素重复或漏掉 ，举个例子，当前列表里由表头到表尾依次有（E，D，C，B，A）五个元素， 每页获取3个元素，用户第一次获取到（E，D，C）三个元素，然后表头新增了一个元素F， 列表变成了（F，E，D，C，B，A），此时用户取第二页拿到（C，B，A）， 元素C重复了。</p>
</blockquote>
<h4 id="list和sorted-set"><a href="#list和sorted-set" class="headerlink" title="list和sorted set"></a>list和sorted set</h4><ul>
<li><p>只有不需要分页（比如每次都只取列表的前5个元素）或者更新频率低（比如每天凌晨更新一次）的列表才适合用list类型实现。</p>
</li>
<li><p>对于需要分页并且会频繁更新的列表，需用使用有序集合sorted set类型实现。</p>
</li>
<li><p>需要通过时间范围查找的最新列表，list类型也实现不了，也需要通过有序集合sorted set类型实现，如以成交时间范围作为条件来查询的订单列表。</p>
</li>
</ul>
<h5 id="如何选用"><a href="#如何选用" class="headerlink" title="如何选用"></a>如何选用</h5><blockquote>
<p>对于排行榜和最新列表两种应用场景，那为什么还要使用list类型去实现排行榜或最新列表呢，直接用sorted set类型不是更好吗？</p>
</blockquote>
<p>原因是sorted <strong>set类型占用的内存容量是list类型的数倍之多</strong>，对于<strong>列表数量不多</strong>的情况，可以用sorted set类型来实现，比如上文中举例的打擂金曲排行榜，每天全国只有一份，两种数据类型的内存容量差距可以忽略不计，但是如果要实现某首歌曲的翻唱作品地区排行榜，数百万的歌曲，300多个地区，会产生数量庞大的榜单，或者数量更加庞大的朋友圈点赞列表，就需要慎重地考虑容量的问题了</p>
<h2 id="hash类型"><a href="#hash类型" class="headerlink" title="hash类型"></a>hash类型</h2><h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p>hash类型是一个string类型的field和value的映射表</p>
<h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><ul>
<li>hdel (HDEL key field1 [field2]) 删除一个或多个哈希表字段</li>
<li>hlen</li>
<li>hgetall</li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-hashes.html">更多方法</a></li>
</ul>
<h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h4><p>以用户id为key，商品id为field，商品数量为value，恰好构成了购物车的3个要素，如下图所示。</p>
<img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/%E8%B4%AD%E7%89%A9%E8%BD%A6.png" style="zoom:50%;" />

<h4 id="存储对象"><a href="#存储对象" class="headerlink" title="存储对象"></a>存储对象</h4><p>存储对象 hash类型的(key, field, value)的结构与对象的(对象id, 属性, 值)的结构相似，也可以用来存储对象。</p>
<h5 id="存储对象时，到底用string-json还是用hash"><a href="#存储对象时，到底用string-json还是用hash" class="headerlink" title="存储对象时，到底用string + json还是用hash"></a>存储对象时，到底用string + json还是用hash</h5><p>两种存储方式的对比如下表所示。</p>
<table>
<thead>
<tr>
<th></th>
<th>string + json</th>
<th>hash</th>
</tr>
</thead>
<tbody><tr>
<td>效率</td>
<td>很高</td>
<td>高</td>
</tr>
<tr>
<td>容量</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td>灵活性</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>序列化</td>
<td>简单</td>
<td>复杂</td>
</tr>
</tbody></table>
<ul>
<li>当对象的某个属性需要频繁修改时，不适合用string+json，因为它不够灵活，每次修改都需要重新将整个对象序列化并赋值</li>
<li>如果使用hash类型，则可以针对某个属性单独修改，没有序列化，也不需要修改整个对象。比如，商品的价格、销量、关注数、评价数等可能经常发生变化的属性，就适合存储在hash类型里。</li>
</ul>
<p>当然，不常变化的属性存储在hash类型里也没有问题，比如商品名称、商品描述、上市日期等。但是，当对象的某个属性<strong>不是基本类型或字符串时</strong>，使用hash类型就必须手动进行复杂序列化</p>
<p>比如，商品的标签是一个标签对象的列表，商品可领取的优惠券是一个优惠券对象的列表（如下图所示）等，即使以coupons（优惠券）作为field，value想存储优惠券对象列表也还是要使用json来序列化，这样的话序列化工作就太繁琐了，不如直接用string + json的方式存储商品信息来的简单。 </p>
<img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/%E4%BC%98%E6%83%A0%E5%8D%B7.png" style="zoom:33%;" />

<p><strong>综上，一般对象用string+json存储，对象中某些频繁变化的基本类型或字符串的属性抽出来用hash存储。</strong></p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p>set类型是string类型的集合，其特点是集合元素无序且不重复</p>
<h3 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h3><ul>
<li>SINTER KEY KEY1..KEYN 回给定所有给定集合的交集</li>
<li>SISMEMBER KEY VALUE 判断成员元素是否是集合的成员</li>
<li>SCARD KEY_NAME 返回集合中元素的数量</li>
<li>SMOVE SOURCE DESTINATION MEMBER 命令将指定成员 member 元素从 source 集合移动到 destination 集合。</li>
<li>SRANDMEMBER KEY [count] 用于返回集合中的一个随机元素。</li>
</ul>
<h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><p>好友/关注/粉丝/感兴趣的人集合</p>
<p>set类型唯一的特点使得其适合用于存储好友/关注/粉丝/感兴趣的人集合，集合中的元素数量可能很多，每次全部取出来成本不小，set类型提供了一些很实用的命令用于直接操作这些集合</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. sinter命令可以获得A和B两个用户的共同好友</span><br><span class="line">2. sismember命令可以判断A是否是B的好友</span><br><span class="line">3. scard命令可以获取好友数量</span><br><span class="line">4. 关注时，smove命令可以将B从A的粉丝集合转移到A的好友集合</span><br></pre></td></tr></table></figure>
<p><strong>需要注意</strong>:</p>
<p>如果你用的是<strong>Redis Cluster集群</strong>，对于<strong>sinter、smove这种操作     多个key的命令</strong>，要求这两个key必须存储在<strong>同一个slot（槽位）中</strong>，否则会报出<code>(error) CROSSSLOT Keys in request don&#39;t hash to the same slot </code>错误。</p>
<p>Redis Cluster一共有<strong>16384</strong>个slot，每个key都是通过哈希算法CRC16(key)获取数值哈希，再模16384来定位slot的。要使得两个key处于同一slot，除了两个key一模一样，还有没有别的方法呢？</p>
<p>Redis提供了一种<strong>Hash Tag</strong>的功能，在key中使用<code>&#123;&#125;</code>括起key中的一部分，在进行<code>CRC16(key) mod 16384</code>的过程中，只会对<code>&#123;&#125;</code>内的字符串计算，例如<strong>friend_set:{123456}<strong>和</strong>fans_set:{123456}<strong>，分别表示</strong>用户123456</strong>的<strong>好友集合</strong>和<strong>粉丝集合</strong>，在定位slot时，只对<code>&#123;&#125;</code>内的<code>123456</code>进行计算，所以这两个集合肯定是在同一个slot内的，当用户123456关注某个粉丝时，就可以通过smove命令将这个粉丝从用户123456的粉丝集合移动到好友集合。</p>
<p>相比于通过srem命令先将这个粉丝从粉丝集合中删除，再通过sadd命令将这个粉丝加到好友集合，smove命令的优势是它是<strong>原子性</strong>的，不会出现这个粉丝从粉丝集合中被删除，却没有加到好友集合的情况。</p>
<p>然而，对于通过sinter获取共同好友而言，Hash Tag则无能为力，例如，要用sinter去获取<strong>用户123456</strong>和<strong>用户456789</strong>两个用户的共同好友，除非我们将key定义为**{friend_set}:123456<strong>和</strong>{friend_set}:456789**，否则不能保证两个key会处于同一个slot，但是如果真这样做的话，所有用户的好友集合都会堆积在同一个slot中，数据分布会严重不均匀，不可取，</p>
<p><strong>所以，在实战中使用Redis Cluster时，sinter这个命令其实是不适合作用于两个不同用户对应的集合的（同理其它操作多个key的命令）。</strong></p>
</li>
<li><p>随机展示 通常，app首页的展示区域有限，但是又不能总是展示固定的内容，一种做法是先确定一批需要展示的内容，再从中随机获取。如下图所示，酷狗音乐K歌擂台赛当日的打擂歌曲共29首，首页随机展示5首；昨日打擂金曲共200首，首页随机展示30首。</p>
</li>
</ol>
<img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/%E6%89%93%E6%93%82.png" style="zoom:33%;" />

<p>set类型适合存放所有需要展示的内容，而<code>srandmember</code>命令则可以从中随机获取几个。</p>
<h2 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted set"></a>sorted set</h2><h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员</p>
<p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p><strong>有序集合的成员是唯一的</strong>,但分数(score)却可以重复。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。</p>
<h4 id="跳跃表，sorted-set底层结构"><a href="#跳跃表，sorted-set底层结构" class="headerlink" title="跳跃表，sorted set底层结构"></a>跳跃表，sorted set底层结构</h4><p>Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，（如果你还不了解红黑树，需要先额外补补功课），HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score，使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。</p>
<p>那为什么Redis的作者使用 SkipList 结构而不是红黑树？</p>
<ul>
<li>红黑树：红黑树的查找效率很高，但是在进行重新平衡时，会涉及到大量节点的变化，因此实现和操作起来都比较复杂。</li>
<li>跳跃表：通过简单的多层索引结构，实现简单，且能达到近似于红黑树的查找效率，插入节点（多层插入）不需要像红黑树那样有额外操作。而且跳跃表还能实现范围查找及输出，而红黑树只支持单个元素查找，对于范围查找效率低。</li>
</ul>
<h3 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h3><ol>
<li>Zadd</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD KEY_NAME SCORE1 VALUE1.. SCOREN VALUEN</span><br></pre></td></tr></table></figure>

<ol>
<li>Zincrby 对有序集合中指定成员的分数加上增量 increment</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY key increment member</span><br></pre></td></tr></table></figure>

<ol>
<li>Zrange 返回有序集中，指定区间内的成员</li>
</ol>
<p>其中成员的位置按分数值递增(从小到大)来排序。 具有相同分数值的成员按字典序(lexicographical order )来排列。</p>
<p><strong>下标参数</strong> start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。</p>
<p>你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure>

<ol>
<li>Zrevrange 命令返回有序集中，指定区间内的成员。</li>
</ol>
<p><strong>下标参数</strong> start 和 stop 其中成员的位置按分数值递减(从大到小)来排列。 具有相同分数值的成员按字典序的逆序(reverse lexicographical order)排列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure>

<ol>
<li>Zrem 命令用于移除有序集中的一个或多个成员，不存在的成员将被忽略。 当 key 存在但不是有序集类型时，返回一个错误。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREM key member [member ...]</span><br></pre></td></tr></table></figure>

<ol>
<li>Zcard 命令用于计算集合中元素的数量。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCARD KEY_NAME</span><br></pre></td></tr></table></figure>

<ol>
<li></li>
</ol>
<p>Zrangebyscore 返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)次序排列。</p>
<p>具有相同分数值的成员按字典序来排列(该属性是有序集提供的，不需要额外的计算)。</p>
<p>默认情况下，<strong>区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br></pre></td></tr></table></figure>

<ul>
<li>ZRANGEBYSCORE zset (1 5 == 1 &lt; score &lt;= 5</li>
<li>ZRANGEBYSCORE zset (5 (10 == 5 &lt; score &lt; 10</li>
<li>ZRANGEBYSCORE salary -inf +inf # 显示整个有序集</li>
<li>ZRANGEBYSCORE salary -inf +inf WITHSCORES #显示整个有序集及成员的 score 值</li>
<li>ZRANGEBYSCORE salary -inf 5000 WITHSCORES # 显示工资 &lt;=5000 的所有成员</li>
<li>ZRANGEBYSCORE salary (5000 400000 # 显示工资大于 5000 小于等于 400000 的成员</li>
</ul>
<ol>
<li>Zrevrangebyscore 返回有序集中指定分数区间内的所有的成员。有序集成员按分数值递减(从大到小)的次序排列。 具有相同分数值的成员按字典序的逆序(reverse lexicographical order )排列。</li>
<li>Zcount 命令用于计算有序集合中指定分数区间的成员数量。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCOUNT key min max</span><br></pre></td></tr></table></figure>

<h3 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>游戏排名</li>
<li>微博热点话题</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/03/31/hashmap%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/31/hashmap%E5%AD%A6%E4%B9%A0/" itemprop="url">hashmap学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-31T22:36:51+08:00">
                2021-03-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-Java%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index">
                    <span itemprop="name">Java - Java容器</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/03/30/redis%E6%8C%81%E4%B9%85%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/30/redis%E6%8C%81%E4%B9%85%E5%8C%96/" itemprop="url">redis持久化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-30T23:39:29+08:00">
                2021-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9-redis%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis知识点 - redis配置</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">* 如果1个缓存更新，则3600 seconds (an hour)后备份</span><br><span class="line">* 如果100个缓存更新，则300 seconds (5 minutes)后备份</span><br><span class="line">* 如果10000个缓存更新，则60 seconds后备份</span><br><span class="line">save 3600 1</span><br><span class="line">save 300 100</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> yes:如果save过程出错，则停止写操作</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> no: 可能造成数据不一致</span></span><br><span class="line"></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> yes:开启rdb压缩模式，会造成cpu耗损</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> no：关闭，但是文件会大</span></span><br><span class="line"></span><br><span class="line">rdbchecksum yes</span><br><span class="line"><span class="meta">#</span><span class="bash">yes：使用CRC64算法校验对rdb进行数据校验</span></span><br><span class="line"><span class="meta">#</span><span class="bash">no：不校验</span></span><br></pre></td></tr></table></figure>

<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> AOF 默认关闭，yes可以开启</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> AOF 的文件名</span></span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> no：不同步</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> everysec：每秒备份，推荐使用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> always：每次操作都会备份，安全并且数据完整，但是慢性能差</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重写的时候是否要同步，no可以保证数据安全</span></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重写机制：避免文件越来越大，自动优化压缩指令，会fork一个新的进程去完成重写动作，新进程里的内存数据会被重写，此时旧的aof文件不会被读取使用，类似rdb</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前AOF文件的大小是上次AOF大小的100% 并且文件体积达到64m，满足两者则触发重写</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Redis-的持久化机制是什么？各自的优缺点？"><a href="#Redis-的持久化机制是什么？各自的优缺点？" class="headerlink" title="Redis 的持久化机制是什么？各自的优缺点？"></a>Redis 的持久化机制是什么？各自的优缺点？</h1><p>redis 提供两种持久化方式。</p>
<p><strong>RDB（Redis DataBase）</strong>，用数据集快照的方式，定时将 redis 存储的数据生成快照并存储到磁盘等介质上即在指定目录下生成一个 dump.rdb 文件；</p>
<p>Redis 提供了 SAVE 和BGSAVE两个命令来生成RDB文件，区别是前者是阻塞的，后者是后台 fork 子进程进行，不会阻塞主进程处理命令请求</p>
<p>持久化key之前，会检查是否过期，过期的key不进入RDB文件。数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）。</p>
<p>RDB适合大量数据的恢复，但是数据的完整性和一致性可能会不足。</p>
<p> <strong>AOF（Append -only file）</strong>，Redis默认不开启，它采用日志的形式来记录每个写操作，生成一个appendonly.aof 文件，并将日志追加到文件末尾。Redis重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<p>重写时，会先判断key是否过期，已过期的key不会重写到aof文件。</p>
<p>如果同时存在<code>RDB</code>和<code>AOF</code>的话会优先使用<code>AOF</code> 重建数据集，因为其保存的数据更完整。</p>
<h2 id="RDB-的优点："><a href="#RDB-的优点：" class="headerlink" title="RDB 的优点："></a>RDB 的优点：</h2><ol>
<li><p>每个一段时间备份，全量备份；</p>
</li>
<li><p>容灾简单，可以远程传输</p>
</li>
<li><p>性能最大化，fork 子进程来完成写操作，让主进程继续处理命令且不会进行任何 IO 操作的，这样就确保了 redis 极高的性能；</p>
</li>
<li><p>相对于数据集大时，比 AOF 的启动效率更高。</p>
</li>
</ol>
<h2 id="RDB-的缺点："><a href="#RDB-的缺点：" class="headerlink" title="RDB 的缺点："></a>RDB 的缺点：</h2><p>数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发 生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候；</p>
<p>备份时占用内存，因为Redis在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍），最后再将临时文件替换之前的备份文件</p>
<h2 id="RDB对过期key的处理"><a href="#RDB对过期key的处理" class="headerlink" title="RDB对过期key的处理"></a>RDB对过期key的处理</h2><p>过期key对RDB没有任何影响</p>
<ul>
<li>从内存数据库持久化数据到RDB文件<ul>
<li>持久化key之前，会检查是否过期，过期的key不进入RDB文件</li>
</ul>
</li>
<li>从RDB文件恢复数据到内存数据库<ul>
<li>数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）</li>
</ul>
</li>
</ul>
<h2 id="AOF-的优点："><a href="#AOF-的优点：" class="headerlink" title="AOF 的优点："></a>AOF 的优点：</h2><p>A. 数据安全，aof 持久化可以配置 append fsync 属性，比如无 fsync，每秒钟一次 fsync，或者每次执行写入命令时 fsync，一般只会丢失一秒钟的数据，或者最后一次执行的数据，对缓存来说，这已经足够。<br>B. 某些场景下还可以恢复数据。比如说某同学在操作 redis 时，不小心执行了 FLUSHALL，导致 redis 内存中的数据全部被清空了。如果 AOF 文件还没有被重写（rewrite），我们就可以用最快的速度暂停 redis 并编辑 AOF 文件，将最后一行的 FLUSHALL 命令删除，然后重启 redis，就可以恢复 redis 的所有数据到 FLUSHALL 之前的状态了。</p>
<h2 id="AOF-的缺点："><a href="#AOF-的缺点：" class="headerlink" title="AOF 的缺点："></a>AOF 的缺点：</h2><ol>
<li>相同的数据，同一份数据，AOF比RDB大</li>
<li>针对不同的同步机制，AOF会比RDB慢，因为AOF每秒都会备份做写操作，这样相对与RDB来说就略低。 每秒备份fsync没毛病，但是如果客户端的每次写入就做一次备份fsync的话，那么redis的性能就会下降。</li>
<li>AOF发生过bug，就是数据恢复的时候数据不完整，这样显得AOF会比较脆弱，容易出现bug，因为AOF没有RDB那么简单，但是呢为了防止bug的产生，AOF就不会根据旧的指令去重构，而是根据当时缓存中存在的数据指令去做重构，这样就更加健壮和可靠了。</li>
</ol>
<h2 id="AOF对过期key的处理"><a href="#AOF对过期key的处理" class="headerlink" title="AOF对过期key的处理"></a>AOF对过期key的处理</h2><p>过期key对AOF没有任何影响</p>
<ul>
<li>从内存数据库持久化数据到AOF文件：<ul>
<li>当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）</li>
<li>当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）</li>
</ul>
</li>
<li>AOF重写<ul>
<li>重写时，会先判断key是否过期，已过期的key不会重写到aof文件</li>
</ul>
</li>
</ul>
<h2 id="RDB-和-AOF-对比："><a href="#RDB-和-AOF-对比：" class="headerlink" title="RDB 和 AOF 对比："></a>RDB 和 AOF 对比：</h2><table>
<thead>
<tr>
<th>命令</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>丢数据</td>
<td>根据策略决定</td>
</tr>
<tr>
<td>轻重</td>
<td>重</td>
<td>轻</td>
</tr>
</tbody></table>
<h2 id="AOF-文件太大会怎么样？"><a href="#AOF-文件太大会怎么样？" class="headerlink" title="AOF 文件太大会怎么样？"></a>AOF 文件太大会怎么样？</h2><p>AOF 文件过大时，后台会自动地对 AOF 进行重写（rewrite)，重写时会压缩 AOF 文件的内容，只保留可以恢复数据的最小指令集。比如说，假如我们调用了 100 次 INCR 指令，在 AOF 文件中就要存储 100 条指令，但这明显是很低效的，完全可以把这 100 条指令合并成一条 SET 指令。</p>
<p>在进行 AOF 重写时，仍然是采用先写临时文件，全部完成后再替换的流程，所以断电、磁盘满等问题都不会影响 AOF 文件的可用性。</p>
<h2 id="采用RDB还是AOF"><a href="#采用RDB还是AOF" class="headerlink" title="采用RDB还是AOF"></a>采用RDB还是AOF</h2><ol>
<li>如果你能接受一段时间的缓存丢失，那么可以使用RDB</li>
<li>如果你对实时性的数据比较care，那么就用AOF</li>
<li>使用RDB和AOF结合一起做持久化，RDB做冷备，可以在不同时期对不同版本做恢复，AOF做热备，保证数据仅仅只有1秒的损失。当AOF破损不可用了，那么再用RDB恢复，这样就做到了两者的相互结合，也就是说Redis恢复会先加载AOF，如果AOF有问题会再加载RDB，这样就达到冷热备份的目的了。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/03/30/redis%E9%9B%86%E7%BE%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/30/redis%E9%9B%86%E7%BE%A4/" itemprop="url">redis集群</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-30T23:19:01+08:00">
                2021-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="主从（复制-集群-同步）"><a href="#主从（复制-集群-同步）" class="headerlink" title="主从（复制|集群|同步）"></a>主从（复制|集群|同步）</h1><p>Redis的主从结构可以采用一主多从或者级联结构，Redis主从复制可以根据是否是全量分为全量同步和增量同步</p>
<p><img src="https://nexus-oss-test.oss-cn-shanghai.aliyuncs.com/redis%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6.png"></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>备份数据，这样当一个节点损坏（指不可恢复的硬件损坏）时，数据因为有备份，可以方便恢复。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>master节点挂了以后，redis就不能对外提供写服务了，因为剩下的slave不能成为master。</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>读请求较多场景</p>
<h2 id="Redis主从同步策略"><a href="#Redis主从同步策略" class="headerlink" title="Redis主从同步策略"></a>Redis主从同步策略</h2><p>主从刚刚连接的时候，进行全量同步；</p>
<p>全同步结束后，进行增量同步。</p>
<p>当然，如果有需要，slave 在任何时候都可以发起全量同步。</p>
<p>redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p>
<h2 id="Redis-的同步机制"><a href="#Redis-的同步机制" class="headerlink" title="Redis 的同步机制"></a>Redis 的同步机制</h2><h3 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h3><p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下：</p>
<ul>
<li> 从服务器连接主服务器，发送SYNC命令；</li>
<li> 主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；</li>
<li> 主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；</li>
<li> 从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；</li>
<li> 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；</li>
<li> 从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li>
</ul>
<p><img src="https://nexus-oss-test.oss-cn-shanghai.aliyuncs.com/%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5.png" alt="image"></p>
<p>完成上面几个步骤后就完成了从服务器数据初始化的所有操作，从服务器此时可以接收来自用户的读请求。</p>
<h3 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h3><p>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。<br>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</p>
<h2 id="全量同步时需要注意："><a href="#全量同步时需要注意：" class="headerlink" title="全量同步时需要注意："></a>全量同步时需要注意：</h2><p>如果多个Slave断线了，需重启时，因为只要Slave启动，就会发送sync请求和主机全量同步，当多个同时出现的时候，可能会导致Master IO剧增宕机。</p>
<h2 id="Redis主从复制重要内容"><a href="#Redis主从复制重要内容" class="headerlink" title="Redis主从复制重要内容"></a>Redis主从复制重要内容</h2><blockquote>
<p>Redis主从复制的配置十分简单，它可以使从服务器是主服务器的完全拷贝。需要清楚知道Redis主从复制的几点重要内容：</p>
</blockquote>
<p>1）Redis使用异步复制。但从Redis 2.8开始，从服务器会周期性的应答从复制流中处理的数据量。</p>
<p>2）一个主服务器可以有多个从服务器。</p>
<p>3）从服务器也可以接受其他从服务器的连接。除了多个从服务器连接到一个主服务器之外，多个从服务器也可以连接到一个从服务器上，形成一个图状结构（级联）。</p>
<p>4）Redis主从复制不阻塞主服务器端。也就是说当若干个从服务器在进行初始同步时，主服务器仍然可以处理请求。</p>
<p>5）主从复制也不阻塞从服务器端。当从服务器进行初始同步时，它使用旧版本的数据来应对查询请求（假设你在redis.conf配置文件是这么配置的)。如果不想这样，你可以配置当复制流关闭时让从服务器给客户端返回一个错误。但是当初始同步完成后，需删除旧数据集和加载新的数据集，在这个短暂时间内，从服务器会阻塞连接进来的请求。</p>
<p>6）主从复制可以用来增强扩展性，使用多个从服务器来处理只读的请求（比如，繁重的排序操作可以放到从服务器去做），也可以简单的用来做数据冗余。</p>
<p>7）使用主从复制可以为主服务器免除把数据写入磁盘的消耗：在主服务器的redis.conf文件中配置“避免保存”（注释掉所有“保存“命令），然后连接一个配置为“进行保存”的从服务器即可。但是这个配置要确保主服务器不会自动重启，主redis服务器一旦重启，因为主redis服务器数据为空，这时候通过主从同步可能导致从redis服务器上的数据也被清空；</p>
<h2 id="主从同步注意问题"><a href="#主从同步注意问题" class="headerlink" title="主从同步注意问题"></a>主从同步注意问题</h2><ul>
<li><p>主从服务器之间会定期进行通话，但是如果master上设置了密码，那么如果不给slave设置密码就会导致slave不能跟master进行任何操作</p>
</li>
<li><p>关于slave服务器上过期键的处理，由master服务器负责键的过期删除处理，然后将相关删除命令已数据同步的方式同步给slave服务器，slave服务器根据删除命令删除本地的key。</p>
</li>
</ul>
<h2 id="当主服务器不进行持久化时复制的安全性"><a href="#当主服务器不进行持久化时复制的安全性" class="headerlink" title="当主服务器不进行持久化时复制的安全性"></a>当主服务器不进行持久化时复制的安全性</h2><p>在进行主从复制设置时，强烈建议在主服务器上开启持久化，当不能这么做时，比如考虑到延迟的问题，应该将实例配置为避免自动重启。</p>
<h3 id="为什么不持久化的主服务器自动重启非常危险呢？"><a href="#为什么不持久化的主服务器自动重启非常危险呢？" class="headerlink" title="为什么不持久化的主服务器自动重启非常危险呢？"></a>为什么不持久化的主服务器自动重启非常危险呢？</h3><p>为了更好的理解这个问题，看下面这个失败的例子，其中主服务器和从服务器中数据库都被删除了</p>
<p>设置节点A为主服务器，关闭持久化，节点B和C从节点A复制数据。这时出现了一个崩溃，但Redis具有自动重启系统，重启了进程，因为关闭了持久化，节点重启后只有一个空的数据集。节点B和C从节点A进行复制，现在节点A是空的，所以节点B和C上的复制数据也会被删除。当在高可用系统中使用Redis Sentinel，关闭了主服务器的持久化，并且允许自动重启，这种情况是很危险的。比如主服务器可能在很短的时间就完成了重启，以至于Sentinel都无法检测到这次失败，那么上面说的这种失败的情况就发生了。如果数据比较重要，并且在使用主从复制时关闭了主服务器持久化功能的场景中，都应该禁止实例自动重启。</p>
<hr>
<h1 id="Redis无磁盘化复制"><a href="#Redis无磁盘化复制" class="headerlink" title="Redis无磁盘化复制"></a>Redis无磁盘化复制</h1><p>通过内存之间的传输，通过socket实现。</p>
<p><img src="https://nexus-oss-test.oss-cn-shanghai.aliyuncs.com/Redis%E6%97%A0%E7%A3%81%E7%9B%98%E5%8C%96%E5%A4%8D%E5%88%B6.png" alt="image"></p>
<ul>
<li><p>磁盘有普通机械硬盘和SSD固定硬盘。如果是普通机械硬盘，硬盘读写效率低下。这样就出现了无磁盘化复制，从而提高了效率。</p>
</li>
<li><p>默认是关闭的</p>
</li>
<li><p>开启式将<code>repl-diskless-sync no --&gt;repl-diskless-sync yes</code></p>
</li>
</ul>
<h1 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h1><h2 id="为何要有哨兵模式"><a href="#为何要有哨兵模式" class="headerlink" title="为何要有哨兵模式"></a>为何要有哨兵模式</h2><p>主从模式下<br>Master挂了，如何保证可用性，实现继续读写</p>
<h2 id="什么是哨兵"><a href="#什么是哨兵" class="headerlink" title="什么是哨兵"></a>什么是哨兵</h2><p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.png"></p>
<p>Sentinel(哨兵)是用于监控Redis集群中Master状态的工具，是 Redis 高可用解决方案，哨兵可以监视一个或者多个redis master服务，以及这些master服务的所有从服务；当某个master服务宕机后，会把这个master下的某个从服务升级为master来替代已宕机的master继续工作。</p>
<h2 id="哨兵模式的作用"><a href="#哨兵模式的作用" class="headerlink" title="哨兵模式的作用"></a>哨兵模式的作用</h2><ul>
<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器；</li>
<li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机；</li>
</ul>
<h2 id="哨兵模式的工作方式："><a href="#哨兵模式的工作方式：" class="headerlink" title="哨兵模式的工作方式："></a>哨兵模式的工作方式：</h2><ul>
<li>每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。</li>
<li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）</li>
<li>如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了主观下线状态</li>
<li>当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为客观下线（ODOWN）</li>
<li>在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。</li>
<li>当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</li>
<li>若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。</li>
</ul>
<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><p>哨兵模式是基于主从模式的，解决了主从模式下master挂了无法提供写服务的情况</p>
<h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><p>当数据量过大到一台服务器存放不下的情况（内存不够时），主从模式或sentinel模式就不能满足需求了</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>存储量不大，单机可承受。</p>
<h2 id="部署归约"><a href="#部署归约" class="headerlink" title="部署归约"></a>部署归约</h2><ul>
<li>哨兵节点至少要有3个或奇数个节点</li>
<li>哨兵分布式部署到不同计算机节点</li>
<li>一组哨兵只监听一组主从</li>
</ul>
<h3 id="哨兵监控"><a href="#哨兵监控" class="headerlink" title="哨兵监控"></a>哨兵监控</h3><p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/%E5%93%A8%E5%85%B5%E7%9B%91%E6%8E%A7.png"></p>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><blockquote>
<p>推荐哨兵个数为奇数台，避免对半分</p>
</blockquote>
<p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行故障转移（ failover） 过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。</p>
<p>当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行故障转移（ failover）操作。</p>
<p>切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。 </p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/redis%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E8%BF%87%E7%A8%8B.png"></p>
<h3 id="选举Leader"><a href="#选举Leader" class="headerlink" title="选举Leader"></a>选举Leader</h3><blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">剩余的slaves重新和新的master做同步的并行个数</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/%E9%80%89%E4%B8%BEleader.png"></p>
<h3 id="原master恢复"><a href="#原master恢复" class="headerlink" title="原master恢复"></a>原master恢复</h3><p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/redismaster%E8%8A%82%E7%82%B9%E6%81%A2%E5%A4%8D.png"></p>
<h1 id="Cluster集群模式"><a href="#Cluster集群模式" class="headerlink" title="Cluster集群模式"></a>Cluster集群模式</h1><p><img src="https://nexus-oss-test.oss-cn-shanghai.aliyuncs.com/Cluster%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F.png" alt="image"></p>
<h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>在 Redis 的每一个节点上，都有这么两个东西，一个是<strong>插槽（slot）</strong>，它的的取值范围是：0-16383。还有一个就是<strong>cluster</strong>，可以理解为是一个集群管理的插件。<strong>当我们的存取的 Key到达的时候，Redis 会根据 crc16的算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽</strong>，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个<strong>对应的节点上</strong>进行存取操作。</p>
<p>为了保证高可用，redis-cluster集群引入了<strong>主从模式</strong>，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。当其它主节点ping一个主节点A时，<strong>如果半数以上的主节点与A通信超时，那么认为主节点A宕机了</strong>。如果主节点A和它的从节点A1都宕机了，那么该集群就无法再提供服务了。</p>
<p><strong>优点</strong>：</p>
<ol>
<li>无中心架构：三机房部署，其中一主一从构成一个分片，之间通过异步复制同步数据，异步复制存在数据不一致的时间窗口，保证高性能的同时牺牲了部分一致性一旦某个机房掉线，则分片上位于另一个机房的 slave 会被提升为 master 从而可以继续提供服务</li>
<li>可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除。</li>
<li>降低运维成本，提高系统的扩展性和可用性。</li>
</ol>
<p><strong>使用场景</strong>：数据量大，高并发场景</p>
<h2 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h2><p>构建Redis集群，需要至少3个节点作为master，以此组成一个高可用的集群，此外每个master都需要配备一个slave，所以整个集群需要6个节点，这也是最经典的Redis集群，也可以称之为三主三从，容错性更佳。所以在搭建的时候需要有6台虚拟机。</p>
<h2 id="Redis-Cluster-实现的功能："><a href="#Redis-Cluster-实现的功能：" class="headerlink" title="Redis Cluster 实现的功能："></a>Redis Cluster 实现的功能：</h2><ul>
<li>将数据分片到多个实例 (按照 slot 存储)；</li>
<li>集群节点宕掉会自动 failover；</li>
<li>提供相对平滑扩容 (缩容) 节点。</li>
</ul>
<hr>
<h1 id="Redis-集群方案什么情况下会导致整个集群不可用？"><a href="#Redis-集群方案什么情况下会导致整个集群不可用？" class="headerlink" title="Redis 集群方案什么情况下会导致整个集群不可用？"></a>Redis 集群方案什么情况下会导致整个集群不可用？</h1><p>有 A，B，C 三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。</p>
<h1 id="redis集群相关问题"><a href="#redis集群相关问题" class="headerlink" title="redis集群相关问题"></a>redis集群相关问题</h1><h2 id="说说-Redis-哈希槽的概念？"><a href="#说说-Redis-哈希槽的概念？" class="headerlink" title="说说 Redis 哈希槽的概念？"></a>说说 Redis 哈希槽的概念？</h2><p>Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p>
<h2 id="Redis-集群的主从复制模型是怎样的？"><a href="#Redis-集群的主从复制模型是怎样的？" class="headerlink" title="Redis 集群的主从复制模型是怎样的？"></a>Redis 集群的主从复制模型是怎样的？</h2><p>为了是在部分节点失败或者大部分节点无法通信的的情况下集群仍然可用，所以集群使用了主从复制模型，<br>每个节点都会有N-1个复制品</p>
<h2 id="Redis-集群会有写操作丢失吗？为什么？"><a href="#Redis-集群会有写操作丢失吗？为什么？" class="headerlink" title="Redis 集群会有写操作丢失吗？为什么？"></a>Redis 集群会有写操作丢失吗？为什么？</h2><p>Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p>
<h2 id="Redis-集群之间是如何复制的？"><a href="#Redis-集群之间是如何复制的？" class="headerlink" title="Redis 集群之间是如何复制的？"></a>Redis 集群之间是如何复制的？</h2><p>异步复制</p>
<h2 id="Redis-集群最大节点个数是多少？"><a href="#Redis-集群最大节点个数是多少？" class="headerlink" title="Redis 集群最大节点个数是多少？"></a>Redis 集群最大节点个数是多少？</h2><p>16384 个。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <!--<a href="/archives/%7C%7Carchive">-->
                <a href="/archives/">
              
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuanyayuan" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:liyuan0707@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LiYuan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
