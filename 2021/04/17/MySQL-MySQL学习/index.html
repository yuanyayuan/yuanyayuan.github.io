<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="数据库,MySQL," />










<meta name="description" content="SQL语句一条SQL语句在MySQL中如何执行的SQL 等执行过程分为两类 对于查询等过程如下：权限校验—》查询缓存—》分析器—》优化器—》权限校验—》执行器—》引擎 对于更新等语句执行流程如下：分析器—-》权限校验—-》执行器—》引擎—》redo log prepare—》binlog—》redo log commit SELECT * 和 SELECT 全部字段两种写法有何优缺点? 前者要解析">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL-MySQL学习">
<meta property="og:url" content="https://yuanyayuan.github.io/2021/04/17/MySQL-MySQL%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hikari的Java之路">
<meta property="og:description" content="SQL语句一条SQL语句在MySQL中如何执行的SQL 等执行过程分为两类 对于查询等过程如下：权限校验—》查询缓存—》分析器—》优化器—》权限校验—》执行器—》引擎 对于更新等语句执行流程如下：分析器—-》权限校验—-》执行器—》引擎—》redo log prepare—》binlog—》redo log commit SELECT * 和 SELECT 全部字段两种写法有何优缺点? 前者要解析">
<meta property="og:locale">
<meta property="og:image" content="file:///E:/YouDaoYun/m18739288920@163.com/8dbe6e2d4f1e489d86f88afbbeda5c9b/xtnpu3ir.bmp?ynotemdtimestamp=1618651314817">
<meta property="og:image" content="file:///E:/YouDaoYun/m18739288920@163.com/3b1a0be34dfa49e2a7dced52699dbd92/ygkj4yk5.bmp?ynotemdtimestamp=1618651314817">
<meta property="article:published_time" content="2021-04-17T09:50:40.000Z">
<meta property="article:modified_time" content="2021-05-10T07:50:00.317Z">
<meta property="article:author" content="LiYuan">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="file:///E:/YouDaoYun/m18739288920@163.com/8dbe6e2d4f1e489d86f88afbbeda5c9b/xtnpu3ir.bmp?ynotemdtimestamp=1618651314817">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yuanyayuan.github.io/2021/04/17/MySQL-MySQL学习/"/>





  <title>MySQL-MySQL学习 | Hikari的Java之路</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hikari的Java之路</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Hello,world</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/17/MySQL-MySQL%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">MySQL-MySQL学习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-17T17:50:40+08:00">
                2021-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL-MySQL%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL - MySQL知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h1><h2 id="一条SQL语句在MySQL中如何执行的"><a href="#一条SQL语句在MySQL中如何执行的" class="headerlink" title="一条SQL语句在MySQL中如何执行的"></a>一条SQL语句在MySQL中如何执行的</h2><p>SQL 等执行过程分为两类</p>
<p>对于查询等过程如下：权限校验—》查询缓存—》分析器—》优化器—》权限校验—》执行器—》引擎</p>
<p>对于更新等语句执行流程如下：分析器—-》权限校验—-》执行器—》引擎—》redo log prepare—》binlog—》redo log commit</p>
<h2 id="SELECT-和-SELECT-全部字段两种写法有何优缺点"><a href="#SELECT-和-SELECT-全部字段两种写法有何优缺点" class="headerlink" title="SELECT * 和 SELECT 全部字段两种写法有何优缺点?"></a>SELECT * 和 SELECT 全部字段两种写法有何优缺点?</h2><ol>
<li>前者要解析数据字典，后者不需要；</li>
<li>结果输出顺序，前者与建表列顺序相同，后者按指定字段顺序；</li>
<li>表字段改名，前者不需要修改，后者需要改；</li>
<li>后者可以建立索引进行优化，前者无法优化；</li>
</ol>
<h2 id="LiKE声明中的％和-是什么意思？"><a href="#LiKE声明中的％和-是什么意思？" class="headerlink" title="LiKE声明中的％和_是什么意思？"></a>LiKE声明中的％和_是什么意思？</h2><p>％对应于0个或更多字符，_只是LIKE语句中的一个字符。</p>
<h2 id="HAVNG-子句-和-WHERE-的异同点"><a href="#HAVNG-子句-和-WHERE-的异同点" class="headerlink" title="HAVNG 子句 和 WHERE 的异同点?"></a>HAVNG 子句 和 WHERE 的异同点?</h2><ol>
<li>语法上：where 用表中列名，having 用 select 结果别名；</li>
<li>影响结果范围：where 从表读出数据的行数，having 返回客户端的行数</li>
<li>索引：where 可以使用索引，having 不能使用索引，只能在临时结果集操作</li>
<li>where 后面不能使用聚集函数，having 是专门使用聚集函数的。</li>
</ol>
<h2 id="一个-SQL-执行的很慢的原因"><a href="#一个-SQL-执行的很慢的原因" class="headerlink" title="一个 SQL 执行的很慢的原因"></a>一个 SQL 执行的很慢的原因</h2><p>1、大多数情况下很正常，偶尔很慢，则有如下原因</p>
<p>(1)、数据库在刷新脏页，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">redo log 写满了需要同步到磁盘。</span><br><span class="line">内存不够用了</span><br></pre></td></tr></table></figure>

<p>(2)、执行的时候，遇到锁，如表锁、行锁。</p>
<p>2、这条 SQL 语句一直执行的很慢，则有如下原因。</p>
<p>(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。</p>
<p>(2)、数据库选错了索引。系统是通过索引的区分度来判断的,区分度称之为基数。系统采样的方式，来预测索引的基数的，由于统计的失误会预测错索引的基数，导致系统没有走索引，而是走了全表扫描</p>
<h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><h2 id="为什么用自增列作为主键"><a href="#为什么用自增列作为主键" class="headerlink" title="为什么用自增列作为主键"></a>为什么用自增列作为主键</h2><ul>
<li>如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引</li>
<li>数据记录本身被存于主索引（⼀颗B+Tree）的叶子节点上，这就要求同⼀个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放</li>
<li>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟⼀个新的页</li>
<li>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置</li>
</ul>
<h2 id="MySQL-中-TIMESTAMP和DATETIME的区别"><a href="#MySQL-中-TIMESTAMP和DATETIME的区别" class="headerlink" title="MySQL 中 TIMESTAMP和DATETIME的区别"></a>MySQL 中 TIMESTAMP和DATETIME的区别</h2><table>
<thead>
<tr>
<th>类型</th>
<th>TIMESTAMP</th>
<th>DATETIME</th>
</tr>
</thead>
<tbody><tr>
<td>不同点</td>
<td>存储空间：TIMESTAMP占用4个字节</td>
<td>存储空间：DATETIME占用8个字节</td>
</tr>
<tr>
<td></td>
<td>时区：TIMESTAMP实际记录的是1970-01-01 00:00:01到现在的数数，受时区影响</td>
<td>时区：DATETIME不受时区影响</td>
</tr>
<tr>
<td></td>
<td>存储方式：对于TIMESTAMP，它把客户端插入的时间从当前时区转化为UTC（世界标准时间）进行存储。查询时，将其又转化为客户端当前时区进行返回(中国属于东八区，所以应该是UTC+8）。</td>
<td>存储方式：而对于DATETIME，不做任何改变，基本上是原样输入和输出。</td>
</tr>
</tbody></table>
<h2 id="自增ID问题"><a href="#自增ID问题" class="headerlink" title="自增ID问题"></a>自增ID问题</h2><p>一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</p>
<ol>
<li><p>如果表的类型是MyISAM，那么是18<br>因为MyISAM表会把自增主键的最大ID记录到数据文件里，重启MySQL自增主键的最大ID也不会丢失</p>
</li>
<li><p>如果表的类型是InnoDB，那么是15<br>InnoDB表只是把自增主键的最大ID记录到内存中，所以重启数据库或者是对表进行OPTIMIZE操作，都会导致最大ID丢失</p>
</li>
</ol>
<h1 id="引擎（MySQL-支持哪些存储引擎）"><a href="#引擎（MySQL-支持哪些存储引擎）" class="headerlink" title="引擎（MySQL 支持哪些存储引擎）"></a>引擎（MySQL 支持哪些存储引擎）</h1><p>MySQL 支持的存储引擎主要有四种：</p>
<ol>
<li><strong>InnoDB</strong> 支持<strong>事务</strong>，<strong>行级锁</strong>和<strong>外键</strong>，是<strong>事务型</strong>数据库的首选引擎；MySQL5.5.5 之后的默认存储引擎；</li>
<li><strong>MyISAM</strong> 拥有较高的插入、查询速度，但<strong>不支持事务</strong>。MySQL5.5.5 之前的默认存储引擎；</li>
<li><strong>Memory</strong> 基于散列，存储在内存中，对临时表有用。常见的应用场景是：<strong>临时存放数据，数据量不大，并且不需要较高的数据安全性</strong>；</li>
<li><strong>Archive</strong> 支持<strong>高并发</strong>的插入操作，但是本身不是事务安全的。常见的应用场景：<strong>存储归档数据，如记录日志信息可以使用 Archive</strong>。</li>
</ol>
<h2 id="InnoDB和MyISAM区别"><a href="#InnoDB和MyISAM区别" class="headerlink" title="InnoDB和MyISAM区别"></a>InnoDB和MyISAM区别</h2><p>最常用的存储引擎是InnoDB引擎和MyISAM存储引擎，InnoDB是MySQL的默认事务引擎。</p>
<table>
<thead>
<tr>
<th>特性比较</th>
<th>事务</th>
<th>并发</th>
<th>外键</th>
<th>备份</th>
<th>崩溃恢复</th>
<th>索引类型</th>
<th>全文索引</th>
<th>执行select count(*) from table时</th>
</tr>
</thead>
<tbody><tr>
<td>InnoDB</td>
<td>事务型</td>
<td>行级锁</td>
<td>支持</td>
<td>在线热备</td>
<td>概率低</td>
<td>InnoDB-聚集索引</td>
<td>不支持全文索引，</td>
<td>InnoDB不保存表的具体行数，需要全表扫描</td>
</tr>
<tr>
<td>MyISAM</td>
<td>非事务性</td>
<td>行级锁</td>
<td>支持</td>
<td>不支持</td>
<td>慢，已丢失</td>
<td>MyISAM-非聚集索引</td>
<td>支持全文索引</td>
<td>MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可</td>
</tr>
</tbody></table>
<h2 id="介绍一下mysql的MVCC机制："><a href="#介绍一下mysql的MVCC机制：" class="headerlink" title="介绍一下mysql的MVCC机制："></a>介绍一下mysql的MVCC机制：</h2><p>MVCC是一种多版本并发控制机制InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别，不可提交读不能使用它的原因是不能读取符合事物版本的行版本。它们总是读取最新的行版本</p>
<p><strong>InnoDB实现MVCC的方法</strong>：它存储了每一行的两个额外的隐藏字段，这两个隐藏字段分别记录了行的创建的时间和删除的时间。在每个事件发生的时 候，每行存储版本号，而不是存储事件实际发生的时间。每次事务的开始这个版本号都会增加</p>
<h1 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h1><p>第一范式：列不可再分<br>第二范式：行可以唯一区分，主键约束<br>第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束<br>且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上 。</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>索引是数据结构，可以帮助我们快速的进行数据的查找</p>
<p>**MySQL索引使用的数据结构为B+树 **</p>
<blockquote>
<p>哈希索引也可以使用 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候。</p>
</blockquote>
<h2 id="MySQL索引数据结构使用B-Tree"><a href="#MySQL索引数据结构使用B-Tree" class="headerlink" title="MySQL索引数据结构使用B+Tree"></a>MySQL索引数据结构使用B+Tree</h2><ul>
<li><p>“非聚簇索引”：<strong>B+Tree叶节点的data域存放的是数据记录的地址</strong>。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录</p>
<blockquote>
<p><strong>非聚集索引</strong> (secondary index)，又称为<strong>辅助索引</strong>、<strong>普通索引</strong>，该索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表可以包含多个非聚集索引。</p>
</blockquote>
</li>
<li><p>“聚簇索引（或聚集索引）”：<strong>其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录</strong>。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引</p>
<blockquote>
<p><strong>聚集索引</strong> (clustered index)，又称为<strong>主索引</strong>，该索引中键值的逻辑顺序决定了表中相应行的物理顺序。因为数据真正的数据只能有一种排序方式，所以一个表上只能有一个聚簇索引。</p>
</blockquote>
</li>
</ul>
<p>在使用非聚集索引进行查找时，需要先查找到主键值，然后再到聚集索引中进行查找，这称之为回表查询。<strong>非聚簇索引不一定会回表查询（当查询语句所要求的字段全部命中了索引，就不用再回表查询了）</strong></p>
<p>在根据主索引搜索时，直接找到key所在的节点即可取出数据。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
<h2 id="为什么不适用-B-树？"><a href="#为什么不适用-B-树？" class="headerlink" title="为什么不适用 B 树？"></a>为什么不适用 B 树？</h2><p>B + 树所有的 Data 域在叶子节点，其余节点用来索引，</p>
<p><img src="file:///E:/YouDaoYun/m18739288920@163.com/8dbe6e2d4f1e489d86f88afbbeda5c9b/xtnpu3ir.bmp?ynotemdtimestamp=1618651314817" alt="image"></p>
<p>而 B 树是每个索引节点都会有 Data 域；</p>
<p><img src="file:///E:/YouDaoYun/m18739288920@163.com/3b1a0be34dfa49e2a7dced52699dbd92/ygkj4yk5.bmp?ynotemdtimestamp=1618651314817" alt="image"></p>
<p>并且 B + 树所有叶子节点之间都有一个链指针。</p>
<p>这样遍历叶子节点就能获得全部数据，从而支持区分查询。在数据库中基于范围的查询是非常频繁的，而 B 树不支持这样的遍历操作。</p>
<h2 id="为什么不用哈希表？"><a href="#为什么不用哈希表？" class="headerlink" title="为什么不用哈希表？"></a>为什么不用哈希表？</h2><p>（1）哈希表只适用与查找等值查询， 不能支持区分条件（大于小于查询）、模糊查询等；</p>
<p>（2）hash 索引虽然在等值查询上较快，但是不稳定，性能不可预测，当某个键值存在大量重复的时候，发生 hash 碰撞，此时效率可能极差。而 B + 树的查询效率比较稳定。</p>
<h2 id="为什么不用红黑树？"><a href="#为什么不用红黑树？" class="headerlink" title="为什么不用红黑树？"></a>为什么不用红黑树？</h2><p>红黑树往往高度过大，从页造成磁盘 IO 读写过于频繁，效率低下。而且逻辑上很近的节点（父子）物理上可能很远，无法利用局部性原理。</p>
<h2 id="Hash索引和B-树所有有什么区别或者说优劣呢"><a href="#Hash索引和B-树所有有什么区别或者说优劣呢" class="headerlink" title="Hash索引和B+树所有有什么区别或者说优劣呢?"></a>Hash索引和B+树所有有什么区别或者说优劣呢?</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据；</p>
<p>B+树底层实现是多路平衡查找树，对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据.。</p>
<h3 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h3><p>1、hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询.</p>
<p>因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</p>
<p>2、hash索引不支持使用索引进行排序，原理同上；</p>
<p>3、hash索引不支持模糊查询以及多列索引的最左前缀匹配，原理也是因为hash函数的不可预测.AAAA和AAAAB的索引没有相关性；</p>
<p>4、hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询；</p>
<p>5、hash索引虽然在等值查询上较快,但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</p>
<p>因此在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度，而不需要使用hash索引。</p>
<h2 id="MySQL-支持的索引类型是哪些？"><a href="#MySQL-支持的索引类型是哪些？" class="headerlink" title="MySQL 支持的索引类型是哪些？"></a>MySQL 支持的索引类型是哪些？</h2><ol>
<li>普通索引：用表中的普通列构建的索引，没有任何限制；</li>
<li>唯一索引：唯一索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的合必须唯一；</li>
<li>主键索引：是一种特殊的唯一索引，根据主键建立索引，不允许重复，不允许空值；</li>
<li>全文索引：通过过建立倒排索引，快速匹配文档的方式。MySQL 5.7.6 之前仅支持英文，MySQL 5.7.6 之后支持中文；</li>
<li>组合索引：又叫联合索引。用多个列组合构建的索引，这多个列中的值不允许有空值。可以在创建表的时候指定，也可以修改表结构。</li>
</ol>
<h2 id="建立索引的原则有哪些？"><a href="#建立索引的原则有哪些？" class="headerlink" title="建立索引的原则有哪些？"></a>建立索引的原则有哪些？</h2><ul>
<li><p>经常需要操作的地方加上索引</p>
<ul>
<li>经常需要搜索的列上，可以加快搜索的速度</li>
<li>经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度</li>
<li>经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间</li>
<li>经常用在经常用在联表的列，这些列主要是一些外键，可以加快连接的速度</li>
</ul>
</li>
<li><p>不适合建索引</p>
<ul>
<li>特大型表的话维护开销会很大，不适合建索引</li>
<li>where 子句中对字段施加函数，不适合建索引</li>
<li>在使用InnoDB时使用业务主键，不适合建索引</li>
</ul>
</li>
<li><p>将某一列设置为default null，where 是可以走索引</p>
</li>
<li><p>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</p>
</li>
</ul>
<h2 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h2><p>MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name&#x3D;xx and city&#x3D;xx ; ／／可以命中索引</span><br><span class="line">select * from user where name&#x3D;xx ; &#x2F;&#x2F; 可以命中索引</span><br><span class="line">select * from user where city&#x3D;xx ; &#x2F;&#x2F; 无法命中索引            </span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 city= xx and name ＝xx，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。</p>
<p>由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDER BY子句也遵循此规则。</p>
<h2 id="索引这么多优点，为什么不对表中的每一个列创建一个索引呢？（索引建立不是越多越好）"><a href="#索引这么多优点，为什么不对表中的每一个列创建一个索引呢？（索引建立不是越多越好）" class="headerlink" title="索引这么多优点，为什么不对表中的每一个列创建一个索引呢？（索引建立不是越多越好）"></a>索引这么多优点，为什么不对表中的每一个列创建一个索引呢？（索引建立不是越多越好）</h2><ol>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
</ol>
<h2 id="索引什么时候会失效？"><a href="#索引什么时候会失效？" class="headerlink" title="索引什么时候会失效？"></a>索引什么时候会失效？</h2><p>（1）条件中有 or；</p>
<p>（2）like 查询（以 % 开头）；</p>
<p>（3）如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不使用索引；</p>
<p>（4）对列进行函数运算（如 where md5 (password) = “xxxx”）；</p>
<p>（5）负向查询条件会导致无法使用索引，比如 NOT IN,NOT LIKE,!= 等；</p>
<p>（6）对于联合索引，不符合最左匹配的；</p>
<p>（7）如果 mysql 评估使用全表扫描要比使用索引快，则不使用索引；</p>
<h2 id="使用索引查询一定能提高查询的性能吗？为什么"><a href="#使用索引查询一定能提高查询的性能吗？为什么" class="headerlink" title="使用索引查询一定能提高查询的性能吗？为什么"></a>使用索引查询一定能提高查询的性能吗？为什么</h2><p>通常,通过索引查询数据比全表扫描要快，但是当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护。</p>
<p>索引范围查询(INDEX RANGE SCAN)适用于两种情况:</p>
<ul>
<li>基于一个范围的检索,一般查询返回结果集小于表中记录数的30%</li>
<li>基于非唯一性索引的检索</li>
</ul>
<h2 id="为什么索引能提高查询速度"><a href="#为什么索引能提高查询速度" class="headerlink" title="为什么索引能提高查询速度"></a>为什么索引能提高查询速度</h2><p>MySQL的基本存储结构是页(记录都存在页里边)</p>
<p>各个数据页可以组成一个双向链表</p>
<p>每个数据页中的记录又可以组成一个单向链表</p>
<p>如果不用索引：定位到记录所在的页需要遍历双向链表，找到所在的页，从所在的页内中查找相应的记录。由于不是根据主键查询，只能遍历所在页的单链表了</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a>事务有哪些特性？</h2><p>1、原子性（Atomicity）：事务是一个不可分割的单位，事务中的所有SQL等操作要么都发生，要么都不发生。</p>
<p>2、一致性（Consistency）：事务发生前和发生后，数据的完整性必须保持一致。</p>
<p>3、隔离性（Isolation）：当并发访问数据库时，一个正在执行的事务在执行完毕前，对应其他的会话是不可见的，多个并发事务之间的数据是相互隔离的。备份的参数 –single-transaction</p>
<p>4、持久性（Durability）：一个事务一旦被提交，它对数据库中的数据改变就是永久性的。如果出了错误，事务也不允许撤销，只能通过“补偿性事务”。</p>
<h2 id="MySQL中InnoDB引擎的行锁是通过加在什么上完成-或称实现-的？为什么是这样子的？"><a href="#MySQL中InnoDB引擎的行锁是通过加在什么上完成-或称实现-的？为什么是这样子的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？"></a>MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？</h2><p>InnoDB是基于索引来完成行锁。</p>
<p>例如在<code>select * from tab_with_index where id = 1 for update</code>中。for update 可以根据条件来完成行锁锁定,并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起。</p>
<h2 id="并发事务带来哪些问题"><a href="#并发事务带来哪些问题" class="headerlink" title="并发事务带来哪些问题?"></a>并发事务带来哪些问题?</h2><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一<br>数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>
<p><strong>脏读（Dirty read）</strong>: 一个事务读取了另一个事务还未提交的数据，针对单笔数据</p>
<p><strong>丢失修改（Lost to modify）</strong>: 一个事务修改了另一个事务还未提交的数据，针对单笔数据</p>
<p><strong>不可重复读（Unrepeatableread）</strong>: 一个事务内多次读同一数据，另一个事务在其还未提交时修改了该数据</p>
<p><strong>幻读（Phantom read）</strong>: 一个事务内多次读同一数据，另一个事务在其还未提交时增加或删除一些数据</p>
<p><strong>不可重复读和幻读区别</strong>：<br>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者<br>删除比如多次读取一条记录发现记录增多或减少了</p>
<h2 id="详述一下数据库事务隔离的四个级别"><a href="#详述一下数据库事务隔离的四个级别" class="headerlink" title="详述一下数据库事务隔离的四个级别"></a>详述一下数据库事务隔离的四个级别</h2><blockquote>
<p>MySQL 的默认事务处理级别是可重复读，Oracle 的默认事务处理级别是读提交。</p>
</blockquote>
<p>（1）Read Uncommitted（<strong>读未提交</strong>）：事务可以看到其他<strong>未提交事务</strong>的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。而且可能出现<strong>脏读</strong>（Dirty Read），即<strong>一个事务读取到另一个事务还有没提交的记录</strong>。</p>
<p>（2） Read Committed（<strong>读提交</strong>） ：事务只能看见<strong>已经提交的事务</strong>所做的改变。这种隔离级别可能导致<strong>不可重复读</strong>（Nonrepeatable Read），<strong>即同一事务的其他实例在该实例处理其间可能会有新的 commit，所以同一个查询操作执行两次或多次的结果不一致</strong>。</p>
<p>（3）Repeatable Read（<strong>可重复读</strong>） ， <strong>事务的多个实例在并发读取数据时读到同样的数据行</strong>。不过理论上，这会导致另一个棘手的问题：<strong>幻读</strong>（PhantomRead），它是指<strong>当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的 “幻影” 数据</strong>。</p>
<p>（4）Serializable（<strong>串行化</strong>） ：通过强制<strong>事务排序</strong>，使之不可能相互冲突，从而解决幻读问题。简言之，它是在<strong>每个读的数据行上加上共享锁</strong>。在这个级别，可能导致<strong>大量的超时现象和锁竞争</strong>。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻影读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED（<strong>读未提交</strong>）</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED（<strong>读提交</strong>）</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ（<strong>可重复读</strong>）</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE（<strong>串行化</strong>）</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>在MySQL主从复制架构中，读操作可以在所有的服务器上面进行，而写操作只能在主服务器上面进行。</p>
<ol>
<li><p>基于SQL语句的复制（statement-based replication,SBR）（目前默认的复制方式）</p>
<ul>
<li>优点<ul>
<li>历史悠久，技术成熟</li>
<li>binlog文件较小</li>
<li>binlog中包含了所有数据库更改信息，可以据此来审核数据库的安全等情况</li>
<li>binlog可以用于实时的还原，而不仅仅用于复制</li>
<li>主从版本可以不一样，从服务器版本可以比主服务器版本高</li>
</ul>
</li>
<li>缺点<ul>
<li>复制需要进行全表扫描(WHERE 语句中没有使用到索引)的 UPDATE 时，需要比 RBR 请求更多的行级锁</li>
<li>对于一些复杂的语句，在从服务器上的耗资源情况会更严重，而 RBR 模式下，只会对那个发生变化的记录产生影响</li>
</ul>
</li>
</ul>
</li>
<li><p>基于行的复制（row-based replication,RBR）MySQL 5以后才出现</p>
<ul>
<li>优点<ul>
<li>任何情况都可以被复制，这对复制来说是最安全可靠的</li>
<li>多数情况下，从服务器上的表如果有主键的话，复制就会快了很多</li>
</ul>
</li>
<li>缺点<ul>
<li>binlog 大了很多</li>
<li>复杂的回滚时 binlog 中会包含大量的数据</li>
<li>主服务器上执行 UPDATE 语句时，所有发生变化的记录都会写到 binlog 中，而 SBR 只会写一次，这会导致频繁发生 binlog 的并发写问题</li>
<li>无法从 binlog 中看到都复制了写什么语句</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="复制过程："><a href="#复制过程：" class="headerlink" title="复制过程："></a>复制过程：</h2><ol>
<li><strong>在每个事务更新数据完成之前，master在二进制日志记录这些改变</strong>。写入二进制日志完成后，master通知存储引擎提交事务。</li>
<li><strong>Slave将master的二进制日志（binary log）复制到其中继日志</strong>。首先slave开始一个工作线程（I/O），I/O线程在master上打开一个普通的连接，然后开始binlog dump process。binlog dump process从master的二进制日志中读取事件，如果已经跟上master，它会睡眠并等待master产生新的事件，I/O线程将这些事件写入中继日志。</li>
<li>Sql slave thread（sql从线程）处理该过程的最后一步，<strong>sql线程从中继日志读取事件，并重放其中的事件而更新slave数据，使其与master中的数据一致</strong>，只要该线程与I/O线程保持一致，中继日志通常会位于os缓存中，所以中继日志的开销很小。</li>
</ol>
<h2 id="目前准备做数据库水平切分，需要注意什么关键问题？"><a href="#目前准备做数据库水平切分，需要注意什么关键问题？" class="headerlink" title="目前准备做数据库水平切分，需要注意什么关键问题？"></a>目前准备做数据库水平切分，需要注意什么关键问题？</h2><p>（1）需要注意分库patition key的选取，要保证两个均衡：数据量的均衡，请求量的均衡。</p>
<p>（2）分库后，需要注意分之前用SQL满足的需求是否还能满足，需要怎么改进满足，例如max, min, avg, sum都需要在服务层再做一次聚合。</p>
<p>（3）夸库事务，分布式事务，在吞吐量是主要矛盾的互联网场景，目前没有能够很好解决的方案，尽量避免。</p>
<h2 id="如果分库分表的情况下碰到要对一个表或多个表关联并且按多个字段为条件进行检索的情况下怎么办呢"><a href="#如果分库分表的情况下碰到要对一个表或多个表关联并且按多个字段为条件进行检索的情况下怎么办呢" class="headerlink" title="如果分库分表的情况下碰到要对一个表或多个表关联并且按多个字段为条件进行检索的情况下怎么办呢"></a>如果分库分表的情况下碰到要对一个表或多个表关联并且按多个字段为条件进行检索的情况下怎么办呢</h2><ol>
<li>严禁跨库join</li>
<li>使用子表，业务层聚合</li>
</ol>
<h2 id="设定网站用户数量在千万级，但是活跃用户数量只有1-，如何通过优化数据库提高活跃用户访问速度"><a href="#设定网站用户数量在千万级，但是活跃用户数量只有1-，如何通过优化数据库提高活跃用户访问速度" class="headerlink" title="设定网站用户数量在千万级，但是活跃用户数量只有1%，如何通过优化数据库提高活跃用户访问速度"></a>设定网站用户数量在千万级，但是活跃用户数量只有1%，如何通过优化数据库提高活跃用户访问速度</h2><p>（1）可以使用MySQL的分区，把活跃用户分在一个区，不活跃用户分在另外一个区，本身活跃用户区数据量比较少，因此可以提高活跃用户访问速度。<br>（2）还可以水平分表，把活跃用户分在一张表，不活跃用户分在另一张表，可以提高活跃用户访问速度。</p>
<h2 id="分库分表的拆分方式有？他们分别主要解决什么问题？"><a href="#分库分表的拆分方式有？他们分别主要解决什么问题？" class="headerlink" title="分库分表的拆分方式有？他们分别主要解决什么问题？"></a>分库分表的拆分方式有？他们分别主要解决什么问题？</h2><p>垂直切分，主要解决表与表之间资源争用问题</p>
<p>水平切分，主要解决单表过大造成的性能问题，单表过大造成的单服务器空间问题。</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="MySQL-中有哪几种锁？"><a href="#MySQL-中有哪几种锁？" class="headerlink" title="MySQL 中有哪几种锁？"></a>MySQL 中有哪几种锁？</h2><p>1、表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。<br>2、行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<br>3、页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发<br>度一般</p>
<h2 id="锁的优化策略"><a href="#锁的优化策略" class="headerlink" title="锁的优化策略"></a>锁的优化策略</h2><p>1、读写分离<br>2、分段加锁<br>3、减少锁持有的时间<br>4、多个线程尽量以相同的顺序去获取资源不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放<br>次数过多，反而效率不如一次加一把大锁。</p>
<h1 id="优化数据库"><a href="#优化数据库" class="headerlink" title="优化数据库"></a>优化数据库</h1><p>最好是按照以下顺序优化：<br>1、SQL 语句及索引的优化<br>2、数据库表结构的优化<br>3、系统配置的优化<br>4、硬件的优化</p>
<hr>
<p>1、选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置 NOTNULL，例如’省份’、’性<br>别’最好适用 ENUM<br>2、使用连接(JOIN)来代替子查询<br>3、适用联合(UNION)来代替手动创建的临时表<br>4、事务处理<br>5、锁定表、优化事务处理<br>6、适用外键，优化锁定表<br>7、建立索引<br>8、优化查询语句</p>
<h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><p>1、查询语句中不要使用select *<br>2、尽量减少子查询，使用关联查询（left join,right join,inner join）替代<br>3、减少使用IN或者NOT IN ,使用exists，not exists或者关联查询语句替代<br>4、or 的查询尽量用 union或者union all 代替(在确认没有重复数据或者不用剔除重复数据时，union<br>all会更好)<br>5、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。<br>6、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫<br>描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null<br>值，然后这样查询： select id from t where num=0</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 数据库</a>
          
            <a href="/tags/MySQL/" rel="tag"># MySQL</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/04/16/%E4%B8%AD%E9%97%B4%E4%BB%B6-Elasticsearch%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%AD%A6%E4%B9%A0/" rel="next" title="中间件-文件系统(FastDFS)">
                <i class="fa fa-chevron-left"></i> 中间件-文件系统(FastDFS)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/04/17/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85-rabbitmq%E5%AE%89%E8%A3%85/" rel="prev" title="软件安装-rabbitmq安装">
                软件安装-rabbitmq安装 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <!--<a href="/archives/%7C%7Carchive">-->
                <a href="/archives/">
              
                  <span class="site-state-item-count">108</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">70</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">70</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuanyayuan" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:liyuan0707@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#SQL%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.</span> <span class="nav-text">SQL语句</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E5%9C%A8MySQL%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="nav-number">1.1.</span> <span class="nav-text">一条SQL语句在MySQL中如何执行的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SELECT-%E5%92%8C-SELECT-%E5%85%A8%E9%83%A8%E5%AD%97%E6%AE%B5%E4%B8%A4%E7%A7%8D%E5%86%99%E6%B3%95%E6%9C%89%E4%BD%95%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.2.</span> <span class="nav-text">SELECT * 和 SELECT 全部字段两种写法有何优缺点?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LiKE%E5%A3%B0%E6%98%8E%E4%B8%AD%E7%9A%84%EF%BC%85%E5%92%8C-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="nav-number">1.3.</span> <span class="nav-text">LiKE声明中的％和_是什么意思？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HAVNG-%E5%AD%90%E5%8F%A5-%E5%92%8C-WHERE-%E7%9A%84%E5%BC%82%E5%90%8C%E7%82%B9"><span class="nav-number">1.4.</span> <span class="nav-text">HAVNG 子句 和 WHERE 的异同点?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA-SQL-%E6%89%A7%E8%A1%8C%E7%9A%84%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.5.</span> <span class="nav-text">一个 SQL 执行的很慢的原因</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5"><span class="nav-number">2.</span> <span class="nav-text">字段</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E8%87%AA%E5%A2%9E%E5%88%97%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE"><span class="nav-number">2.1.</span> <span class="nav-text">为什么用自增列作为主键</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E4%B8%AD-TIMESTAMP%E5%92%8CDATETIME%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.2.</span> <span class="nav-text">MySQL 中 TIMESTAMP和DATETIME的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%A2%9EID%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.</span> <span class="nav-text">自增ID问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%95%E6%93%8E%EF%BC%88MySQL-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">引擎（MySQL 支持哪些存储引擎）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB%E5%92%8CMyISAM%E5%8C%BA%E5%88%AB"><span class="nav-number">3.1.</span> <span class="nav-text">InnoDB和MyISAM区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bmysql%E7%9A%84MVCC%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="nav-number">3.2.</span> <span class="nav-text">介绍一下mysql的MVCC机制：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%8C%83%E5%BC%8F"><span class="nav-number">4.</span> <span class="nav-text">范式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">5.</span> <span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95"><span class="nav-number">5.1.</span> <span class="nav-text">什么是索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%BF%E7%94%A8B-Tree"><span class="nav-number">5.2.</span> <span class="nav-text">MySQL索引数据结构使用B+Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%80%82%E7%94%A8-B-%E6%A0%91%EF%BC%9F"><span class="nav-number">5.3.</span> <span class="nav-text">为什么不适用 B 树？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%9F"><span class="nav-number">5.4.</span> <span class="nav-text">为什么不用哈希表？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="nav-number">5.5.</span> <span class="nav-text">为什么不用红黑树？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash%E7%B4%A2%E5%BC%95%E5%92%8CB-%E6%A0%91%E6%89%80%E6%9C%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E6%88%96%E8%80%85%E8%AF%B4%E4%BC%98%E5%8A%A3%E5%91%A2"><span class="nav-number">5.6.</span> <span class="nav-text">Hash索引和B+树所有有什么区别或者说优劣呢?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">5.6.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C"><span class="nav-number">5.6.2.</span> <span class="nav-text">不同</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E6%94%AF%E6%8C%81%E7%9A%84%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">5.7.</span> <span class="nav-text">MySQL 支持的索引类型是哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E5%88%99%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">5.8.</span> <span class="nav-text">建立索引的原则有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="nav-number">5.9.</span> <span class="nav-text">最左匹配原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%BF%99%E4%B9%88%E5%A4%9A%E4%BC%98%E7%82%B9%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AF%B9%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%88%97%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95%E5%91%A2%EF%BC%9F%EF%BC%88%E7%B4%A2%E5%BC%95%E5%BB%BA%E7%AB%8B%E4%B8%8D%E6%98%AF%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD%EF%BC%89"><span class="nav-number">5.10.</span> <span class="nav-text">索引这么多优点，为什么不对表中的每一个列创建一个索引呢？（索引建立不是越多越好）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="nav-number">5.11.</span> <span class="nav-text">索引什么时候会失效？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%E4%B8%80%E5%AE%9A%E8%83%BD%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%80%A7%E8%83%BD%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-number">5.12.</span> <span class="nav-text">使用索引查询一定能提高查询的性能吗？为什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B4%A2%E5%BC%95%E8%83%BD%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6"><span class="nav-number">5.13.</span> <span class="nav-text">为什么索引能提高查询速度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">6.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="nav-number">6.1.</span> <span class="nav-text">事务有哪些特性？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E4%B8%ADInnoDB%E5%BC%95%E6%93%8E%E7%9A%84%E8%A1%8C%E9%94%81%E6%98%AF%E9%80%9A%E8%BF%87%E5%8A%A0%E5%9C%A8%E4%BB%80%E4%B9%88%E4%B8%8A%E5%AE%8C%E6%88%90-%E6%88%96%E7%A7%B0%E5%AE%9E%E7%8E%B0-%E7%9A%84%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%99%E6%A0%B7%E5%AD%90%E7%9A%84%EF%BC%9F"><span class="nav-number">6.2.</span> <span class="nav-text">MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="nav-number">6.3.</span> <span class="nav-text">并发事务带来哪些问题?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%A6%E8%BF%B0%E4%B8%80%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%BA%A7%E5%88%AB"><span class="nav-number">6.4.</span> <span class="nav-text">详述一下数据库事务隔离的四个级别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">7.</span> <span class="nav-text">主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="nav-number">7.1.</span> <span class="nav-text">复制过程：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E5%89%8D%E5%87%86%E5%A4%87%E5%81%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B0%B4%E5%B9%B3%E5%88%87%E5%88%86%EF%BC%8C%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">7.2.</span> <span class="nav-text">目前准备做数据库水平切分，需要注意什么关键问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E7%A2%B0%E5%88%B0%E8%A6%81%E5%AF%B9%E4%B8%80%E4%B8%AA%E8%A1%A8%E6%88%96%E5%A4%9A%E4%B8%AA%E8%A1%A8%E5%85%B3%E8%81%94%E5%B9%B6%E4%B8%94%E6%8C%89%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E4%B8%BA%E6%9D%A1%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%A3%80%E7%B4%A2%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%80%8E%E4%B9%88%E5%8A%9E%E5%91%A2"><span class="nav-number">7.3.</span> <span class="nav-text">如果分库分表的情况下碰到要对一个表或多个表关联并且按多个字段为条件进行检索的情况下怎么办呢</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E5%AE%9A%E7%BD%91%E7%AB%99%E7%94%A8%E6%88%B7%E6%95%B0%E9%87%8F%E5%9C%A8%E5%8D%83%E4%B8%87%E7%BA%A7%EF%BC%8C%E4%BD%86%E6%98%AF%E6%B4%BB%E8%B7%83%E7%94%A8%E6%88%B7%E6%95%B0%E9%87%8F%E5%8F%AA%E6%9C%891-%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E9%AB%98%E6%B4%BB%E8%B7%83%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6"><span class="nav-number">7.4.</span> <span class="nav-text">设定网站用户数量在千万级，但是活跃用户数量只有1%，如何通过优化数据库提高活跃用户访问速度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E6%8B%86%E5%88%86%E6%96%B9%E5%BC%8F%E6%9C%89%EF%BC%9F%E4%BB%96%E4%BB%AC%E5%88%86%E5%88%AB%E4%B8%BB%E8%A6%81%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">7.5.</span> <span class="nav-text">分库分表的拆分方式有？他们分别主要解决什么问题？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">8.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E4%B8%AD%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%94%81%EF%BC%9F"><span class="nav-number">8.1.</span> <span class="nav-text">MySQL 中有哪几种锁？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="nav-number">8.2.</span> <span class="nav-text">锁的优化策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">9.</span> <span class="nav-text">优化数据库</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SQL%E4%BC%98%E5%8C%96"><span class="nav-number">10.</span> <span class="nav-text">SQL优化</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LiYuan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
