<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="工作中技术总结">
<meta property="og:type" content="website">
<meta property="og:title" content="Hikari的Java之路">
<meta property="og:url" content="https://yuanyayuan.github.io/page/8/index.html">
<meta property="og:site_name" content="Hikari的Java之路">
<meta property="og:description" content="工作中技术总结">
<meta property="og:locale">
<meta property="article:author" content="LiYuan">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yuanyayuan.github.io/page/8/"/>





  <title>Hikari的Java之路</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hikari的Java之路</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Hello,world</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/13/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/13/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url">Java-面向对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-13T01:14:36+08:00">
                2021-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础 - Java知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h1><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。<strong>即外壳不变，核心重写！</strong></p>
<ul>
<li><strong>参数列表</strong>与<strong>被重写方法的参数列表</strong>必须完全相同。</li>
<li><strong>返回类型</strong>与<strong>被重写方法的返回类型</strong>可以<strong>不相同</strong>，但是必须是<strong>父类返回值的派生类</strong>（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</li>
<li><strong>访问权限</strong>不能比<strong>父类中被重写的方法的访问权限更低</strong>。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</li>
<li><strong>父类的成员方法</strong>只能被它的<strong>子类重写</strong>。</li>
<li>声明为<strong>final</strong>的方法不能被<strong>重写</strong>。</li>
<li>声明为<strong>static</strong>的方法不能被<strong>重写</strong>，但是能够被再次声明。</li>
<li>子类和父类在<strong>同一个包中</strong>，那么<strong>子类可以重写父类所有方法</strong>，除了声明为 private 和 final 的方法。</li>
<li>子类和父类<strong>不在同一个包中</strong>，那么<strong>子类只能够重写父类的声明为 public 和 protected 的非 final 方法</strong>。</li>
<li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常。</li>
<li><strong>构造方法不能被重写</strong>。</li>
<li>如果<strong>不能继承一个方法，则不能重写这个方法</strong>。</li>
</ul>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p>
<p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p>
<p>最常用的地方就是构造器的重载。</p>
<ul>
<li>被重载的方法**必须改变参数列表(参数个数或类型不一样)**；</li>
<li>被重载的方法<strong>可以改变返回类型</strong>；</li>
<li>被重载的方法<strong>可以改变访问修饰符</strong>；</li>
<li>被重载的方法<strong>可以声明新的或更广的检查异常</strong>；</li>
<li><strong>方法</strong>能够在<strong>同一个类中或者在一个子类中被重载</strong>。</li>
<li><strong>无法以返回值类型作为重载函数的区分标准</strong>。</li>
</ul>
<h2 id="为什么不能根据返回类型来区分重载"><a href="#为什么不能根据返回类型来区分重载" class="headerlink" title="为什么不能根据返回类型来区分重载"></a>为什么不能根据返回类型来区分重载</h2><p>函数的返回值只是作为函数运行之后的一个“状态” ，并不能作为某个方法的“标识” 。</p>
<h2 id="构造器（constructor）是否可被重写（override）"><a href="#构造器（constructor）是否可被重写（override）" class="headerlink" title="构造器（constructor）是否可被重写（override）"></a>构造器（constructor）是否可被重写（override）</h2><p>构造器不能被继承，因此不能被重写，但可以被重载</p>
<h2 id="父类的静态方法能否被子类重写"><a href="#父类的静态方法能否被子类重写" class="headerlink" title="父类的静态方法能否被子类重写"></a>父类的静态方法能否被子类重写</h2><p>不能。重写只适用于实例方法，不能用于静态方法，而子类当中含有和父类相同签名的静态方法，我们一般称之为隐藏，调用的方法为定义的类所有的静态方法。</p>
<h1 id="创建类的方法"><a href="#创建类的方法" class="headerlink" title="创建类的方法"></a>创建类的方法</h1><ol>
<li>使用new关键字；</li>
<li>反射，<ul>
<li>使用<code>java.lang.Class</code>类的<code>newInstance</code>方法。</li>
<li>使用 java.lang.reflect.Constructor类的newInstance方法。</li>
</ul>
</li>
<li>使用clone方法。<ul>
<li>实现 Cloneable 接口并重写 Object 类中的 clone()方法</li>
<li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆</li>
</ul>
</li>
<li>使用反序列化。</li>
</ol>
<blockquote>
<p>为了序列化/反序列化一个对象，需要该类实现空接口Serializable。序列化是深拷贝。</p>
</blockquote>
<p><strong>点评：</strong><br>前面2种创建方式比较常见，其中第反射经常见于框架代码，用于bean注入等。clone本质是复制，是不需要调用构造器的（见下表），反序列化在rpc调用中使用比较多，clone使用比较少一些。</p>
<table>
<thead>
<tr>
<th>创建对象方式</th>
<th>是否调用了构造器</th>
</tr>
</thead>
<tbody><tr>
<td>new关键字</td>
<td>是</td>
</tr>
<tr>
<td>Class.newInstance</td>
<td>是</td>
</tr>
<tr>
<td>Constructor.newInstance</td>
<td>是</td>
</tr>
<tr>
<td>Clone</td>
<td>否</td>
</tr>
<tr>
<td>反序列化</td>
<td>否</td>
</tr>
</tbody></table>
<h2 id="创建对象时的步骤"><a href="#创建对象时的步骤" class="headerlink" title="创建对象时的步骤"></a>创建对象时的步骤</h2><p>先声明对象，为对象分配内存空间，对象初始化，然后才能使用对象</p>
<h2 id="java-lang-Class类的newInstance方法和-java-lang-reflect-Constructor类的newInstance方法有什么区别？"><a href="#java-lang-Class类的newInstance方法和-java-lang-reflect-Constructor类的newInstance方法有什么区别？" class="headerlink" title="java.lang.Class类的newInstance方法和 java.lang.reflect.Constructor类的newInstance方法有什么区别？"></a>java.lang.Class类的newInstance方法和 java.lang.reflect.Constructor类的newInstance方法有什么区别？</h2><ul>
<li>Class类的newInstance只能触发无参数的构造方法创建对象，而构造器类的newInstance能触发有参数或者任意参数的构造方法来创建对象。</li>
<li>Class类的newInstance需要其构造方法是public的或者对调用方法可见的，而构造器类的newInstance可以在特定环境下调用私有构造方法来创建对象。</li>
<li>Class类的newInstance抛出类构造函数的异常，而构造器类的newInstance包装了一个InvocationTargetException异常</li>
</ul>
<h1 id="java修饰符"><a href="#java修饰符" class="headerlink" title="java修饰符"></a>java修饰符</h1><h2 id="public-private-protected-default"><a href="#public-private-protected-default" class="headerlink" title="public,private,protected,default"></a>public,private,protected,default</h2><p>访问修饰符public,private,protected,以及不写（默认）时的区别？ 答：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>当前类</th>
<th>同包</th>
<th>子类</th>
<th>其他包</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<h1 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h1><h2 id="抽象类（abstract-class）和接口（interface）有什么异同？"><a href="#抽象类（abstract-class）和接口（interface）有什么异同？" class="headerlink" title="抽象类（abstract class）和接口（interface）有什么异同？"></a>抽象类（abstract class）和接口（interface）有什么异同？</h2><table>
<thead>
<tr>
<th align="left">比较</th>
<th align="left">抽象类</th>
<th align="left">接口</th>
</tr>
</thead>
<tbody><tr>
<td align="left">默认方法</td>
<td align="left">抽象类可以有默认的方法实现</td>
<td align="left">java 8之前,接口中不存在方法的实现.</td>
</tr>
<tr>
<td align="left">实现方式</td>
<td align="left">子类使用extends关键字来继承抽象类.如果子类不是抽象类,子类需要提供抽象类中所声明方法的实现.</td>
<td align="left">子类使用implements来实现接口,需要提供接口中所有声明的实现.</td>
</tr>
<tr>
<td align="left">构造器</td>
<td align="left">抽象类中可以有构造器,</td>
<td align="left">接口中不能</td>
</tr>
<tr>
<td align="left">和正常类区别</td>
<td align="left">抽象类不能被实例化</td>
<td align="left">接口则是完全不同的类型</td>
</tr>
<tr>
<td align="left">访问修饰符</td>
<td align="left">抽象方法可以有public,protected和default等修饰</td>
<td align="left">接口默认是public,不能使用其他修饰符</td>
</tr>
<tr>
<td align="left">多继承</td>
<td align="left">一个子类只能存在一个父类</td>
<td align="left">一个子类可以存在多个接口</td>
</tr>
<tr>
<td align="left">添加新方法</td>
<td align="left">抽象类中添加新方法,可以提供默认的实现,因此可以不修改子类现有的代码</td>
<td align="left">如果往接口中添加新方法,则子类中需要实现该方法.</td>
</tr>
</tbody></table>
<h2 id="抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰？为什么？"><a href="#抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰？为什么？" class="headerlink" title="抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？为什么？"></a>抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？为什么？</h2><p>都不能。 抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的； 本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的； synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的；</p>
<h2 id="普通类和抽象类有哪些区别"><a href="#普通类和抽象类有哪些区别" class="headerlink" title="普通类和抽象类有哪些区别"></a>普通类和抽象类有哪些区别</h2><ol>
<li>抽象类不能被实例</li>
<li>抽象类不能有构造函数，抽象方法也不能被声明为静态</li>
<li>抽象类可以有抽象方法</li>
<li>抽象类的抽象方法必须被非抽象子类继承</li>
</ol>
<h2 id="抽象类能使用-final-修饰吗？"><a href="#抽象类能使用-final-修饰吗？" class="headerlink" title="抽象类能使用 final 修饰吗？"></a>抽象类能使用 final 修饰吗？</h2><p>不能，抽象类中的抽象方法是未来继承之后重写方法，而用final修饰的类，无法被继承。</p>
<h2 id="接口是否可继承（extends）接口-抽象类是否可实现（implements）接口-抽象类是否可继承具体类（concrete-class）"><a href="#接口是否可继承（extends）接口-抽象类是否可实现（implements）接口-抽象类是否可继承具体类（concrete-class）" class="headerlink" title="接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口?抽象类是否可继承具体类（concrete class）"></a>接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口?抽象类是否可继承具体类（concrete class）</h2><p>接口可以继承接口。抽象类可以实现(implements)接口，抽象类可继承具 体类，但前提是具体类必须有明确的构造函数。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/13/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/13/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url">Java-基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-13T01:14:24+08:00">
                2021-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础 - Java知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><table>
<thead>
<tr>
<th>类型</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>访问控制</td>
<td>private</td>
<td>protected</td>
<td>public</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>类，方法和变量修饰符</td>
<td>abstract</td>
<td>class</td>
<td>extends</td>
<td>final</td>
<td>implements</td>
<td>interface</td>
<td>native</td>
</tr>
<tr>
<td></td>
<td>new</td>
<td>static</td>
<td>strictfp</td>
<td>synchronized</td>
<td>transient</td>
<td>volatile</td>
<td></td>
</tr>
<tr>
<td>程序控制</td>
<td>break</td>
<td>continue</td>
<td>return</td>
<td>do</td>
<td>while</td>
<td>if</td>
<td>else</td>
</tr>
<tr>
<td></td>
<td>for</td>
<td>instanceof</td>
<td>switch</td>
<td>case</td>
<td>default</td>
<td></td>
<td></td>
</tr>
<tr>
<td>错误处理</td>
<td>try</td>
<td>catch</td>
<td>throw</td>
<td>throws</td>
<td>finally</td>
<td></td>
<td></td>
</tr>
<tr>
<td>包相关</td>
<td>import</td>
<td>package</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>基本类型</td>
<td>boolean</td>
<td>byte</td>
<td>char</td>
<td>double</td>
<td>float</td>
<td>int</td>
<td>long</td>
</tr>
<tr>
<td></td>
<td>short</td>
<td>null</td>
<td>true</td>
<td>false</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>变量引用</td>
<td>super</td>
<td>this</td>
<td>void</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>保留字</td>
<td>goto</td>
<td>const</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="final-finally-finalize"><a href="#final-finally-finalize" class="headerlink" title="final, finally, finalize"></a>final, finally, finalize</h2><ol>
<li><p><strong>final</strong></p>
<ul>
<li><p>被final修饰的类不可以被继承</p>
</li>
<li><p>被final修饰的方法不可以被重写，JVM会尝试将其内联,以提高运行效率</p>
</li>
<li><p>被final修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变，修饰的常量在编译阶段会存入常量池中</p>
<ul>
<li>使用final关键字修饰一个变量时，是引用不可变,引用指向的内容可变<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> StringBuffer a=<span class="keyword">new</span> StringBuffer(<span class="string">&quot;immutable&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>  执行如下语句将报告编译期错误:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="keyword">new</span> StringBuffer(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>但是，执行如下语句则可以通过编译:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.append(<span class="string">&quot; broken!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">final</span> StringBuffer param)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">param.append(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>finally</strong></p>
<p>在异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。</p>
</li>
<li><p><strong>finalize</strong></p>
<p><strong>方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</strong>这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。注意：finalize不一定被jvm调用，只有当垃圾回收器要清除垃圾时才被调用。</p>
</li>
</ol>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile 的意思是可见的，常用来修饰某个共享变量，意思是当共享变量的值被修改后，会及时通知到其它线程上，其它线程就能知道当前共享变量的值已经被修改了。</p>
<h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h2><p>transient 关键字我们常用来修饰类变量，意思是当前变量是无需进行序列化的。在序列化时，就会忽略该变量，这些在序列化工具底层，就已经对 transient 进行了支持。</p>
<h2 id="default"><a href="#default" class="headerlink" title="default"></a>default</h2><p>default 关键字一般会用在接口的方法上，意思是对于该接口，子类是无需强制实现的，但自己必须有默认实现，我们举个例子如下：</p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/default.png" alt="图片描述"></p>
<h2 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h2><p><code>goto</code> 是Java中的保留字，在目前版本的Java中没有使用。</p>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p><strong>关键字switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上</strong></p>
<p>switch支持的类型<strong>byte、short、char、int、enum、String</strong></p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>static 只能修饰类变量、方法和方法块。</p>
<ul>
<li><p>当 static 修饰类变量时</p>
<p>如果该变量是 public 的话，表示该变量任何类都可以直接访问，而且无需初始化类，直接使用 <strong>类名.static 变量</strong> 这种形式访问即可。</p>
<blockquote>
<p>这时候我们非常需要注意的一点就是线程安全的问题了，因为当多个线程同时对共享变量进行读写时，很有可能会出现并发问题，如我们定义了：<code>public static List list = new ArrayList();</code>这样的共享变量。这个 list 如果同时被多个线程访问的话，就有线程安全的问题，这时候一般有两个解决办法：</p>
<ol>
<li>把线程不安全的 ArrayList 换成 线程安全的 CopyOnWriteArrayList；</li>
<li>每次访问时，手动加锁。</li>
</ol>
</blockquote>
</li>
<li><p>当 static 修饰方法时</p>
<p>代表该方法和当前类是无关的，任意类都可以直接访问（如果权限是 public 的话）。</p>
<p>被 static 修饰的方法，在类初始化的时候并不会初始化，只有当自己被调用时，才会被执行。</p>
<blockquote>
<ol>
<li><strong>该方法内部只能调用同样被 static 修饰的方法，不能调用普通方法</strong>，</li>
<li><strong>static 方法内部的变量在执行时是没有线程安全问题的</strong>。方法执行时，数据运行在栈里面，栈的数据每个线程都是隔离开的</li>
</ol>
</blockquote>
</li>
<li><p>当 static 修饰方法块时</p>
<p>叫做静态块，静态块常常用于在类启动之前，初始化一些值，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">// 进行一些初始化的工作</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>静态块只能调用同样被 static 修饰的变量，并且 static 的变量需要写在静态块的前面，不然编译也会报错。</p>
</blockquote>
<p><strong>初始化时机</strong></p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/static.png"></p>
<p>打印出来的结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">父类静态变量初始化</span><br><span class="line"></span><br><span class="line">父类静态块初始化</span><br><span class="line"></span><br><span class="line">子类静态变量初始化</span><br><span class="line"></span><br><span class="line">子类静态块初始化</span><br><span class="line"></span><br><span class="line">main 方法执行</span><br><span class="line"></span><br><span class="line">父类构造器初始化</span><br><span class="line"></span><br><span class="line">子类构造器初始化</span><br></pre></td></tr></table></figure>

<p>从结果中，我们可以看出两点：</p>
<pre><code>1. 父类的静态变量和静态块比子类优先初始化；
2. 静态变量和静态块比类构造器优先初始化。
</code></pre>
</li>
<li><p>静态导包(用来导入类中的静态资源，1.5之后的新特性)</p>
<p>格式为：<code>import static</code> 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。</p>
</li>
</ul>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this关键字用于引用类的当前实例。 例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line">    Employees[] employees;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">manageEmployees</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalEmp = <span class="keyword">this</span>.employees.length;</span><br><span class="line">        System.out.println(<span class="string">&quot;Total employees: &quot;</span> + totalEmp);</span><br><span class="line">        <span class="keyword">this</span>.report();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，this关键字用于两个地方：</p>
<ul>
<li>this.employees.length：访问类Manager的当前实例的变量。</li>
<li>this.report（）：调用类Manager的当前实例的方法。</li>
</ul>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>super关键字用于从子类访问父类的变量和方法。 例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">showNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;number = &quot;</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.number = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">super</span>.showNumber();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，Sub 类访问父类成员变量 number 并调用其其父类 Super 的 <code>showNumber（）</code>方法。</p>
<p><strong>使用 this 和 super 要注意的问题：</strong></p>
<ul>
<li><p>在构造器中使用 <code>super()</code> 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。</p>
</li>
<li><p>this、super不能用在static方法中。</p>
<p><strong>简单解释一下：</strong></p>
<p>被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， <strong>this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西</strong>。</p>
</li>
</ul>
<h2 id="continue、break、和-return"><a href="#continue、break、和-return" class="headerlink" title="continue、break、和 return"></a>continue、break、和 return</h2><h3 id="区别是什么"><a href="#区别是什么" class="headerlink" title="区别是什么"></a>区别是什么</h3><p>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：</p>
<ol>
<li><p>continue ：指跳出当前的这一次循环，继续下一次循环。</p>
</li>
<li><p>break ：指跳出整个循环体，继续执行循环下面的语句。</p>
</li>
<li><p>return 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</p>
<ol>
<li><code>return;</code> ：直接使用 return 结束方法执行，用于没有返回值函数的方法</li>
<li><code>return value;</code> ：return 一个特定值，用于有返回值函数的方法</li>
</ol>
</li>
</ol>
<h3 id="Java中跳出多重循环有三种方式"><a href="#Java中跳出多重循环有三种方式" class="headerlink" title="Java中跳出多重循环有三种方式"></a>Java中跳出多重循环有三种方式</h3><p>1、break+标签。在最外层循环前加一个标签如label，然后在最里层的循环使用用break label。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        label:    <span class="comment">//标记</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j);</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">5</span>) &#123;  <span class="comment">//满中一定条件跳到某个标记</span></span><br><span class="line">                    <span class="keyword">break</span> label;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、通过捕获异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j);</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">5</span>) &#123;<span class="comment">// 满足一定条件抛异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;test exception for j = 5&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">//循环外层捕获异常</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、通过标置变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//初始化标置变量</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j);</span><br><span class="line">               <span class="keyword">if</span> (j == <span class="number">5</span>) &#123;   <span class="comment">//满足一定条件进行设置标置变量</span></span><br><span class="line">                   flag = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (flag) &#123; <span class="comment">//内层循环判断标置变量</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (flag) &#123;<span class="comment">//外层循环判断标置变量</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h2><p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<h3 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><p><strong>Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">类型擦除例子</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">12</span>);</span><br><span class="line"><span class="comment">//这里直接添加会报错</span></span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">Class&lt;? extends List&gt; clazz = list.getClass();</span><br><span class="line">Method add = clazz.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line"><span class="comment">//但是通过反射添加，是可以的</span></span><br><span class="line">add.invoke(list, <span class="string">&quot;kl&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(list)</span><br></pre></td></tr></table></figure>

<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerResponse</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;状态码；200:成功&quot;,example = &quot;200&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> code;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;状态说明&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;返回数据&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ServerResponse</span><span class="params">(<span class="keyword">long</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ServerResponse&lt;T&gt; <span class="title">success</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerResponse&lt;T&gt;(ResultCode.SUCCESS.getCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServerResponse <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ServerResponse.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现泛型接口，不指定类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现泛型接口，指定类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">( E[] inputArray )</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (E element : inputArray )&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s &quot;</span>,element);</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br></pre></td></tr></table></figure>

<h2 id="常用的通配符为：-T，E，K，V，"><a href="#常用的通配符为：-T，E，K，V，" class="headerlink" title="常用的通配符为： T，E，K，V，?"></a>常用的通配符为： T，E，K，V，?</h2><ul>
<li>？ 表示不确定的 java 类型</li>
<li>T (type) 表示具体的一个 java 类型</li>
<li>K V (key value) 分别代表 java 键值中的 Key Value</li>
<li>E (element) 代表 Element</li>
</ul>
<h2 id="Java-泛型类在什么时候确定类型"><a href="#Java-泛型类在什么时候确定类型" class="headerlink" title="Java 泛型类在什么时候确定类型"></a>Java 泛型类在什么时候确定类型</h2><p>在编译期间确定变量类型。类型擦除。</p>
<h1 id="equals-与"><a href="#equals-与" class="headerlink" title="equals 与=="></a><code>equals</code> 与<code>==</code></h1><ul>
<li>值类型（<code>int,char,long,boolean</code>等）都是用<code>==</code>判断相等性。<code>== </code>比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的<strong>地址</strong>是否相同</li>
<li><code>equals</code>用来比较的是两个<strong>对象的内容</strong>是否相等,equals是Object的成员函数。</li>
</ul>
<p><strong>例如：两个引用所指向的String都是”abc”，但可能出现他们实际对应的对象并不是同一个，因此用==判断他们可能不相等，但用equals判断一定是相等的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>String 中的 equals 方法是被重写过的，因为 Object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</li>
<li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li>
</ul>
<h2 id="euqals-的正确使用"><a href="#euqals-的正确使用" class="headerlink" title="euqals()的正确使用"></a>euqals()的正确使用</h2><p>Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常</span></span><br><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (str.equals(<span class="string">&quot;SnailClimb&quot;</span>)) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的程序会抛出空指针异常，但是我们把第二行的条件判断语句改为下面这样的话，就不会抛出空指针异常，else 语句块得到执行。：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;SnailClimb&quot;</span>.equals(str);<span class="comment">// false </span></span><br></pre></td></tr></table></figure>

<p>不过更推荐使用 <code>java.util.Objects#equals</code>(JDK7 引入的工具类)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Objects.equals(<span class="keyword">null</span>,<span class="string">&quot;SnailClimb&quot;</span>);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><code>java.util.Objects#equals</code>的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。</span></span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="hashCode与equals"><a href="#hashCode与equals" class="headerlink" title="hashCode与equals"></a><code>hashCode</code>与<code>equals</code></h1><h2 id="hashCode（）介绍"><a href="#hashCode（）介绍" class="headerlink" title="hashCode（）介绍"></a>hashCode（）介绍</h2><p>hashCode() 的作用是获取哈希码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p>
<h2 id="为什么要有hashCode"><a href="#为什么要有hashCode" class="headerlink" title="为什么要有hashCode"></a>为什么要有hashCode</h2><p><strong>“HashSet如何检查重复”为例子来说明</strong></p>
<p>当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较</p>
<p>如果没有相符的 hashcode，<code>HashSet</code> 会假设对象没有重复出现，但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code> 方法来检查 hashcode 相等的对象是否真的相同</p>
<p>如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。</p>
<h2 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals 时必须重写 hashCode 方法？"></a>为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？</h2><p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。</p>
<p>但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。<strong>因此，equals 方法被覆盖过，则 <code>hashCode</code> 方法也必须被覆盖。</strong></p>
<h2 id="为什么两个对象有相同的-hashcode-值，它们也不一定是相等的"><a href="#为什么两个对象有相同的-hashcode-值，它们也不一定是相等的" class="headerlink" title="为什么两个对象有相同的 hashcode 值，它们也不一定是相等的"></a>为什么两个对象有相同的 hashcode 值，它们也不一定是相等的</h2><p>hash碰撞使得不同的对象得到相同的 <code>hashCode</code>。</p>
<h2 id="hashCode（）与equals（）的相关规定"><a href="#hashCode（）与equals（）的相关规定" class="headerlink" title="hashCode（）与equals（）的相关规定"></a>hashCode（）与equals（）的相关规定</h2><ol>
<li>如果两个对象相等，则hashcode一定也是相同的</li>
<li>两个对象相等,对两个对象分别调用equals方法都返回true</li>
<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>
<li><strong>因此，equals方法被覆盖过，则hashCode方法也必须被覆盖</strong></li>
<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ol>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="Java-中的几种基本数据类型是什么？对应的包装类型是什么"><a href="#Java-中的几种基本数据类型是什么？对应的包装类型是什么" class="headerlink" title="Java 中的几种基本数据类型是什么？对应的包装类型是什么"></a>Java 中的几种基本数据类型是什么？对应的包装类型是什么</h2><p>Java中有 8 种基本数据类型，分别为：</p>
<ol>
<li>6 种数字类型 ：byte、short、int、long、float、double</li>
<li>1 种字符类型：char</li>
<li>1 种布尔型：boolean。</li>
</ol>
<table>
<thead>
<tr>
<th>原始类型</th>
<th>boolean</th>
<th>char</th>
<th>byte</th>
<th>short</th>
<th>int</th>
<th>long</th>
<th>float</th>
<th>double</th>
</tr>
</thead>
<tbody><tr>
<td>包装类型</td>
<td>Boolean</td>
<td>Character</td>
<td>Byte</td>
<td>Short</td>
<td>Integer</td>
<td>Long</td>
<td>Float</td>
<td>Double</td>
</tr>
</tbody></table>
<p>注意：</p>
<ol>
<li>Java 里使用 long 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析：</li>
<li><code>char a = &#39;h&#39;</code>char :单引号，<code>String a = &quot;hello&quot;</code> :双引号</li>
<li>int 取值范围 ：-2^31——2^31-1</li>
</ol>
<h2 id="8-种基本类型的包装类和常量池"><a href="#8-种基本类型的包装类和常量池" class="headerlink" title="8 种基本类型的包装类和常量池"></a>8 种基本类型的包装类和常量池</h2><p><strong>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；</strong></p>
<p><strong>Byte,Short,Integer,Long包装类默认创建了数值[-128，127] 的相应类型的缓存数据，</strong></p>
<p><strong>Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False。</strong></p>
<p><strong>如果超出对应范围仍然会去创建新的对象。</strong></p>
<ol>
<li><strong>两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">33</span>;</span><br><span class="line">Integer i2 = <span class="number">33</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// 输出 true</span></span><br><span class="line">Integer i11 = <span class="number">333</span>;</span><br><span class="line">Integer i22 = <span class="number">333</span>;</span><br><span class="line">System.out.println(i11 == i22);<span class="comment">// 输出 false</span></span><br><span class="line">Double i3 = <span class="number">1.2</span>;</span><br><span class="line">Double i4 = <span class="number">1.2</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>

<p><strong>应用场景：</strong></p>
<ol>
<li>Integer i1=40；Java 在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。</li>
<li>Integer i1 = new Integer(40);这种情况下会创建新的对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">//输出 false</span></span><br></pre></td></tr></table></figure>

<p><strong>Integer相关练习例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">    Integer d = <span class="keyword">new</span> Integer(<span class="number">3</span>);     <span class="comment">// 通过new来创建的两个Integer对象</span></span><br><span class="line">    Integer b = <span class="number">3</span>;                  <span class="comment">// 将3自动装箱成Integer类型int c = 3;</span></span><br><span class="line">    <span class="keyword">int</span>     c = <span class="number">3</span>;                  <span class="comment">// 基本数据类型3</span></span><br><span class="line">    System.out.println(a == b);     <span class="comment">// false 两个引用没有引用同一对象</span></span><br><span class="line">    System.out.println(a == d);     <span class="comment">// false 两个通过new创建的Integer对象也不是同一个引用</span></span><br><span class="line">    System.out.println(c == b);     <span class="comment">// true a自动拆箱成int类型再和c比较</span></span><br><span class="line">    </span><br><span class="line">    Integer i1 = <span class="number">40</span>;</span><br><span class="line">    Integer i2 = <span class="number">40</span>;</span><br><span class="line">    Integer i3 = <span class="number">0</span>;</span><br><span class="line">    Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">    Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">    Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;i1=i2   &quot;</span> + (i1 == i2));<span class="comment">//true</span></span><br><span class="line">    System.out.println(<span class="string">&quot;i1=i2+i3   &quot;</span> + (i1 == i2 + i3));<span class="comment">//true</span></span><br><span class="line">    System.out.println(<span class="string">&quot;i1=i4   &quot;</span> + (i1 == i4)); <span class="comment">// false</span></span><br><span class="line">    System.out.println(<span class="string">&quot;i4=i5   &quot;</span> + (i4 == i5));<span class="comment">// false</span></span><br><span class="line">    System.out.println(<span class="string">&quot;i4=i5+i6   &quot;</span> + (i4 == i5 + i6)); <span class="comment">//true</span></span><br><span class="line">    System.out.println(<span class="string">&quot;40=i5+i6   &quot;</span> + (<span class="number">40</span> == i5 + i6)); <span class="comment">//true</span></span><br><span class="line">    <span class="comment">//语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行	 </span></span><br><span class="line">    <span class="comment">//数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值       </span></span><br><span class="line">    <span class="comment">//40，最终这条语句转为 40 == 40 进行数值比较。</span></span><br><span class="line">    Integer f1 = <span class="number">100</span>;</span><br><span class="line">    Integer f2 = <span class="number">100</span>;</span><br><span class="line">    Integer f3 = <span class="number">150</span>;</span><br><span class="line">    Integer f4 = <span class="number">150</span>;</span><br><span class="line">    System.out.println(f1 == f2);   <span class="comment">// true，当int在[-128,127]内时，结果会缓存起来</span></span><br><span class="line">	System.out.println(f3 == f4);   <span class="comment">// false，属于两个对象</span></span><br><span class="line">    <span class="comment">//IntegerCache是Integer的内部类。简单的说，如果整型字面量的值在-128到127之间，那么不会new新的       </span></span><br><span class="line">    <span class="comment">//Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1f2的结果是true，而f3f4的结果是false。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Long相关练习例子</strong></p>
<p>的缓存问题，Long 自己实现了一种缓存机制，缓存了从 -128 到 127 内的所有 Long 值，如果是这个范围内的 Long 值，就不会初始化，而是从缓存中拿</p>
<p><strong>为什么使用 Long 时，大家推荐多使用 valueOf 方法，少使用 parseLong 方法</strong></p>
<p>答：因为 Long 本身有缓存机制，缓存了 -128 到 127 范围内的 Long，valueOf 方法会从缓存中去拿值，如果命中缓存，会减少资源的开销，parseLong 方法就没有这个机制。</p>
<h2 id="精度问题"><a href="#精度问题" class="headerlink" title="精度问题"></a>精度问题</h2><ul>
<li><p>float是单精度类型,精度是8位有效数字，取值范围是10的-38次方到10的38次方，float占用4个字节的存储空间</p>
</li>
<li><p>double是双精度类型，精度是17位有效数字，取值范围是10的-308次方到10的308次方，double占用8个字节的存储空间</p>
</li>
<li><p>低精度向高精度靠齐</p>
</li>
</ul>
<h2 id="隐式自动类型转换"><a href="#隐式自动类型转换" class="headerlink" title="隐式自动类型转换"></a>隐式自动类型转换</h2><p>+=操作符会进行隐式自动类型转换，a+=b隐式的将加操作的结果类型强制转换为持有结果的类型，而a=a+b则不会自动进行类型转换。</p>
<p>举个例子，如： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> a = <span class="number">23</span>; </span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">22</span>; </span><br><span class="line">b = a + b;<span class="comment">//编译出错 </span></span><br><span class="line">b += a; <span class="comment">// 编译OK</span></span><br></pre></td></tr></table></figure>

<h1 id="Java-中只有值传递"><a href="#Java-中只有值传递" class="headerlink" title="Java 中只有值传递"></a>Java 中只有值传递</h1><p>Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。</p>
<h2 id="一个方法不能修改一个基本数据类型的参数"><a href="#一个方法不能修改一个基本数据类型的参数" class="headerlink" title="一个方法不能修改一个基本数据类型的参数"></a>一个方法不能修改一个基本数据类型的参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    swap(num1, num2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">    System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 20</span><br><span class="line">b &#x3D; 10</span><br><span class="line">num1 &#x3D; 10</span><br><span class="line">num2 &#x3D; 20</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="一个方法可以改变一个对象参数的状态。"><a href="#一个方法可以改变一个对象参数的状态。" class="headerlink" title="一个方法可以改变一个对象参数的状态。"></a>一个方法可以改变一个对象参数的状态。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">       System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">       change(arr);</span><br><span class="line">       System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">       array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="一个方法不能让对象参数引用一个新的对象。"><a href="#一个方法不能让对象参数引用一个新的对象。" class="headerlink" title="一个方法不能让对象参数引用一个新的对象。"></a>一个方法不能让对象参数引用一个新的对象。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">        Test.swap(s1, s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;s1:&quot;</span> + s1.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;s2:&quot;</span> + s2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//小张 x，小李 y</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Student x, Student y)</span> </span>&#123;</span><br><span class="line">        Student temp = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp;</span><br><span class="line">        System.out.println(<span class="string">&quot;x:&quot;</span> + x.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;y:&quot;</span> + y.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x:小李</span><br><span class="line">y:小张</span><br><span class="line">s1:小张</span><br><span class="line">s2:小李</span><br></pre></td></tr></table></figure>

<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><h2 id="（）"><a href="#（）" class="headerlink" title="（）"></a>（）</h2><p>优先级最高</p>
<h2 id="amp-和-amp-amp-；-和"><a href="#amp-和-amp-amp-；-和" class="headerlink" title="&amp;和&amp;&amp;；|和||"></a>&amp;和&amp;&amp;；|和||</h2><h3 id="amp-和-amp-amp"><a href="#amp-和-amp-amp" class="headerlink" title="&amp;和&amp;&amp;"></a>&amp;和&amp;&amp;</h3><p>共同点：两者都可做逻辑运算符。它们都表示运算符的两边都是true时，结果为true；</p>
<p>不同点: &amp;也是位运算符。&amp; 表示在运算时两边都会计算，然后再判断；&amp;&amp;表示先运算符号左边的东西，然后判断是否为true，是true就继续运算右边的然后判断并输出，是false就停下来直接输出不会再运行后面的东西。</p>
<h3 id="和"><a href="#和" class="headerlink" title="|和||"></a>|和||</h3><p>共同点：两者都可做逻辑运算符。它们都表示运算符的两边任意一边为true，结果为true，两边都不是true，结果就为false；</p>
<p>不同点：|也是位运算符。| 表示两边都会运算，然后再判断结果；|| 表示先运算符号左边的东西，然后判断是否为true，是true就停下来直接输出不会再运行后面的东西，是false就继续运算右边的然后判断并输出。</p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| 是把某两个数中, 只要其中一个的某一位为1，则结果的该位就为1；</span><br><span class="line">&amp; 相反 都为1 才为1</span><br></pre></td></tr></table></figure>

<h1 id="深拷贝-vs-浅拷贝"><a href="#深拷贝-vs-浅拷贝" class="headerlink" title="深拷贝 vs 浅拷贝"></a>深拷贝 vs 浅拷贝</h1><ol>
<li><strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li>
<li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/13/Java-String%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/13/Java-String%E6%BA%90%E7%A0%81/" itemprop="url">Java-String源码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-13T01:14:03+08:00">
                2021-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础 - Java知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="String源码解析"><a href="#String源码解析" class="headerlink" title="String源码解析"></a>String源码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;,<span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<ol>
<li>String 被 final 修饰，说明 String 类绝不可能被继承了，也就是说任何对 String 的操作方法，都不会被继承覆写；</li>
<li>String 中保存数据的是一个 char 的数组 value。 value 也是被 final 修饰的，也就是说 value  一旦被赋值，内存地址是绝对无法修改的，而且 value 的权限是  private 的，外部绝对访问不到，String 也没有开放出可以对  value 进行赋值的方法，所以说 value 一旦产生，内存地址就根本无法被修改。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str =<span class="string">&quot;hello world !!&quot;</span>;</span><br><span class="line">str.replace(<span class="string">&quot;l&quot;</span>,<span class="string">&quot;dd&quot;</span>); <span class="comment">//这种写法是替换不掉的，必须接受 replace 方法返回的参数才行，这样才行：str = str.replace(&quot;l&quot;,&quot;dd&quot;);</span></span><br></pre></td></tr></table></figure>

<h2 id="为什么大家都说-String-是不可变的"><a href="#为什么大家都说-String-是不可变的" class="headerlink" title="为什么大家都说 String 是不可变的"></a>为什么大家都说 String 是不可变的</h2><p>主要是因为 String 和保存数据的 char 数组，都被 final 关键字所修饰，所以是不可变的</p>
<p>当一个String变量被第二次赋值时，不是在原有内存地址上修改数据，而是在内存中重新开辟一块内存地址，并指向新地址。</p>
<h3 id="String类为什么要被设计为是final的？"><a href="#String类为什么要被设计为是final的？" class="headerlink" title="String类为什么要被设计为是final的？"></a>String类为什么要被设计为是final的？</h3><ol>
<li>不可变性支持线程安全。</li>
<li>不可变性支持字符串常量池，提升性能。</li>
<li>String字符串作为最常用数据类型之一，不可变防止了随意修改，保证了数据的安全性。</li>
</ol>
<h2 id="String比较"><a href="#String比较" class="headerlink" title="String比较"></a>String比较</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                String a = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">                String b = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">                String aa = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">                String bb = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">                <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String类，两个引用所指向的String都是”abc”，但可能出现他们实际对应的对象并不是同一个（和jvm实现方式有关），因此用==判断他们可能不相等，但用equals判断一定是相等的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">&quot;Programming&quot;</span>;</span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">&quot;Programming&quot;</span>);</span><br><span class="line">        String c = <span class="string">&quot;Program&quot;</span>+<span class="string">&quot;ming&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(a == b);<span class="comment">//false</span></span><br><span class="line">        System.out.println(a == c );<span class="comment">//true</span></span><br><span class="line">        System.out.println(a.equals(b));<span class="comment">//true</span></span><br><span class="line">        System.out.println(a.equals(c));<span class="comment">//true</span></span><br><span class="line">        <span class="comment">//a.intern() 会将字符串添加到常量池中</span></span><br><span class="line">        System.out.println(a.intern() == b.intern());<span class="comment">//true</span></span><br><span class="line">        </span><br><span class="line">        String s = <span class="keyword">new</span> String(“abc”);</span><br><span class="line">        String s1 = “abc”;</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(“abc”);</span><br><span class="line">        System.out.println(s == s1.intern());<span class="comment">//false</span></span><br><span class="line">        System.out.println(s == s2.intern());<span class="comment">//false</span></span><br><span class="line">        System.out.println(s1 == s2.intern()); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = “abc”;</span><br><span class="line">String s2 = “a”;</span><br><span class="line">String s3 = “bc”;</span><br><span class="line">String s4 = s2 + s3;</span><br><span class="line">System.out.println(s1 == s4);<span class="comment">//false，因为s2+s3实际上是使用StringBuilder.append来完成，会生成不同的对象。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 &#x3D; “abc”;</span><br><span class="line">final String s2 &#x3D; “a”;</span><br><span class="line">final String s3 &#x3D; “bc”;</span><br><span class="line">String s4 &#x3D; s2 + s3;</span><br><span class="line">System.out.println(s1 &#x3D;&#x3D; s4);&#x2F;&#x2F;true，因为final变量在编译后会直接替换成对应的值，</span><br><span class="line">&#x2F;&#x2F;所以实际上等于s4&#x3D;”a”+”bc”，而这种情况下，编译器会直接合并为s4&#x3D;”abc”，所以最终s1&#x3D;&#x3D;s4。</span><br></pre></td></tr></table></figure>

<h2 id="字符串乱码"><a href="#字符串乱码" class="headerlink" title="字符串乱码"></a>字符串乱码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str  =<span class="string">&quot;nihao 你好 喬亂&quot;</span>;</span><br><span class="line"><span class="comment">// 字符串转化成 byte 数组</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = str.getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>);</span><br><span class="line"><span class="comment">// byte 数组转化成字符串</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(bytes);</span><br><span class="line">log.info(s2);</span><br><span class="line"><span class="comment">// 结果打印为：</span></span><br><span class="line">nihao ?? ??</span><br></pre></td></tr></table></figure>

<p><strong>解决：</strong></p>
<pre><code>唯一的解决办法，就是在所有需要用到编码的地方，都统一使用 UTF-8，对于 String 来说，getBytes 和 new String 两个方法都会使用到编码，我们把这两处的编码替换成 UTF-8 后，打印出的结果就正常了
</code></pre>
<h3 id="如何解决-String-乱码的问题"><a href="#如何解决-String-乱码的问题" class="headerlink" title="如何解决 String 乱码的问题"></a>如何解决 String 乱码的问题</h3><p>乱码的问题的根源主要是两个：字符集不支持复杂汉字、二进制进行转化时字符集不匹配，所以在 String 乱码时我们可以这么做：</p>
<ol>
<li>所有可以指定字符集的地方强制指定字符集，比如 new String 和 getBytes 这两个地方；</li>
<li>我们应该使用 UTF-8 这种能完整支持复杂汉字的字符集。</li>
</ol>
<h2 id="截取-首字母大小写"><a href="#截取-首字母大小写" class="headerlink" title="截取(首字母大小写)"></a>截取(首字母大小写)</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><pre><code>项目被 Spring 托管的话，有时候我们会通过 `applicationContext.getBean(className);` 这种方式得到 SpringBean，这时 className 必须是要满足首字母小写的，除了该场景，在反射场景下面，我们也经常要使类属性的首字母小写。
</code></pre>
<h3 id="一般处理方法"><a href="#一般处理方法" class="headerlink" title="一般处理方法"></a>一般处理方法</h3><p><code>name.substring(0, 1).toLowerCase() + name.substring(1);</code>，使用 substring 方法，该方法主要是为了截取字符串连续的一部分，substring 有两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> #beginIndex：开始位置，endIndex：结束位置；</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> # beginIndex 开始位置，结束位置为文本末尾。</span></span><br></pre></td></tr></table></figure>

<p>substring 方法的底层使用的是字符数组范围截取的方法 ：Arrays.copyOfRange(字符数组, 开始位置, 结束位置); 从字符数组中进行一段范围的拷贝。</p>
<p>相反的，如果要修改成首字母大写，只需要修改成 <code>name.substring(0, 1).toUpperCase() + name.substring(1);</code> 即可。</p>
<h2 id="相等判断"><a href="#相等判断" class="headerlink" title="相等判断"></a>相等判断</h2><p><code>equals 和 equalsIgnoreCase</code>。后者判断相等时，会忽略大小写</p>
<h3 id="equals源码"><a href="#equals源码" class="headerlink" title="equals源码"></a>equals源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断内存地址是否相同</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 待比较的对象是否是 String，如果不是 String，直接返回不相等</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="comment">// 两个字符串的长度是否相等，不等则直接返回不相等</span></span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 依次比较每个字符是否相等，若有一个不等，直接返回不相等</span></span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="替换、删除"><a href="#替换、删除" class="headerlink" title="替换、删除"></a>替换、删除</h2><p><code>replace</code> 替换所有字符、<code>replaceAll</code> 批量替换字符串、<code>replaceFirst</code>替换遇到的第一个字符串三种场景</p>
<p>replace 有两个方法，一个入参是 char，一个入参是 String，前者表示替换所有字符，如：<code>name.replace(&#39;a&#39;,&#39;b&#39;)</code>，后者表示替换所有字符串，如：<code>name.replace(&quot;a&quot;,&quot;b&quot;)</code>，两者就是单引号和多引号的区别。</p>
<p><em>需要注意的是， replace 并不只是替换一个，是替换所有匹配到的字符或字符串哦。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReplace</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String str =<span class="string">&quot;hello word !!&quot;</span>;</span><br><span class="line">  log.info(<span class="string">&quot;替换之前 :&#123;&#125;&quot;</span>,str);</span><br><span class="line">  str = str.replace(<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">  log.info(<span class="string">&quot;替换所有字符 :&#123;&#125;&quot;</span>,str);</span><br><span class="line">  str = str.replaceAll(<span class="string">&quot;d&quot;</span>,<span class="string">&quot;l&quot;</span>);</span><br><span class="line">  log.info(<span class="string">&quot;替换全部 :&#123;&#125;&quot;</span>,str);</span><br><span class="line">  str = str.replaceFirst(<span class="string">&quot;l&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">  log.info(<span class="string">&quot;替换第一个 l :&#123;&#125;&quot;</span>,str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出的结果是：</span></span><br><span class="line">替换之前 :hello word !!</span><br><span class="line">替换所有字符 :heddo word !!</span><br><span class="line">替换全部 :hello worl !!</span><br><span class="line">替换第一个 :helo worl !!</span><br></pre></td></tr></table></figure>

<p>当然我们想要删除某些字符，也可以使用 replace 方法，把想删除的字符替换成 “” 即可。替换、删除</p>
<h2 id="拆分和合并"><a href="#拆分和合并" class="headerlink" title="拆分和合并"></a>拆分和合并</h2><p>拆分我们使用 split 方法，该方法有两个入参数。第一个参数是我们拆分的标准字符，第二个参数是一个 int 值，叫 limit，来限制我们需要拆分成几个元素。如果 limit 比实际能拆分的个数小，按照 limit 的个数进行拆分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String s =<span class="string">&quot;boo:and:foo&quot;</span>;</span><br><span class="line"><span class="comment">// 我们对 s 进行了各种拆分，演示的代码和结果是：</span></span><br><span class="line">s.split(<span class="string">&quot;:&quot;</span>) 结果:[<span class="string">&quot;boo&quot;</span>,<span class="string">&quot;and&quot;</span>,<span class="string">&quot;foo&quot;</span>]</span><br><span class="line">s.split(<span class="string">&quot;:&quot;</span>,<span class="number">2</span>) 结果:[<span class="string">&quot;boo&quot;</span>,<span class="string">&quot;and:foo&quot;</span>]</span><br><span class="line">s.split(<span class="string">&quot;:&quot;</span>,<span class="number">5</span>) 结果:[<span class="string">&quot;boo&quot;</span>,<span class="string">&quot;and&quot;</span>,<span class="string">&quot;foo&quot;</span>]</span><br><span class="line">s.split(<span class="string">&quot;:&quot;</span>,-<span class="number">2</span>) 结果:[<span class="string">&quot;boo&quot;</span>,<span class="string">&quot;and&quot;</span>,<span class="string">&quot;foo&quot;</span>]</span><br><span class="line">s.split(<span class="string">&quot;o&quot;</span>) 结果:[<span class="string">&quot;b&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;:and:f&quot;</span>]</span><br><span class="line">s.split(<span class="string">&quot;o&quot;</span>,<span class="number">2</span>) 结果:[<span class="string">&quot;b&quot;</span>,<span class="string">&quot;o:and:foo&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>那如果字符串里面有一些空值呢，拆分的结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a =<span class="string">&quot;,a,,b,&quot;</span>;</span><br><span class="line">a.split(<span class="string">&quot;,&quot;</span>) 结果:[<span class="string">&quot;&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;b&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>从拆分结果中，我们可以看到，空值是拆分不掉的，仍然成为结果数组的一员，如果我们想删除空值，只能自己拿到结果后再做操作，但 Guava（Google 开源的技术工具） 提供了一些可靠的工具类，可以帮助我们快速去掉空值，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String a =<span class="string">&quot;,a, ,  b  c ,&quot;</span>;</span><br><span class="line"><span class="comment">// Splitter 是 Guava 提供的 API </span></span><br><span class="line">List&lt;String&gt; list = Splitter.on(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    .trimResults()<span class="comment">// 去掉空格</span></span><br><span class="line">    .omitEmptyStrings()<span class="comment">// 去掉空值</span></span><br><span class="line">    .splitToList(a);</span><br><span class="line">log.info(<span class="string">&quot;Guava 去掉空格的分割方法：&#123;&#125;&quot;</span>,JSON.toJSONString(list));</span><br><span class="line"><span class="comment">// 打印出的结果为：</span></span><br><span class="line">[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b  c&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>从打印的结果中，可以看到去掉了空格和空值，这正是我们工作中常常期望的结果，所以推荐使用 Guava 的 API 对字符串进行分割。</p>
<p>合并我们使用 join 方法，此方法是静态的，我们可以直接使用。方法有两个入参，参数一是合并的分隔符，参数二是合并的数据源，数据源支持数组和 List，在使用的时候，我们发现有两个不太方便的地方：</p>
<ol>
<li>不支持依次 join 多个字符串，比如我们想依次 join 字符串 s 和 s1，如果你这么写的话 <code>String.join(&quot;,&quot;,s).join(&quot;,&quot;,s1)</code> 最后得到的是 s1 的值，第一次 join 的值被第二次 join 覆盖了；</li>
<li>如果 join 的是一个 List，无法自动过滤掉 null 值。</li>
</ol>
<p>而 Guava 正好提供了 API，解决上述问题，我们来演示一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依次 join 多个字符串，Joiner 是 Guava 提供的 API</span></span><br><span class="line">Joiner joiner = Joiner.on(<span class="string">&quot;,&quot;</span>).skipNulls();</span><br><span class="line">String result = joiner.join(<span class="string">&quot;hello&quot;</span>,<span class="keyword">null</span>,<span class="string">&quot;china&quot;</span>);</span><br><span class="line">log.info(<span class="string">&quot;依次 join 多个字符串:&#123;&#125;&quot;</span>,result);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;china&quot;</span>,<span class="keyword">null</span>&#125;);</span><br><span class="line">log.info(<span class="string">&quot;自动删除 list 中空值:&#123;&#125;&quot;</span>,joiner.join(list));</span><br><span class="line"><span class="comment">// 输出的结果为；</span></span><br><span class="line">依次 join 多个字符串:hello,china</span><br><span class="line">自动删除 list 中空值:hello,china</span><br></pre></td></tr></table></figure>

<p>从结果中，我们可以看到 Guava 不仅仅支持多个字符串的合并，还帮助我们去掉了 List 中的空值，这就是我们在工作中常常需要得到的结果。</p>
<h1 id="String-StringBuffer-和-StringBuilder-的区别是什么"><a href="#String-StringBuffer-和-StringBuilder-的区别是什么" class="headerlink" title="String, StringBuffer 和 StringBuilder 的区别是什么?"></a>String, StringBuffer 和 StringBuilder 的区别是什么?</h1><p><strong>可变性</strong></p>
<p>简单的来说：<code>String</code> 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以<code>String</code> 对象是不可变的。</p>
<blockquote>
<p>补充：在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 <code>private final byte[] value</code>;</p>
</blockquote>
<p>而 <code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 <code>final</code> 关键字修饰，所以这两种对象都是可变的。</p>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 的构造方法都是调用父类构造方法也就是<code>AbstractStringBuilder</code> 实现的</p>
<p><strong>线程安全性</strong></p>
<p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
<h1 id="String-intern"><a href="#String-intern" class="headerlink" title="String().intern()"></a>String().intern()</h1><p>调用这个方法之后把字符串对象加入常量池中</p>
<ol>
<li>直接定义字符串变量的时候赋值，如果表达式右边只有字符串常量，那么就是把变量存放在常量池里面。</li>
<li>new出来的字符串是存放在堆里面。</li>
<li>对字符串进行拼接操作，也就是做”+”运算的时候，分2中情况：</li>
</ol>
<p>i.表达式右边是纯字符串常量，那么存放在栈里面。</p>
<p>ii.表达式右边如果存在字符串引用，也就是字符串对象的句柄，那么就存放在堆里面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">String str3 = <span class="string">&quot;aaabbb&quot;</span>;</span><br><span class="line">String str4 = str1 + str2;</span><br><span class="line">String str5 = <span class="string">&quot;aaa&quot;</span> + <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">System.out.println(str3 == str4); <span class="comment">// false</span></span><br><span class="line">System.out.println(str3 == str4.intern()); <span class="comment">// true</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>结果：str1、str2、str3、str5都是存在于常量池，str4由于表达式右半边有引用类型，所以str4存在于堆内存，而str5表达式右边没有引用类型，是纯字符串常量，就存放在了常量池里面。其实Integer这种包装类型的-128~ +127也是存放在常量池里面，比如Integer i1 = 10;Integer i2 = 10; i1 == i2结果是true，估计也是为了性能优化。</p>
<h1 id="数组有没有-length-方法-String-有没有-length-方法？"><a href="#数组有没有-length-方法-String-有没有-length-方法？" class="headerlink" title="数组有没有 length()方法?String 有没有 length()方法？"></a>数组有没有 length()方法?String 有没有 length()方法？</h1><p>数组没有 length()方法，有 length 的属性。String 有 length()方法。Jav aScript 中，获得字符串的长度是通过 length 属性得到的</p>
<h1 id="String-类和常量池"><a href="#String-类和常量池" class="headerlink" title="String 类和常量池"></a>String 类和常量池</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abcd&quot;</span>;<span class="comment">//先检查字符串常量池中有没有&quot;abcd&quot;，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向&quot;abcd&quot;&quot;；</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);<span class="comment">//堆中创建一个新的对象</span></span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);<span class="comment">//堆中创建一个新的对象</span></span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str2==str3);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>这两种不同的创建方法是有差别的。</p>
<ul>
<li>第一种方式是在常量池中拿对象；</li>
<li>第二种方式是直接在堆内存空间创建一个新的对象。</li>
</ul>
<p>记住一点：<strong>只要使用 new 方法，便需要创建新的对象。</strong></p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/2019-3String-Pool-Java1-450x249.png?ynotemdtimestamp=1618390160630" alt="String-Pool-Java"></p>
<p><strong>String 类型的常量池比较特殊。它的主要使用方法有两种：</strong></p>
<ul>
<li>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</li>
<li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;计算机&quot;</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s3 = <span class="string">&quot;计算机&quot;</span>;</span><br><span class="line">System.out.println(s2);<span class="comment">//计算机</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，</span></span><br><span class="line">System.out.println(s3 == s2);<span class="comment">//true，因为两个都是常量池中的 String 对象</span></span><br></pre></td></tr></table></figure>

<p><strong>字符串拼接:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String str1 &#x3D; &quot;str&quot;;</span><br><span class="line">String str2 &#x3D; &quot;ing&quot;;</span><br><span class="line">         </span><br><span class="line">String str3 &#x3D; &quot;str&quot; + &quot;ing&quot;;&#x2F;&#x2F;常量池中的对象</span><br><span class="line">String str4 &#x3D; str1 + str2; &#x2F;&#x2F;在堆上创建的新的对象      </span><br><span class="line">String str5 &#x3D; &quot;string&quot;;&#x2F;&#x2F;常量池中的对象</span><br><span class="line">System.out.println(str3 &#x3D;&#x3D; str4);&#x2F;&#x2F;false</span><br><span class="line">System.out.println(str3 &#x3D;&#x3D; str5);&#x2F;&#x2F;true</span><br><span class="line">System.out.println(str4 &#x3D;&#x3D; str5);&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5-%E5%B8%B8%E9%87%8F%E6%B1%A02.png?ynotemdtimestamp=1618390160630" alt="字符串拼接"></p>
<p>尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。</p>
<h2 id="String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="String s1 = new String(“abc”);这句话创建了几个字符串对象？"></a>String s1 = new String(“abc”);这句话创建了几个字符串对象？</h2><p><strong>将创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。如果池中没有字符串常量“abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</strong></p>
<p><strong>验证：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);<span class="comment">// 堆内存的地址值</span></span><br><span class="line">String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。</span></span><br><span class="line">System.out.println(s1.equals(s2));<span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/09/Spring-SpringMVC%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/09/Spring-SpringMVC%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/" itemprop="url">Spring-SpringMVC数据绑定</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-09T00:10:17+08:00">
                2021-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6-SpringMVC%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">常用框架 - SpringMVC知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/139162484">SpringMVC参数绑定-细致总结（通俗易懂）</a></p>
<h1 id="基本类型、包装类型参数绑定"><a href="#基本类型、包装类型参数绑定" class="headerlink" title="基本类型、包装类型参数绑定"></a>基本类型、包装类型参数绑定</h1><h2 id="基本类型-int"><a href="#基本类型-int" class="headerlink" title="基本类型 int"></a>基本类型 int</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RequestMapping(<span class="string">&quot;baseType.do&quot;</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">baseType</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;age:&quot;</span> + age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;baseType.do?age&#x3D;30</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当我们请求时，返回结果：age:30</span><br></pre></td></tr></table></figure>

<ul>
<li>这种情况下，首先 <strong>key 值必须传入</strong>，否则会报 <strong>500 错误</strong>，提示当前 age 不能为空</li>
<li>其次，<strong>参数只能为 int 类型</strong>，否则报 <strong>400 参数异常错误</strong></li>
</ul>
<p><strong>是否可以使用<code>@RequestParam</code>的  required 属性，避免请求参数为空</strong></p>
<p>答案是不能，虽然这个注解设置 required = false 后不传值后台也不会报错，但是如果其中指定了基本数据类型。例如我们代码中的 int  这个时候如果不传值是依旧会报一个 500 错误因为其不传值就赋 null，但是 int 类型却不能为null，所以想要规避这个参数为空的问题，我们就可以选择包装类型 Integer</p>
<h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;packingType.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">packingType</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;age:&quot;</span> + age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;packingType.do?age&#x3D;30</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正常返回：age:30</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;packingType.do</span><br><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;packingType.do?</span><br><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;packingType.do?&#x3D;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数为空不报错，均返回：age:null</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>可以不传 key</strong>，后台接收到的数据则为 age=null</li>
<li>所以开发中，<strong>对于参数可能为空的数据，建议使用包装类型</strong></li>
<li>当然，我们也可以使用 @RequestParam 注解 来设置是否请求中必须包含该参数，此注解默认就是必须传参，否则报错</li>
</ul>
<h1 id="对象的参数绑定"><a href="#对象的参数绑定" class="headerlink" title="对象的参数绑定"></a>对象的参数绑定</h1><h2 id="多层级对象的绑定"><a href="#多层级对象的绑定" class="headerlink" title="多层级对象的绑定"></a>多层级对象的绑定</h2><ul>
<li>创建用户类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    ......补充其 get set toString 方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>直接在参数中写上对应 User 类型就可以了</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;objectType.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">objectType</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;objectType.do?id&#x3D;001&amp;name&#x3D;Steven</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回结果：User&#123;uid&#x3D;&#39;001&#39;, name&#x3D;&#39;Steven&#39;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个新的类 UserDetails</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    ......补充其 get set toString 方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 User 类中引入这个类，这种情况又该如何绑定参数呢</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> UserDetails userDetails;</span><br><span class="line">    </span><br><span class="line">    ......补充其 get set toString 方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;objectType.do?id&#x3D;1&amp;name&#x3D;Steven&amp;userDetails.age&#x3D;20&amp;userDetails.address&#x3D;BeiJing</span><br></pre></td></tr></table></figure>

<p>返回结果：User{uid=’1’, name=’Steven’, userDetails=UserDetails{age=20, address=’BeiJing’}}</p>
<ul>
<li>对于引入的对象成员复赋值，格式就例如：<code>userDetails.address=xxxxx</code></li>
<li>这里地址我没用中文，是因为我是直接返回的，没经过编码的处理，不然会显示</li>
</ul>
<h2 id="同属性对象参数绑定"><a href="#同属性对象参数绑定" class="headerlink" title="同属性对象参数绑定"></a>同属性对象参数绑定</h2><p>如果我们想要直接接收两个对象，有时候免不了有相同的成员，例如我们的 User 和 Student 类中均含有</p>
<p>Integer id 、String name 两个成员，我们试着请求一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;objectType2.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">objectType2</span><span class="params">(User user, Student student)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user.toString() + <span class="string">&quot; &quot;</span> + student.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;objectType2.do?id&#x3D;8&amp;name&#x3D;Steven</span><br></pre></td></tr></table></figure>

<p>返回结果：User{id=’8’, name=’Steven’} Student{id=’8’, name=’Steven’}</p>
<p>可以看到，两个对象的值都被赋上了，但是，大部分情况下，不同的对象的值一般都是不同的，为此，我们还有解决办法</p>
<p>@InitBinder 注解可以帮助我们分开绑定，下面的代码也就是说分别给 user、student 指定一个前缀</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InitBinder(&quot;user&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initUser</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line">    binder.setFieldDefaultPrefix(<span class="string">&quot;user.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@InitBinder(&quot;student&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initStudent</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line">    binder.setFieldDefaultPrefix(<span class="string">&quot;stu.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;objectType2.do?user.id&#x3D;1&amp;name&#x3D;Steven&amp;stu.id&#x3D;002</span><br></pre></td></tr></table></figure>

<p>当发起这样一个请求后，我们分别指定了 user 和 student 的 id 值，而 name 则是同样的 Steven</p>
<p>返回结果：User{id=’1’, name=’Steven’, userDetails=null} Student{id=’2’, name=’Steven’}</p>
<h1 id="数组类型参数绑定"><a href="#数组类型参数绑定" class="headerlink" title="数组类型参数绑定"></a>数组类型参数绑定</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;arrayType.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">arrayType</span><span class="params">(String[] nickname)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (String s : nickname) &#123;</span><br><span class="line">        sb.append(s).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;arrayType.do?nickname&#x3D;Jack&amp;nickname&#x3D;Steven&amp;nickname&#x3D;Tom</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回结果：Jack, Steven, Tom,</span><br></pre></td></tr></table></figure>

<h1 id="集合类型参数绑定"><a href="#集合类型参数绑定" class="headerlink" title="集合类型参数绑定"></a>集合类型参数绑定</h1><h2 id="List-类型"><a href="#List-类型" class="headerlink" title="List 类型"></a>List 类型</h2><p>集合是不能直接进行参数绑定的，所以我们需要创建出一个类，然后在类中进行对 List 的参数绑定</p>
<p>首先创建 UserList 类，其中我为了演示，只放了  <code>private List&lt;User&gt; users</code> 补充好 get set toString 方法</p>
<p>控制层方法中，参数就是这个创建出来的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;listType.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">listType</span><span class="params">(UserList userList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userList.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;listType.do?users[0].id&#x3D;1&amp;users[0].name&#x3D;Jack&amp;users[1].id&#x3D;2&amp;users[1].name&#x3D;Marry</span><br></pre></td></tr></table></figure>

<p>我们的请求，分别将两个user信息存入了 <code>List&lt;User&gt; users</code>中</p>
<p><strong>特别注意</strong>：如果你的 Tomcat 版本是 7.0 左右 那么上述请求是没问题的，但是如果版本比较高，例如我本身所用的 Tomcat 8.5 ，如果执行上述请求就会报 400 错误</p>
<blockquote>
<p><strong>HTTP Status 400 – Bad Request</strong><br><strong>Message</strong> Invalid character found in the request target. The valid characters are defined in RFC 7230 and RFC 3986</p>
</blockquote>
<p>这是因为Tomcat高的版本地址中不能使用“[”和“]” ，我们可以将其换成对应的16进制，即 “[” 换成 %5B，“]” 换成 %5D</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;listType.do?users%5B0%5D.id&#x3D;1&amp;users%5B0%5D.name&#x3D;Jack&amp;users%5B1%5D.id&#x3D;2&amp;users%5B1%5D.name&#x3D;Marry</span><br></pre></td></tr></table></figure>

<p>或者直接用 post 请求也是可以的</p>
<h2 id="Map-类型"><a href="#Map-类型" class="headerlink" title="Map 类型"></a>Map 类型</h2><p>map 类型是一样的套路，我们先创建一个 UserMap类，然后在其中声明 <code>private Map&lt;String,User&gt; users</code> 进而绑定参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;mapType.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">mapType</span><span class="params">(UserMap userMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userMap.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;mapType.do?users[&#39;userA&#39;].id&#x3D;1&amp;users[&#39;userA&#39;].name&#x3D;Jack&amp;users[&#39;userB&#39;].id&#x3D;2&amp;users[&#39;userB&#39;].name&#x3D;Tom</span><br></pre></td></tr></table></figure>

<p>同样 “[]” 会遇到上面的错误，所以如果想要在地址栏请求访问，就需要替换字符，或者发起一个 post 请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;mapType.do?users%5B%27userA%27%5D.id&#x3D;1&amp;users%5B%27userA%27%5D.name&#x3D;Jack&amp;users%5B%27userB%27%5D.id&#x3D;2&amp;users%5B%27userB%27%5D.name&#x3D;Tom</span><br></pre></td></tr></table></figure>

<p>返回结果：UserMap{users={userA=User{id=’1’, name=’Jack’}, userB=User{id=’2’, name=’Tom’}}}</p>
<h1 id="JSON-参数绑定"><a href="#JSON-参数绑定" class="headerlink" title="JSON 参数绑定"></a>JSON 参数绑定</h1><p>除了前面表单等提交的方式，我们还有一种ajax的提交方式，常常用来向后端传递以及接受 json 格式的数据，关于 json 字符串和对象之间的转换会用到下面的 jar包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>这一块的演示，我们创建一个 Admin 实体类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Admin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    ......补充其 get set toString 方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实体参数绑定"><a href="#实体参数绑定" class="headerlink" title="实体参数绑定"></a>实体参数绑定</h2><p>当 ajax 传递的参数很多的时候，使用参数名匹配，会非常麻烦，如果请求的参数在后台中有一个匹配的实体类，我们就可以选择前台传一个 json 到后台，后台使用匹配的实体类进行接收</p>
<p>提交 JSON： {“id”: “37”,”name”: “张三”}</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&quot;#btn&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//发送ajax请求</span></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url:<span class="string">&quot;ajaxType1.do&quot;</span>,</span><br><span class="line">            contentType:<span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">            data:<span class="string">&#x27;&#123;&quot;id&quot;:&quot;37&quot;,&quot;name&quot;:&quot;张三&quot;&#125;&#x27;</span>,</span><br><span class="line">            dataType:<span class="string">&quot;json&quot;</span>,</span><br><span class="line">            type:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">            success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//解析响应数据</span></span><br><span class="line">            alert(data.id);</span><br><span class="line">            alert(data.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>Contoller</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用实体接参数</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;ajaxType1.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Admin <span class="title">ajaxType1</span><span class="params">(<span class="meta">@RequestBody</span> Admin admin)</span> </span>&#123;</span><br><span class="line">    System.out.println(admin.toString());</span><br><span class="line">    admin.setName(<span class="string">&quot;测试管理员&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> admin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后端参数中的 admin 就会被绑定好参数，供开发者使用</p>
<p><code>@RequestBody</code> 注解常用来处理 <code>content-type</code>不是默认的<code>application/x-www-form-urlcoded</code>编码的内容，说常处理<code>application/json</code>类型</p>
<h2 id="Map-参数绑定"><a href="#Map-参数绑定" class="headerlink" title="Map 参数绑定"></a>Map 参数绑定</h2><p>还有一种情况，那就是请求的参数仍然挺多，但是后台也没有一个合适的实体进行匹配，我们也可以考虑使用map来接收</p>
<p>依旧提交 JSON： {“id”: “37”,”name”: “张三”}</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&quot;#btn&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//发送ajax请求</span></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url:<span class="string">&quot;ajaxType1.do&quot;</span>,</span><br><span class="line">            contentType:<span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">            data:<span class="string">&#x27;&#123;&quot;id&quot;:&quot;37&quot;,&quot;name&quot;:&quot;张三&quot;&#125;&#x27;</span>,</span><br><span class="line">            dataType:<span class="string">&quot;json&quot;</span>,</span><br><span class="line">            type:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">            success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//解析响应数据</span></span><br><span class="line">            alert(data.id);</span><br><span class="line">            alert(data.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>但是 Controller 中我们使用 map 来进行接收，然后简单给了一个实例，将map值封装到 Admin 对象中，然后返回到前端去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;ajaxType3.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Admin <span class="title">ajaxType3</span><span class="params">(<span class="meta">@RequestBody</span> Map&lt;String, String&gt; map)</span>  </span>&#123;</span><br><span class="line">    Integer id = <span class="keyword">null</span>;</span><br><span class="line">    String name = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(<span class="string">&quot;id&quot;</span>))&#123;</span><br><span class="line">        id = Integer.parseInt(map.get(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(<span class="string">&quot;name&quot;</span>))&#123;</span><br><span class="line">        name = map.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Admin admin = <span class="keyword">new</span> Admin();</span><br><span class="line">    admin.setId(id);</span><br><span class="line">    admin.setName(name);</span><br><span class="line">    <span class="keyword">return</span> admin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="List-参数绑定"><a href="#List-参数绑定" class="headerlink" title="List 参数绑定"></a>List 参数绑定</h2><p>同样的，我们还可以使用 list 方式进行接收，它时以 json 数组的形式传递的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> listType=[];</span><br><span class="line"><span class="keyword">var</span> admin=&#123;&#125;;</span><br><span class="line">admin.id=<span class="number">1</span>;</span><br><span class="line">admin.name=<span class="string">&#x27;汤姆&#x27;</span>;</span><br><span class="line">listType.push(admin);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> admin2=&#123;&#125;;</span><br><span class="line">admin2.id=<span class="number">2</span>;</span><br><span class="line">admin2.name=<span class="string">&#x27;杰克&#x27;</span>;</span><br><span class="line">listType.push(admin2);</span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&quot;#btn&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//发送ajax请求</span></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url:<span class="string">&quot;ajaxType1.do&quot;</span>,</span><br><span class="line">            contentType:<span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">            data:<span class="built_in">JSON</span>.stringify(listType),</span><br><span class="line">            dataType:<span class="string">&quot;json&quot;</span>,</span><br><span class="line">            type:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">            success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//解析响应数据</span></span><br><span class="line">            alert(data.id);</span><br><span class="line">            alert(data.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>去后台看一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;ajaxType5.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ajaxType5</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;Admin&gt; list)</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Admin admin : list)&#123;</span><br><span class="line">        System.out.println(admin.getId() + <span class="string">&quot; &quot;</span> + admin.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下控制台的输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Admin&#123;id=&#x27;1&#x27;, name=&#x27;汤姆&#x27;&#125;, Admin&#123;id=&#x27;2&#x27;, name=&#x27;杰克&#x27;&#125;]</span><br><span class="line">1 汤姆</span><br><span class="line">2 杰克</span><br></pre></td></tr></table></figure>

<h2 id="表单提交"><a href="#表单提交" class="headerlink" title="表单提交"></a>表单提交</h2><p>这是用来提交的表单</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;ajaxForm&quot;</span>  <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    id:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    name:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这是 ajax请求，我们也常用<code>$(&quot;#ajaxForm&quot;).serialize()</code> 进行一个表单的序列化，然后提交，但是它只是将Form序列化拼接成了简单的字符串，并不是JSON格式，它是例如这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=<span class="number">111</span>&amp;name=Steven</span><br></pre></td></tr></table></figure>

<p>所以刚才所说的json那一套就不管用了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&quot;#btn&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//发送ajax请求</span></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url:<span class="string">&quot;ajaxType1.do&quot;</span>,</span><br><span class="line">            contentType:<span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">            data:$(<span class="string">&quot;#ajaxForm&quot;</span>).serialize(),</span><br><span class="line">            dataType:<span class="string">&quot;json&quot;</span>,</span><br><span class="line">            type:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">            success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//解析响应数据</span></span><br><span class="line">            alert(data.id);</span><br><span class="line">            alert(data.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果想要使用序列化，同时还想要传递 json 格式到后台，也不是没办法</p>
<p>我们需要添加一个方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$.fn.serializeObject = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">this</span>.serializeArray();</span><br><span class="line">    $.each(a, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o[<span class="built_in">this</span>.name]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!o[<span class="built_in">this</span>.name].push) &#123;</span><br><span class="line">                o[<span class="built_in">this</span>.name] = [o[<span class="built_in">this</span>.name]];</span><br><span class="line">             &#125;</span><br><span class="line">            o[<span class="built_in">this</span>.name].push(<span class="built_in">this</span>.value || <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            o[<span class="built_in">this</span>.name] = <span class="built_in">this</span>.value || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同时将下面 ajax 中的 data修改为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:<span class="built_in">JSON</span>.stringify($(<span class="string">&quot;#ajaxForm&quot;</span>).serializeObject()),</span><br></pre></td></tr></table></figure>

<p>后台就能获取到 json 格式了</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;id&quot;</span>:<span class="string">&quot;111&quot;</span>,<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;Steven&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h1 id="XML-参数绑定"><a href="#XML-参数绑定" class="headerlink" title="XML 参数绑定"></a>XML 参数绑定</h1><p>后台非常简单，和前面没什么区别，我们需要在实体中进行一些操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;xmlType.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">xmlType</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> student.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下，我们需要借助一个jar包 —— spring-oxm，自己可以导入一下</p>
<p>然后我们需要在接受的实体那里，添加 @XmlRootElement 和 @XmlElement 注解，来代表根节点和子节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ideal.Object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.annotation.XmlElement;</span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.annotation.XmlRootElement;</span><br><span class="line"></span><br><span class="line"><span class="meta">@XmlRootElement(name = &quot;student&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XmlElement(name = &quot;id&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XmlElement(name = &quot;name&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&#x27;&quot;</span> + id + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如我们xml为</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span>&gt;</span>66<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>Steven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后发起请求，注意将Content-Type 改为 application/xml</p>
<p>返回的结果：Student{id=’66’, name=’Steven’}</p>
<h1 id="PropertyEditor、Formatter、Converter自定义格式化工具和类型转换器"><a href="#PropertyEditor、Formatter、Converter自定义格式化工具和类型转换器" class="headerlink" title="PropertyEditor、Formatter、Converter自定义格式化工具和类型转换器"></a>PropertyEditor、Formatter、Converter自定义格式化工具和类型转换器</h1><blockquote>
<p>1、PropertyEditor：内置可扩展，在类中进行局部使用 webdatabinder。（不推荐，一般使用全局方案会比较多）<br>2、Formatter：内置可扩展，全局，或者使用new Formatter的方式进行局部使用，只能转换String到其他类型。<br>3、Converter：内置不可扩展，全局或局部，和Formatter类似，但Converter的源对象不仅仅是String，而可以自行进行定义。</p>
</blockquote>
<h2 id="PropertyEditor"><a href="#PropertyEditor" class="headerlink" title="PropertyEditor"></a>PropertyEditor</h2><ul>
<li>全局处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 日期格式的字符串转换成Date对象</span></span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        dateFormat.setLenient(<span class="keyword">false</span>);</span><br><span class="line">        binder.registerCustomEditor(Date.class, <span class="keyword">new</span> CustomDateEditor(dateFormat, <span class="keyword">false</span>));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@InitBinder注解标注的方法：用于请求中注册自定义参数的解析，从而达到自定义请求参数格式的目的；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/getExamListByOpInfo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;List&lt;GetExamListResVo&gt;&gt; getExamListByOpInfo(<span class="meta">@NotNull</span> Date examOpDate,<span class="meta">@ModelAttribute(&quot;loginUserInfo&quot;)</span> UserDetails userDetails) &#123;</span><br><span class="line">    List&lt;GetExamListResVo&gt; resVos = examService.getExamListByOpInfo(examOpDate, userDetails);</span><br><span class="line">    Result&lt;List&lt;GetExamListResVo&gt;&gt; result = <span class="keyword">new</span> Result(resVos);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Formatter"><a href="#Formatter" class="headerlink" title="Formatter"></a>Formatter</h2><ol>
<li><p>定义Formatter类：</p>
<p>需要实现Formatter接口, 并在pase方法中进行转换的逻辑。通过@Component自动将其添加到SpringBoot容器，这样就会自动生效。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDateFormatter</span>  <span class="keyword">implements</span> <span class="title">Formatter</span>&lt;<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">parse</span><span class="params">(String text, Locale locale)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sdf.parse(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">print</span><span class="params">(Date object, Locale locale)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/date2&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">date2</span><span class="params">(Date date2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> date2.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Converter"><a href="#Converter" class="headerlink" title="Converter"></a>Converter</h2><p>1.创建转换类：其他步骤和Formatter完全一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span> ,<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sdf.parse(source);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/date2&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">date2</span><span class="params">(Date date2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> date2.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/08/Spring-Spring%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/08/Spring-Spring%E5%AD%A6%E4%B9%A0/" itemprop="url">Spring-Spring学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-08T23:45:08+08:00">
                2021-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6-Spring%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">常用框架 - Spring知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>参考：</strong><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93?id=_91-%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8jpa%e5%9c%a8%e6%95%b0%e6%8d%ae%e5%ba%93%e4%b8%ad%e9%9d%9e%e6%8c%81%e4%b9%85%e5%8c%96%e4%b8%80%e4%b8%aa%e5%ad%97%e6%ae%b5%ef%bc%9f">Spring 常见问题总结</a></p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong>  IoC 在其他语言中也有应用，并非 Spring 特有。 <strong>IoC 容器是 Spring 用来实现 IoC 的载体，  IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</strong></p>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。  <strong>IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong> </p>
<p><strong>Spring IoC的初始化过程：</strong> </p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/Springboot/Spring%20IoC%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="Spring IoC的初始化过程"></p>
<h3 id="spring-中有多少种-IOC-容器？"><a href="#spring-中有多少种-IOC-容器？" class="headerlink" title="spring 中有多少种 IOC 容器？"></a>spring 中有多少种 IOC 容器？</h3><ul>
<li><p>BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean</p>
<ul>
<li>懒加载</li>
<li>使用语法显式提供资源对象</li>
</ul>
</li>
<li><p>ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。</p>
<ul>
<li>及时加载</li>
<li>自己创建和管理对象</li>
<li>支持国际化</li>
<li>支持基于依赖的注解</li>
</ul>
</li>
</ul>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<p><strong>Spring AOP就是基于动态代理的</strong>，</p>
<p>如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，</p>
<p>如果要代理的对象，是没有实现接口的对象，这时候Spring AOP会使用<strong>Cglib</strong> ，生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/Springboot/SpringAOP.png" alt="SpringAOPProcess"></p>
<h3 id="Spring-中，优先使用哪种-AOP-呢"><a href="#Spring-中，优先使用哪种-AOP-呢" class="headerlink" title="Spring 中，优先使用哪种 AOP 呢"></a>Spring 中，优先使用哪种 AOP 呢</h3><p>（1）如果目标对象实现了接口，默认会采用 JDK 的动态代理，但也可以强制使用 CGLIB；</p>
<p>（2）如果目标对象没有实现了接口，则必须采用 CGLIB 库。</p>
<p>Spring 会自动在 JDK 动态代理和 CGLIB 之间转换。</p>
<h3 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h3><ul>
<li><p>Spring AOP 属于运行时增强，基于代理(Proxying)</p>
</li>
<li><p>AspectJ 是编译时增强。基于字节码操作(Bytecode Manipulation)</p>
</li>
</ul>
<h3 id="Aspect，JoinPoint，Advice"><a href="#Aspect，JoinPoint，Advice" class="headerlink" title="Aspect，JoinPoint，Advice"></a>Aspect，JoinPoint，Advice</h3><ul>
<li>Aspect——切面</li>
<li>JoinPoint——切点，（@Pointcut（）内的内容，可以是方法可以是注解）</li>
<li><h2 id="Advice通知"><a href="#Advice通知" class="headerlink" title="Advice通知"></a>Advice通知</h2></li>
</ul>
<h2 id="Spring-bean"><a href="#Spring-bean" class="headerlink" title="Spring bean"></a>Spring bean</h2><h3 id="Spring-中的-bean-的作用域有哪些"><a href="#Spring-中的-bean-的作用域有哪些" class="headerlink" title="Spring 中的 bean 的作用域有哪些?"></a>Spring 中的 bean 的作用域有哪些?</h3><ul>
<li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>global-session：  全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet  都有不同的会话</li>
</ul>
<h3 id="Spring-中的单例-bean-的线程安全问题了解吗？"><a href="#Spring-中的单例-bean-的线程安全问题了解吗？" class="headerlink" title="Spring 中的单例 bean 的线程安全问题了解吗？"></a>Spring 中的单例 bean 的线程安全问题了解吗？</h3><p><strong>spring单例例为什么没有安全问题(ThreadLocal)</strong><br>1、ThreadLocal：spring使用ThreadLocal解决线程安全问题；ThreadLocal会为每一个线程提供一个独立的变量量副本，从而隔离了了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量量副本，从而也就没有必要对该变量量进行行同步了。<br>ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不不影响。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更更⾼高的并发性。<br>2、单例：无状态的Bean(无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例例变量的对象，不能保存数据，是不变类，是线程安全的。)适合用不变模式，技术就是单例模式，这样可以共享实例例，提高性能。</p>
<h3 id="Component-和-Bean-的区别是什么？"><a href="#Component-和-Bean-的区别是什么？" class="headerlink" title="@Component 和 @Bean 的区别是什么？"></a>@Component 和 @Bean 的区别是什么？</h3><ol>
<li>作用对象不同: <code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li>
<li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了Spring这是某个类的示例，当我需要用它的时候还给我。</li>
<li><code>@Bean</code> 注解比 <code>Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li>
</ol>
<p><code>@Bean</code>注解使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 上面的代码相当于下面的 xml 配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transferService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面这个例子是通过 <code>@Component</code> 无法实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OneService <span class="title">getService</span><span class="params">(status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> (status)  &#123;</span><br><span class="line">        when <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl1();</span><br><span class="line">        when <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl2();</span><br><span class="line">        when <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将一个类声明为Spring的-bean-的注解有哪些"><a href="#将一个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="将一个类声明为Spring的 bean 的注解有哪些?"></a>将一个类声明为Spring的 bean 的注解有哪些?</h3><p>我们一般使用 <code>@Autowired</code> 注解自动装配 bean，要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类,采用以下注解可实现：</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个Bean不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<h3 id="Spring-中的-bean-生命周期"><a href="#Spring-中的-bean-生命周期" class="headerlink" title="Spring 中的 bean 生命周期?"></a>Spring 中的 bean 生命周期?</h3><ul>
<li>Bean 容器找到配置文件中 Spring Bean 的定义。</li>
</ul>
<p><strong>（1）实例化 Bean：</strong></p>
<p>对于 BeanFactory 容器，当向容器请求一个尚未初始化的 bean 时，或初始化 bean 的时候需要注入另一个尚未初始化 bean 的依赖时，容器就会调用 createBean 进行实例化；</p>
<p>对于 ApplicationContext 容器，当容器启动结束后，通过获取 BeanDefinition 对象中的信息，实例化所有的 bean。</p>
<p><strong>（2）设置对象属性（依赖注入）：</strong></p>
<p>实例化后的 Bean 被封装在 BeanWrapper 对象中，然后 Spring 根据 BeanDefinition 中的信息以及通过 BeanWrapper 提供的设置属性的接口完成依赖注入。</p>
<p><strong>（3）处理 Aware 接口：</strong></p>
<p>Spring 会检测该 Bean 是否实现了 xxxAware 接口，并将相关的 xxxAware 实例注入给 Bean：</p>
<p>① 如果该 Bean 实现了 BeanNameAware 接口，会调用它实现的 setBeanName (String beanId) 方法，入参是 Spring 配置文件中 Bean 的 id 值；</p>
<p>② 如果该 Bean 实现了 BeanFactoryAware 接口，会调用它实现的 setBeanFactory () 方法，传递的是 Spring 工厂自身。</p>
<p>③ 如果该 Bean 已经实现了 ApplicationContextAware 接口，会调用 setApplicationContext (ApplicationContext) 方法，入参是 Spring 上下文；</p>
<p><strong>（4）处理 BeanPostProcessor 接口：</strong></p>
<p>如果该 Bean 实现了实现了 BeanPostProcessor 接口，那将会调用 postProcessBeforeInitialization (Object obj, String s) 方法；</p>
<p><strong>（5）InitializingBean 与 init-method：</strong><br> 如果该 Bean 在 xml 中配置了 init-method 属性，则会自动调用其配置的初始化方法。</p>
<p>以上几个步骤完成后，Bean 就已经被正确创建了，之后就可以使用这个 Bean 了。</p>
<p><strong>（6）处理 DisposableBean 接口：</strong></p>
<p>当 Bean 不再需要时，会经过清理阶段，如果 Bean 实现了 DisposableBean 这个接口，会调用其实现的 destroy () 方法；</p>
<p><strong>（7）处理 destroy-method 属性：</strong></p>
<p>最后，如果这个 Bean 的 Spring 配置中配置了 destroy-method 属性，会自动调用其配置的销毁方法。</p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/Springboot/Spring%20%E4%B8%AD%E7%9A%84%20bean%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Spring Bean 生命周期"></p>
<h3 id="Spring常见的依赖注入方式"><a href="#Spring常见的依赖注入方式" class="headerlink" title="Spring常见的依赖注入方式"></a>Spring常见的依赖注入方式</h3><ul>
<li>构造器注入：利用构造方法的参数注入依赖</li>
<li>Setter注入：调用Setter的方法注入依赖</li>
<li>字段注入：在字段上使用@Autowired/Resource注解</li>
</ul>
<h4 id="各种依赖注入方式的优缺点"><a href="#各种依赖注入方式的优缺点" class="headerlink" title="各种依赖注入方式的优缺点"></a>各种依赖注入方式的优缺点</h4><ul>
<li>构造器注入：强依赖性（即必须使用此依赖），不变性（各依赖不会经常变动）</li>
<li>Setter注入：可选（没有此依赖也可以工作），可变（依赖会经常变动）</li>
<li>Field注入：大多数情况下尽量少使用字段注入，一定要使用的话，@Resource相对@Autowired对IoC容器的耦合更低</li>
</ul>
<h4 id="Field注入的缺点"><a href="#Field注入的缺点" class="headerlink" title="Field注入的缺点"></a>Field注入的缺点</h4><ul>
<li>不能像构造器那样注入不可变的对象</li>
<li>依赖对外部不可见，外界可以看到构造器和setter，但无法看到私有字段，自然无法了解所需依赖</li>
<li>会导致组件与IoC容器紧耦合（这是最重要的原因，离开了IoC容器去使用组件，在注入依赖时就会十分困难）</li>
<li>导致单元测试也必须使用IoC容器，原因同上</li>
<li>依赖过多时不够明显，比如我需要10个依赖，用构造器注入就会显得庞大，这时候应该考虑一下此组件是不是违反了单一职责原则</li>
</ul>
<h3 id="我们在Service层能不能注入Controller的Bean？"><a href="#我们在Service层能不能注入Controller的Bean？" class="headerlink" title="我们在Service层能不能注入Controller的Bean？"></a>我们在Service层能不能注入Controller的Bean？</h3><blockquote>
<p>一般我们使用Spring的时候可以注入并正常使用的，但是使用SpringMVC+Spring的时候不能</p>
</blockquote>
<p>Spring和SpringMVC都会根据自己的配置文件去生成各自的容器，那Spring的叫做父容器，SpringMVC的叫做子容器。但是其主要区别在于：子容器可以访问父容器中的Bean，而父容器不能访问子容器中的Bean，所说我们可以在Controller中注入@Service，@Component，@Repository等Bean，但如果想要在Service中注入@Controller Bean是不可以的 ，因为父容器不能访问子容器中的Bean，实际我们也不会这样用。</p>
<h3 id="为什么要分两个容器来存放Bean呢，我使用Spring扫描全部的Bean有没有问题？"><a href="#为什么要分两个容器来存放Bean呢，我使用Spring扫描全部的Bean有没有问题？" class="headerlink" title="为什么要分两个容器来存放Bean呢，我使用Spring扫描全部的Bean有没有问题？"></a>为什么要分两个容器来存放Bean呢，我使用Spring扫描全部的Bean有没有问题？</h3><p>如果我们使用Spring扫描所有的Bean，那说明所有的Bean都在父容器中，那SpringMVC会找不到Controller对象的，因为HandleMapping在找Controller时默认是不会去父容器中找的（HandleMapping处理器映射器）。如果你真的想把Controller的Bean存入父容器中，可以通过手动配置让它从父容器中找。但是这样会对HandlerMapping的配置不太好，约定大于配置嘛！（另外，如果所有Bean都在父容器中时，Controller的Bean是可以注入到Service的，因为两者都在Spring容器中）</p>
<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>MVC 是一种设计模式。Spring MVC 可以帮助我们进行更简洁的Web层的开发，并且它天生与 Spring 框架集成。Spring  MVC 下我们一般把后端项目分为  Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。</p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/Springboot/Spring%20MVC.png" alt="img"></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>原理如下图所示：</strong></p>
<blockquote>
<p>笔误的：Spring MVC 的入口函数也就是前端控制器 <code>DispatcherServlet</code> 的作用是接收请求，响应结果。</p>
</blockquote>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/Springboot/SpringMVC%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="SpringMVC运行原理"></p>
<p><strong>流程说明（重要）：</strong></p>
<ol>
<li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</li>
<li>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</li>
<li><code>HandlerAdapter</code> 会根据 <code>Handler </code>来调用真正的处理器来处理请求，并处理相应的业务逻辑。</li>
<li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/%E4%B8%AD%E9%97%B4%E4%BB%B6-redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%8C%E7%A9%BF%E9%80%8F%EF%BC%8C%E5%87%BB%E7%A9%BF%EF%BC%8C%E9%A2%84%E7%83%AD%EF%BC%8C%E6%9B%B4%E6%96%B0%EF%BC%8C%E9%99%8D%E7%BA%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/%E4%B8%AD%E9%97%B4%E4%BB%B6-redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%8C%E7%A9%BF%E9%80%8F%EF%BC%8C%E5%87%BB%E7%A9%BF%EF%BC%8C%E9%A2%84%E7%83%AD%EF%BC%8C%E6%9B%B4%E6%96%B0%EF%BC%8C%E9%99%8D%E7%BA%A7/" itemprop="url">中间件-redis缓存雪崩，穿透，击穿，预热，更新，降级</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T19:29:30+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis缓存问题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="redis-雪崩："><a href="#redis-雪崩：" class="headerlink" title="redis 雪崩："></a>redis 雪崩：</h1><p>雪崩就是指缓存中<strong>大批量热点数据过期</strong>后系统涌入大量查询请求，因为<strong>大部分数据在Redis层已经失</strong>效，请求渗透到<strong>数据库层</strong>，大批量请求犹如洪水一般涌入，引起数据库压力造成查询堵塞甚至宕机。</p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.png" alt="image"></p>
<h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><ol>
<li>将缓存失效时间分散开，比如每个key的过期时间是随机，防止同一时间大量数据过期现象发生，这样不会出现同一时间全部请求都落在数据库层，如果缓存数据库是分布式部署，将热点数据均匀分布在不同Redis和数据库中，有效分担压力，别一个人扛。</li>
<li>简单粗暴，让Redis数据永不过期（如果业务准许，比如不用更新的名单类）。当然，如果业务数据准许的情况下可以，比如中奖名单用户，每期用户开奖后，名单不可能会变了，无需更新。</li>
<li>采用限流算法，限制请求流量，业务有损；</li>
<li>加锁访问，但是吞吐量会明显下降。</li>
<li>采购第三方Redis</li>
</ol>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A92.png" alt="image"></p>
<ol start="6">
<li>多缓存结合</li>
</ol>
<img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A93.png" style="zoom:33%;" />

<h1 id="击穿和穿透"><a href="#击穿和穿透" class="headerlink" title="击穿和穿透"></a>击穿和穿透</h1><h2 id="redis-穿透"><a href="#redis-穿透" class="headerlink" title="redis 穿透"></a>redis 穿透</h2><p>穿透是指绕过Reids，调用者发起的请求参数（key）在缓存和数据库中都不存在，通过不存在的key，成功穿透到系统底层，大规模不断发起不存在的key检索请求导致系统压力过大最后故障。</p>
<p>造成穿透的伪代码多为这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(redis.get(key) == <span class="keyword">null</span>)&#123;</span><br><span class="line">  <span class="comment">// redis数据不存在或已经过期 查询数据库</span></span><br><span class="line"> Object value = dao.query(key);</span><br><span class="line">  <span class="comment">// 重新将value刷入缓存。</span></span><br><span class="line">  redis.set(key);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> reids.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="以mall项目为例子"><a href="#以mall项目为例子" class="headerlink" title="以mall项目为例子"></a>以mall项目为例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;CategoryVO&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">String catsStr = redisOperator.get(<span class="string">&quot;subCat:&quot;</span> + rootCatId);</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isBlank(catsStr))&#123;</span><br><span class="line">    list = categoryService.getSubCatList(rootCatId);</span><br><span class="line">    redisOperator.set(<span class="string">&quot;subCat:&quot;</span> + rootCatId,JsonUtils.objectToJson(list));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    list = JsonUtils.jsonToList(catsStr,CategoryVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="攻击造成缓存穿透"><a href="#攻击造成缓存穿透" class="headerlink" title="攻击造成缓存穿透"></a>攻击造成缓存穿透</h3><p>不停地调用查询接口 查询 <strong>rootCatId == 99999</strong> 的子类造成不停查询数据库</p>
<h3 id="解决办法：-1"><a href="#解决办法：-1" class="headerlink" title="解决办法："></a>解决办法：</h3><ol>
<li><p>分布式布隆过滤器：布隆是BloomFilter音译过来的，Redis 自身支持BloomFilter。</p>
<p><strong>布隆过滤器缺点</strong>: 无法删除</p>
</li>
<li><p>返回空值：遇到数据库和Redis都查询不到的值，在Redis里set一个null value，过期时间很短，目的在于同一个key再次请求时直接返回null，避免穿透。</p>
</li>
<li><p>多级缓存。L1 为原始缓存（过期时间设置为短期），L2 为二级缓存（过期时间设置为长期）。L1 失效时可以继续访问 L2，避免同时失效。不过多了一级缓存，存储成本更高，而且多个缓存之间的数据一致性问题挑战也大。</p>
</li>
</ol>
<h2 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h2><p>BloomFilter：即布隆过滤器。可以用于检索一个元素是否在一个集合中。</p>
<h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><p>BloomFilter检索一个元素是否在一个集合中有一定的错误率（很低），但不会漏判。</p>
<ul>
<li><strong>如果判断一个key不在集合中，那一定不在</strong>。</li>
<li><strong>如果判断一个key存在，那不一定真的在</strong>。</li>
</ul>
<p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 <strong>“某样东西一定不存在或者可能存在”</strong>。</p>
<p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>基本思想是利用一个足够好的Hash函数将一个字符串映射到二进制位数组中的某一位，这样不管字符串如何长，都只有一位，因此存储空间就极大的提升了。但是不管hash函数如何高效，总是会存在Hash冲突，尤其是数据量变大的时候，而BloomFilter是利用多个不同的Hash函数来解决“冲突”，即一次采用多个Hash函数把数据映射到不同的位上，降低了冲突概率。如下图所示，</p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt="image">subCat:9999 会被误判为存在</p>
<p>如何根据输入元素个数n，确定位数组m的大小及Hash函数个数？已知文献证明，当Hash函数个数k=(ln2)*(m/n)时错误率最小。</p>
<p>BloomFilter有个缺点是不能删除数据，因为删除数据可能会影响到其它数据，有一些增强算法可以实现改功能，但代价比较大，不建议使用。</p>
<p>BloomFilter十分适合海量数据去重、过滤，尤其是当检测的字符串比较大时，极大地节省内存和存储空间，同时查询效率也十分高效。如果只是在内存使用，直接使用guava包的api即可；如果要做到分布式，结合Redis可以高效实现分布式的过滤效果。</p>
<h2 id="redis击穿"><a href="#redis击穿" class="headerlink" title="redis击穿"></a>redis击穿</h2><p>击穿和穿透概念类似，一般是指一个key被穿透，这个key是热点key，同一个key会被有成千上万次请求，比如微博热点排行榜，key是小时时间戳，value是个list的榜单。每个小时产生一个key，这个key会有百万QPS，如果这个key失效了，就像保险丝熔断，百万QPS直接压垮数据库。</p>
<h3 id="解决办法：-2"><a href="#解决办法：-2" class="headerlink" title="解决办法："></a>解决办法：</h3><p>业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。类似下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(key)</span> </span>&#123;</span><br><span class="line">    String value = redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">//代表缓存值过期</span></span><br><span class="line">        <span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line">        <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;  <span class="comment">//代表设置成功</span></span><br><span class="line">            value = db.get(key);</span><br><span class="line">            redis.set(key, value, expire_secs);</span><br><span class="line">            redis.del(key_mutex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">            sleep(<span class="number">50</span>);</span><br><span class="line">            get(key);  <span class="comment">//重试</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;      </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h1><p>缓存预热这个应该是一个比较常见的概念，相信都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p>解决思路：</p>
<p>1、直接写个缓存刷新页面，上线时手工操作下；</p>
<p>2、数据量不大，可以在项目启动的时候自动进行加载；</p>
<p>3、定时刷新缓存；</p>
<h1 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h1><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<p>（1）定时去清理过期的缓存；</p>
<p>（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</p>
<p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！</p>
<h1 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h1><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<p>（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p>
<p>（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</p>
<p>（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</p>
<p>（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/%E4%B8%AD%E9%97%B4%E4%BB%B6-redis%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/%E4%B8%AD%E9%97%B4%E4%BB%B6-redis%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5/" itemprop="url">中间件-redis缓存读写策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T16:43:29+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis缓存读写策略</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="如何保证缓存和数据库数据的一致性？-重要"><a href="#如何保证缓存和数据库数据的一致性？-重要" class="headerlink" title="如何保证缓存和数据库数据的一致性？(重要)"></a>如何保证缓存和数据库数据的一致性？(重要)</h1><p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p>
<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p>
<ol>
<li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li><strong>增加cache更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。</li>
</ol>
<h1 id="redis缓存读写策略"><a href="#redis缓存读写策略" class="headerlink" title="redis缓存读写策略"></a>redis缓存读写策略</h1><ul>
<li><p>Cache Aside （旁路缓存模式）</p>
<ul>
<li>先更新数据库，再更新缓存。这种做法最大的问题就是两个并发的写操作导致脏数据</li>
<li>先删除缓存，再更新数据库。这个逻辑是错误的，因为两个并发的读和写操作导致脏数据</li>
<li>先更新数据库，再删除缓存（在实际的系统中也推荐使用这种方式）</li>
</ul>
</li>
<li><p>Read/Write Through Pattern（读写穿透）</p>
</li>
<li><p>Write-behind caching（异步缓存写入）</p>
</li>
</ul>
<h2 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache Aside Pattern（旁路缓存模式）"></a>Cache Aside Pattern（旁路缓存模式）</h2><ul>
<li><p><strong>Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。</strong></p>
</li>
<li><p>Cache Aside Pattern 中服务端需要同时维系 DB 和 cache，并且是以 DB 的结果为准。</p>
</li>
<li><p>保证最终一致性的解决方案是缓存设置过期时间。</p>
</li>
</ul>
<h3 id="缓存读步骤"><a href="#缓存读步骤" class="headerlink" title="缓存读步骤"></a>缓存读步骤</h3><ul>
<li>从 cache 中读取数据，读取到就直接返回</li>
<li>cache中读取不到的话，就从 DB 中读取数据返回</li>
<li>再把数据放到 cache 中。</li>
</ul>
<img src="https://img-blog.csdnimg.cn/img_convert/a8c18b5f5b1aed03234bcbbd8c173a87.png" alt="img" style="zoom: 50%;" />

<h3 id="缓存写步骤"><a href="#缓存写步骤" class="headerlink" title="缓存写步骤"></a>缓存写步骤</h3><h4 id="方案一：先更新缓存，再更新数据库"><a href="#方案一：先更新缓存，再更新数据库" class="headerlink" title="方案一：先更新缓存，再更新数据库"></a>方案一：先更新缓存，再更新数据库</h4><p>不推荐。</p>
<ol>
<li>先更新缓存</li>
<li>若更新数据库失败，还需再更新缓存。</li>
</ol>
<h4 id="方案二：先更新数据库，再更新缓存"><a href="#方案二：先更新数据库，再更新缓存" class="headerlink" title="方案二：先更新数据库，再更新缓存"></a>方案二：先更新数据库，再更新缓存</h4><p>不推荐。</p>
<p>同时有请求A和请求B进行更新操作，请求A与B在不同线程，可能会出现：</p>
<ol>
<li>请求A更新了数据库</li>
<li>请求B更新了数据库</li>
<li>请求B更新了缓存</li>
<li>请求A更新了缓存</li>
</ol>
<p>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。</p>
<h4 id="方案三：先删除缓存，再更新数据库"><a href="#方案三：先删除缓存，再更新数据库" class="headerlink" title="方案三：先删除缓存，再更新数据库"></a>方案三：先删除缓存，再更新数据库</h4><p>有点问题。</p>
<p>有一个请求A进行更新操作，另一个请求B进行查询操作，可能会出现：</p>
<p>（1）、单个数据库</p>
<ol>
<li>请求A进行写操作，删除缓存</li>
<li>请求B查询发现缓存不存在</li>
<li>请求B去数据库查询得到旧值</li>
<li>请求B将旧值写入缓存</li>
<li>请求A将新值写入数据库</li>
</ol>
<p>（2）、读写分离架构</p>
<ol>
<li><p>请求A进行写操作，删除缓存</p>
</li>
<li><p>请求A将数据写入数据库了，</p>
</li>
<li><p>请求B查询缓存发现，缓存没有值</p>
</li>
<li><p>请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值</p>
</li>
<li><p>请求B将旧值写入缓存</p>
</li>
<li><p>数据库完成主从同步，从库变为新值</p>
</li>
</ol>
<p>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据</p>
<h5 id="解决方案：延时双删策略"><a href="#解决方案：延时双删策略" class="headerlink" title="解决方案：延时双删策略"></a>解决方案：延时双删策略</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void write(String key,Object data)&#123;</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">    db.updateData(data);</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先淘汰缓存</li>
<li>再写数据库（这两步和原来一样）</li>
<li>休眠1秒</li>
<li>再次淘汰缓存</li>
</ol>
<p>自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>
<p>对于MySQL读写分离架构，只是睡眠时间修改为在主从同步的延时时间基础上，加几百ms。</p>
<h4 id="方案四：先更新数据库，再删除缓存"><a href="#方案四：先更新数据库，再删除缓存" class="headerlink" title="方案四：先更新数据库，再删除缓存"></a>方案四：先更新数据库，再删除缓存</h4><img src="https://img-blog.csdnimg.cn/img_convert/5687fe759a1dac9ed9554d27e3a23b6d.png" alt="img" style="zoom:50%;" />

<p>极端情况有问题。</p>
<p>有一个请求A进行更新操作，另一个请求B进行查询操作，可能会出现：</p>
<ol>
<li>请求A查询数据库得到一个旧值</li>
<li>请求B将新值写入数据库</li>
<li>请求B删除缓存</li>
<li>请求A将查到的旧值写入缓存</li>
</ol>
<p>步骤2的<strong>写数据库操作比步骤1的读数据库操作耗时更短</strong>，才有可能使得步骤3先于步骤4。可是，数据库的<strong>读操作的速度远快于写操作</strong>的，因此步骤2耗时比步骤1更短，这一情形很难出现。</p>
<h5 id="解决方案：延时双删策略-1"><a href="#解决方案：延时双删策略-1" class="headerlink" title="解决方案：延时双删策略"></a>解决方案：延时双删策略</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void write(String key,Object data)&#123;</span><br><span class="line">    db.updateData(data);</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先写数据库</li>
<li>再淘汰缓存</li>
<li>休眠1秒</li>
<li>再次淘汰缓存</li>
</ol>
<h4 id="方案三与方案四还存在问题"><a href="#方案三与方案四还存在问题" class="headerlink" title="方案三与方案四还存在问题"></a>方案三与方案四还存在问题</h4><ul>
<li>问题一:同步双删导致并发降低</li>
<li>问题二:比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况。</li>
</ul>
<h5 id="问题一解决方案"><a href="#问题一解决方案" class="headerlink" title="问题一解决方案"></a>问题一解决方案</h5><p>异步。</p>
<h5 id="问题二解决方案"><a href="#问题二解决方案" class="headerlink" title="问题二解决方案"></a>问题二解决方案</h5><p>提供一个保障的重试机制。</p>
<h6 id="方案一：消息队列方式"><a href="#方案一：消息队列方式" class="headerlink" title="方案一：消息队列方式"></a>方案一：消息队列方式</h6><p>更新数据库数据<br>缓存因为种种问题删除失败<br>将需要删除的key发送至消息队列<br>自己消费消息，获得需要删除的key<br>继续重试删除操作，直到成功</p>
<p>业务线代码侵入较大。</p>
<h6 id="方案二：订阅binlong方式"><a href="#方案二：订阅binlong方式" class="headerlink" title="方案二：订阅binlong方式"></a>方案二：订阅binlong方式</h6><p>更新数据库数据<br>数据库会将操作信息写入binlog日志当中<br>订阅程序提取出所需要的数据以及key<br>另起一段非业务代码，获得该信息<br>尝试删除缓存操作，发现删除失败<br>将这些信息发送至消息队列<br>重新从消息队列中获得该数据，重试操作。</p>
<blockquote>
<p>订阅binlog程序在MySQL中有阿里开源的中间件叫canal。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试也可。</p>
</blockquote>
<p><strong>总结</strong></p>
<p>根据数据实时性要求，以及系统并发量考虑。</p>
<p>实时性不强，则可以选择设定缓存过期时间，先删缓存再更新数据库或先更新数据库再删缓存方案都可行。</p>
<p>实时性较强的，又有大并发量可以考虑延迟双删策略。</p>
<p>至于其他如请求串行化，放入同一个队列中依次执行的，复杂没必要。</p>
<h3 id="Cache-Aside-Pattern的缺陷"><a href="#Cache-Aside-Pattern的缺陷" class="headerlink" title="Cache Aside Pattern的缺陷"></a>Cache Aside Pattern的缺陷</h3><ul>
<li><p>缺陷1：首次请求数据一定不在 cache 的问题</p>
<p>解决办法：可以将热点数据可以提前放入cache 中。</p>
</li>
<li><p>写操作比较频繁的话导致cache中的数据会被频繁被删除，这样会影响缓存命中率 。</p>
<p>解决办法：</p>
<ul>
<li>数据库和缓存数据强一致场景 ：更新DB的时候同样更新cache，不过我们需要加一个锁/分布式锁来保证更新cache的时候不存在线程安全问题。</li>
<li>可以短暂地允许数据库和缓存数据不一致的场景 ：更新DB的时候同样更新cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li>
</ul>
</li>
</ul>
<h2 id="Read-Write-Through-Pattern（读写穿透）"><a href="#Read-Write-Through-Pattern（读写穿透）" class="headerlink" title="Read/Write Through Pattern（读写穿透）"></a>Read/Write Through Pattern（读写穿透）</h2><p>Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。</p>
<p>这种缓存读写策略在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为使用的分布式缓存 Redis 并没有提供 cache 将数据写入DB的功能。</p>
<p><strong>写（Write Through）：</strong></p>
<ul>
<li>先查 cache，cache 中不存在，直接更新 DB。</li>
<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（<strong>同步更新 cache 和 DB</strong>）。</li>
</ul>
<p>简单画了一张图帮助大家理解写的步骤。</p>
<p><img src="https://img-blog.csdnimg.cn/20210201100340808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70&ynotemdtimestamp=1617437153078" alt="img"></p>
<p><strong>读(Read Through)：</strong></p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回 。</li>
<li>读取不到的话，先从 DB 加载，写入到 cache 后返回响应。</li>
</ul>
<p>简单画了一张图帮助大家理解读的步骤。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9ada757c78614934aca11306f334638d.png?ynotemdtimestamp=1617437153078" alt="img"></p>
<p>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。</p>
<p>和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。</p>
<h2 id="Write-Behind-Pattern（异步缓存写入）"><a href="#Write-Behind-Pattern（异步缓存写入）" class="headerlink" title="Write Behind Pattern（异步缓存写入）"></a>Write Behind Pattern（异步缓存写入）</h2><p>Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 DB 的读写。</p>
<p>但是，两个又有很大的不同：<strong>Read/Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。</strong></p>
<p>很明显，这种方式对数据一致性带来了更大的挑战，比如cache数据可能还没异步更新DB的话，cache服务可能就就挂掉了。</p>
<p>这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 InnoDB Buffer Pool 机制都用到了这种策略。</p>
<p>Write Behind Pattern 下 DB 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/%E4%B8%AD%E9%97%B4%E4%BB%B6-redis%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/%E4%B8%AD%E9%97%B4%E4%BB%B6-redis%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/" itemprop="url">中间件-redis实际应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T16:32:57+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E5%BA%94%E7%94%A8/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis应用</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis-最适合的场景是什么？"><a href="#Redis-最适合的场景是什么？" class="headerlink" title="Redis 最适合的场景是什么？"></a>Redis 最适合的场景是什么？</h1><p>1、会话缓存（Session Cache）</p>
<p>最常用的一种使用 Redis 的情景是会话缓存（session cache）。用 Redis 缓存会话比其他存储（如 Memcached）的优势在于：Redis 提供持久化。</p>
<p>2、全页缓存（FPC）</p>
<p>除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。能帮助你以最快速度加载你曾浏览过的页面。</p>
<p>3、队列</p>
<p>Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push/pop 操作。</p>
<p>4，排行榜/计数器</p>
<p>Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的 10个用户，我们只需要像下面一样执行即可： 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES。</p>
<p>5、发布/订阅</p>
<p>最后（但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。在社交网络中甚至可以用 Redis 的发布/订阅功能来建立聊天系统！</p>
<h1 id="Redis-做异步队列（发布-订阅）"><a href="#Redis-做异步队列（发布-订阅）" class="headerlink" title="Redis 做异步队列（发布/订阅）"></a>Redis 做异步队列（发布/订阅）</h1><p>一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。</p>
<h2 id="可不可以不用-sleep-呢？"><a href="#可不可以不用-sleep-呢？" class="headerlink" title="可不可以不用 sleep 呢？"></a>可不可以不用 sleep 呢？</h2><p>list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。</p>
<h2 id="能不能生产一次消费多次呢？"><a href="#能不能生产一次消费多次呢？" class="headerlink" title="能不能生产一次消费多次呢？"></a>能不能生产一次消费多次呢？</h2><p>使用 pub/sub 主题订阅者模式，可以实现1:N 的消息队列。</p>
<h2 id="pub-sub-有什么缺点？"><a href="#pub-sub-有什么缺点？" class="headerlink" title="pub/sub 有什么缺点？"></a>pub/sub 有什么缺点？</h2><p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 RabbitMQ等。</p>
<h2 id="redis-如何实现延时队列？"><a href="#redis-如何实现延时队列？" class="headerlink" title="redis 如何实现延时队列？"></a>redis 如何实现延时队列？</h2><p>使用 sortedset，拿时间戳作为score，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。</p>
<h1 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h1><p>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止忘记释放</p>
<h1 id="Redis-Cookie分布式会话"><a href="#Redis-Cookie分布式会话" class="headerlink" title="Redis+Cookie分布式会话"></a>Redis+Cookie分布式会话</h1><h2 id="如果在setnx之后执行expire之前进程意外crash或者重启维护了，怎么办？"><a href="#如果在setnx之后执行expire之前进程意外crash或者重启维护了，怎么办？" class="headerlink" title="如果在setnx之后执行expire之前进程意外crash或者重启维护了，怎么办？"></a>如果在setnx之后执行expire之前进程意外crash或者重启维护了，怎么办？</h2><p>setnx和expire合成一条指令</p>
<h1 id="redis批量查询优化"><a href="#redis批量查询优化" class="headerlink" title="redis批量查询优化"></a>redis批量查询优化</h1><h2 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 大量key查询</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/getALot&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getALot</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; resutl = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String k:keys) &#123;</span><br><span class="line">        resutl.add(redisOperator.get(k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resutl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h2><h3 id="mget进行批量查询"><a href="#mget进行批量查询" class="headerlink" title="mget进行批量查询"></a>mget进行批量查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量查询 mget</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/mget&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">mget</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; keysList = Arrays.asList(keys);</span><br><span class="line">    <span class="keyword">return</span> redisOperator.mget(keysList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pipeline-进行批量查询"><a href="#pipeline-进行批量查询" class="headerlink" title="pipeline 进行批量查询"></a>pipeline 进行批量查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量查询 pipeline</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/batchGet&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">batchGet</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; keysList = Arrays.asList(keys);</span><br><span class="line">    <span class="keyword">return</span> redisOperator.batchGet(keysList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="redis热点数据问题"><a href="#redis热点数据问题" class="headerlink" title="redis热点数据问题"></a>redis热点数据问题</h1><h2 id="MySQL-里有-2000w-数据，Redis-中只存-20w-的数据，如何保证Redis-中的数据都是热点数据？"><a href="#MySQL-里有-2000w-数据，Redis-中只存-20w-的数据，如何保证Redis-中的数据都是热点数据？" class="headerlink" title="MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证Redis 中的数据都是热点数据？"></a>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证Redis 中的数据都是热点数据？</h2><p>限定 Redis 占用的内存，Redis 会根据自身数据淘汰策略，加载热数据到内存。 所以，计算一下 20W 数据大约占用的内存，然后设置一下 Redis 内存限制即可。</p>
<p>Redis存储数据会限制它内存大小，如果超过了最大内存容量，会触发数据淘汰策略</p>
<h2 id="由于内存限制，导致了Redis中只能存储最多1W条的数据信息，如何确保这1w条数据是最热门的数据？"><a href="#由于内存限制，导致了Redis中只能存储最多1W条的数据信息，如何确保这1w条数据是最热门的数据？" class="headerlink" title="由于内存限制，导致了Redis中只能存储最多1W条的数据信息，如何确保这1w条数据是最热门的数据？"></a>由于内存限制，导致了Redis中只能存储最多1W条的数据信息，如何确保这1w条数据是最热门的数据？</h2><h3 id="热点数据排序（点击次数）"><a href="#热点数据排序（点击次数）" class="headerlink" title="热点数据排序（点击次数）"></a>热点数据排序（点击次数）</h3><p>既然热门数据，那么就需要有排序，使用redis中的zset数据类型是很自然的想法。数据中的某个唯一字段作为zset中的value，而点击次数作为score，记为click_zset。这样就可选出最热门的数据。而数据，则直接用HashMap存储。</p>
<h3 id="热点数据时间（近期访问）"><a href="#热点数据时间（近期访问）" class="headerlink" title="热点数据时间（近期访问）"></a>热点数据时间（近期访问）</h3><p>既然只能存1w条数据且需要是热门数据，那么，点击次数是一方面，时效性也是一方面，如何保证？可以另起一个zset，数据的字段为value，而每次点击时更新当前时间戳为其score，记为time_zset这样，就可以记录时间。在后台跑一个任务，间隔一定时间段删除两个zset中长时间没有发生点击事件的键，并删除hash数据，为产生的新数据腾出数据空间。</p>
<h3 id="处理新热点数据"><a href="#处理新热点数据" class="headerlink" title="处理新热点数据"></a>处理新热点数据</h3><p>如果有空间，则保存到自己的hashmap，并将key存到两个zset中。 而没有空间时，就应该在click_zset中取出点击次数排在最前第1w位后面的键，删除对应的hash数据。然后看这1w个score的值，然后把key放入两个zset中即可。</p>
<h1 id="redis在自己工作中的使用"><a href="#redis在自己工作中的使用" class="headerlink" title="redis在自己工作中的使用"></a>redis在自己工作中的使用</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37334135/article/details/77751562?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.channel_param">参考</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/yuanyayuan/yymall/blob/master/mall_api/src/main/java/com/nexus/mall/api/controller/ShopcatController.java">源代码(登录状态购物车修改)</a>，<a target="_blank" rel="noopener" href="https://github.com/yuanyayuan/yymall/blob/master/mall_api/src/main/java/com/nexus/mall/api/controller/PassportController.java">源代码(用户登录后购物车同步)</a></p>
<p>未实现购物车数量修改，未登录时由前端修改cookie</p>
<h2 id="redis结合cookie实现购物车"><a href="#redis结合cookie实现购物车" class="headerlink" title="redis结合cookie实现购物车"></a>redis结合cookie实现购物车</h2><h3 id="未登录状态下购物车功能实现"><a href="#未登录状态下购物车功能实现" class="headerlink" title="未登录状态下购物车功能实现"></a>未登录状态下购物车功能实现</h3><blockquote>
<p> 把购物车信息写入cookie。</p>
</blockquote>
<ul>
<li>优点：<br>1、不占用服务端存储空间<br>2、用户体验好。<br>3、代码实现简单。</li>
<li>缺点：<br>1、cookie中保存的容量有限。最大4k<br>2、把购物车信息保存在cookie中，更换设备购物车信息不能同步。</li>
</ul>
<h4 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h4><ol>
<li><p>完全由前端实现，操作cookie存储购物车信息修改</p>
</li>
<li><p>后端提供接口，实现cookie的信息修改</p>
<ul>
<li>购物车新增商品分析：</li>
</ul>
<ol>
<li>从cookie中获取购物车列表</li>
<li>遍历购物车列表，判断需要添加的商品在购物车列表是否存在</li>
<li>商品存在的话，那么取出该商品原来的数量+添加的数量作为该商品现在的数量</li>
<li>如果商品不存在，那么调用服务，根据传来的商品id查询商品数量，设置商品的数量为页面传来的数量，取商品的第一张图片(购物车列表只展示一张图片)。</li>
<li>把修改后的购物车列表重新存入到cookie中</li>
</ol>
<ul>
<li>购物车删除商品分析</li>
</ul>
<ol>
<li>从cookie中获取购物车列表</li>
<li>遍历，查找到要删除的商品</li>
<li>将该商品从购物车列表移除</li>
<li>更新后的购物车列表重新写入cookie</li>
</ol>
<ul>
<li>购物车列表页面修改商品数量(点击“+”或者“-”)</li>
</ul>
<ol>
<li>从cookie中获取购物车列表</li>
<li>取所选择的需要更新的商品</li>
<li>更新商品数量</li>
<li>物车信息写入cookie</li>
</ol>
</li>
</ol>
<h3 id="登录状态下购物车功能的实现"><a href="#登录状态下购物车功能的实现" class="headerlink" title="登录状态下购物车功能的实现"></a>登录状态下购物车功能的实现</h3><blockquote>
<p>未登录状态下，把购物车数据保存到cookie中。登录状态下，需要把购物车数据保存到服务端。需要永久保存，可以保存到数据库中也可以把购物车数据保存到redis中，但数据库和redis同时保存购物车信息时需考虑数据一致性问题</p>
</blockquote>
<h4 id="redis使用的数据类型"><a href="#redis使用的数据类型" class="headerlink" title="redis使用的数据类型"></a>redis使用的数据类型</h4><ol>
<li> 使用hash数据类型</li>
<li>Hash的key应该是用户id。Hash中的field是商品id，value可以是把商品数量</li>
</ol>
<h4 id="实现方式：-1"><a href="#实现方式：-1" class="headerlink" title="实现方式："></a>实现方式：</h4><p>把购物车数据保存到redis(<em>数据类型是hash  key:用户id   field:商品id  value:商品数量</em>)</p>
<ul>
<li>购物车新增商品分析</li>
</ul>
<ol>
<li>判断商品是否存在    </li>
<li>如果存在,把 value中的json转换成购物车对象，增加数量，写回redis</li>
<li>如果不存在，根据商品id取商品信息，设置购物车数量，添加到购物车列表</li>
</ol>
<ul>
<li><p>修改购物车商品数量</p>
<ol>
<li>根据用户id，商品id从redis中取出对应的商品</li>
<li> 设置商品的数量</li>
<li> 该商品更新到redis中</li>
</ol>
</li>
<li><p>删除购物车商品</p>
<ol>
<li>获取redis中购物车</li>
<li>如果redis中已经有购物车了，判断购物车中是否存在已有商品，如果有的话则删除</li>
</ol>
</li>
<li><p>用户登录，购物车同步</p>
<ol>
<li>redis中无数据，<pre><code>     - 如果cookie中的购物车为空，那么这个时候不做任何处理
         - 如果cookie中的购物车不为空，此时直接放入redis中
</code></pre>
</li>
<li>redis中有数据，<ul>
<li>如果cookie中的购物车为空，那么直接把redis的购物车覆盖本地cookie</li>
<li>如果cookie中的购物车不为空，如果cookie中的某个商品在redis中存在，则进行合并</li>
</ul>
</li>
<li>同步到redis中去了以后，覆盖本地cookie购物车的数据，保证本地购物车的数据是同步最新的</li>
</ol>
</li>
</ul>
<h2 id="缓存用户权限，不用每次登陆都去数据库查询"><a href="#缓存用户权限，不用每次登陆都去数据库查询" class="headerlink" title="缓存用户权限，不用每次登陆都去数据库查询"></a>缓存用户权限，不用每次登陆都去数据库查询</h2><p><a target="_blank" rel="noopener" href="http://www.macrozheng.com/#/technology/redis_permission">参考</a></p>
<h3 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h3><p>用户登录请求会经过<code>JwtAuthenticationTokenFilter </code>验证token，其中有一步会从数据库中查询登录用户信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String authHeader = request.getHeader(<span class="keyword">this</span>.tokenHeader);</span><br><span class="line">    <span class="keyword">if</span> (authHeader != <span class="keyword">null</span> &amp;&amp; authHeader.startsWith(<span class="keyword">this</span>.tokenHead)) &#123;</span><br><span class="line">        <span class="comment">// The part after &quot;Bearer &quot;</span></span><br><span class="line">        String authToken = authHeader.substring(<span class="keyword">this</span>.tokenHead.length());</span><br><span class="line">        String username = jwtTokenUtil.getUserNameFromToken(authToken);</span><br><span class="line">        log.info(<span class="string">&quot;checking username:&#123;&#125;&quot;</span>, username);</span><br><span class="line">        <span class="keyword">if</span> (username != <span class="keyword">null</span> &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//此处会从数据库中获取登录用户信息</span></span><br><span class="line">            UserDetails userDetails = <span class="keyword">this</span>.userDetailsService.loadUserByUsername(username);</span><br><span class="line">            <span class="keyword">if</span> (jwtTokenUtil.validateToken(authToken, userDetails)) &#123;</span><br><span class="line">                UsernamePasswordAuthenticationToken authentication = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(userDetails, <span class="keyword">null</span>, userDetails.getAuthorities());</span><br><span class="line">                authentication.setDetails(<span class="keyword">new</span> WebAuthenticationDetailsSource().buildDetails(request));</span><br><span class="line">                log.info(<span class="string">&quot;authenticated user:&#123;&#125;&quot;</span>, username);</span><br><span class="line">                SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问任何接口，都会从数据库中查询用户信息和用户所拥有的资源信息，每次访问接口都触发这种操作，有的时候会带来一定的性能问题。</p>
<h3 id="使用redis作为缓存"><a href="#使用redis作为缓存" class="headerlink" title="使用redis作为缓存"></a>使用redis作为缓存</h3><blockquote>
<p>主要是获取用户信息和获取用户的资源信息这两个操作。当查询数据时，先去Redis缓存中查询，如果Redis中没有，再从数据库查询，查询到以后在把数据存储到Redis中去。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UmsAdminService实现类</span></span><br><span class="line"><span class="comment"> * Created by macro on 2018/4/26.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UmsAdminServiceImpl</span> <span class="keyword">implements</span> <span class="title">UmsAdminService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//专门用来操作Redis缓存的业务类</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UmsAdminCacheService adminCacheService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        BackendAdmin admin = getAdminByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (admin != <span class="keyword">null</span>) &#123;</span><br><span class="line">            List&lt;BackendResource&gt; resourceList = getResourceList(admin.getId());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AdminUserDetails(admin, resourceList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span>  <span class="keyword">new</span> UsernameNotFoundException(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UmsAdmin <span class="title">getAdminByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先从缓存中获取数据</span></span><br><span class="line">        BackendAdmin admin = adminCacheService.getAdmin(username);</span><br><span class="line">        <span class="keyword">if</span>(admin!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>  admin;</span><br><span class="line">        &#125;</span><br><span class="line">        Example example = <span class="keyword">new</span> Example(BackendAdmin.class);</span><br><span class="line">        Example.Criteria criteria = example.createCriteria();</span><br><span class="line">        criteria.andEqualTo(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line">        List&lt;BackendAdmin&gt; adminList = adminMapper.selectByExample(example);</span><br><span class="line">        <span class="keyword">if</span> (adminList != <span class="keyword">null</span> &amp;&amp; adminList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            admin = adminList.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//将数据库中的数据存入缓存中</span></span><br><span class="line">            adminCacheService.setAdmin(admin);</span><br><span class="line">            <span class="keyword">return</span> admin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;UmsResource&gt; <span class="title">getResourceList</span><span class="params">(Long adminId)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先从缓存中获取数据</span></span><br><span class="line">        List&lt;BackendResource&gt; resourceList = adminCacheService.getResourceList(adminId);</span><br><span class="line">        <span class="keyword">if</span>(CollUtil.isNotEmpty(resourceList))&#123;</span><br><span class="line">            <span class="keyword">return</span>  resourceList;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//缓存中没有从数据库中获取</span></span><br><span class="line">        resourceList = adminRoleRelationMapperCustom.getResourceList(adminId);</span><br><span class="line">        <span class="keyword">if</span>(CollUtil.isNotEmpty(resourceList))&#123;</span><br><span class="line">            <span class="comment">//将数据库中的数据存入缓存中</span></span><br><span class="line">            adminCacheService.setResourceList(adminId,resourceList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resourceList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/yuanyayuan/yymall/blob/master/mall_backend_service/src/main/java/com/nexus/mall/service/backend/BackendAdminCacheService.java">后台用户缓存操作类</a></p>
<h3 id="使用AOP处理缓存操作异常"><a href="#使用AOP处理缓存操作异常" class="headerlink" title="使用AOP处理缓存操作异常"></a>使用AOP处理缓存操作异常</h3><blockquote>
<p>为什么要用AOP来解决这个问题呢？因为我们的缓存业务类<code>UmsAdminCacheService</code>已经写好了，要保证缓存业务类中的方法执行不影响正常的业务逻辑，就需要在所有方法中添加<code>try catch</code>逻辑。使用AOP，我们可以在一个地方写上<code>try catch</code>逻辑，然后应用到所有方法上去</p>
</blockquote>
<ol>
<li><p>定义切面，在相关缓存业务类上面应用，在它的环绕通知中直接处理掉异常，保障后续操作能执行</p>
<blockquote>
<p>不过并不是所有的方法都需要处理异常的，比如我们的验证码存储，如果我们的Redis宕机了，我们的验证码存储接口需要的是报错，而不是返回执行成功。</p>
<p>对于上面这种需求我们可以通过自定义注解来完成，首先我们自定义一个<code>CacheException</code>注解，如果方法上面有这个注解，发生异常则直接抛出。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义注解，有该注解的缓存方法会抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CacheException &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(2)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * com.nexus.mall.service.backend.*CacheService.*(..)) || execution(public * com.nexus.mall.service.*CacheService.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Around(&quot;cacheAspect()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) signature;</span><br><span class="line">        Method method = methodSignature.getMethod();</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="comment">//有CacheException注解的方法需要抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(CacheException.class)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> throwable;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.error(throwable.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>接下来我们需要把<code>@CacheException</code>注解应用到存储和获取验证码的方法上去，这里需要注意的是要<strong>应用在实现类上而不是接口上，因为<code>isAnnotationPresent</code>方法只能获取到当前方法上的注解，而不能获取到它实现接口方法上的注解。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UmsMemberCacheService实现类</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/3/14.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UmsMemberCacheServiceImpl</span> <span class="keyword">implements</span> <span class="title">UmsMemberCacheService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheException</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthCode</span><span class="params">(String telephone, String authCode)</span> </span>&#123;</span><br><span class="line">        String key = REDIS_DATABASE + <span class="string">&quot;:&quot;</span> + REDIS_KEY_AUTH_CODE + <span class="string">&quot;:&quot;</span> + telephone;</span><br><span class="line">        redisService.set(key,authCode,REDIS_EXPIRE_AUTH_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheException</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAuthCode</span><span class="params">(String telephone)</span> </span>&#123;</span><br><span class="line">        String key = REDIS_DATABASE + <span class="string">&quot;:&quot;</span> + REDIS_KEY_AUTH_CODE + <span class="string">&quot;:&quot;</span> + telephone;</span><br><span class="line">        <span class="keyword">return</span> (String) redisService.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="缓存一些热点数据"><a href="#缓存一些热点数据" class="headerlink" title="缓存一些热点数据"></a>缓存一些热点数据</h2><blockquote>
<p>缓存一些不常修改但是经常被访问的数据</p>
</blockquote>
<p>缓存商品分类，并防止缓存穿透</p>
<ul>
<li>显示一级分类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 首页分类展示需求：</span></span><br><span class="line"><span class="comment">     * 1. 第一次刷新主页查询大分类，渲染展示到首页</span></span><br><span class="line"><span class="comment">     * 2. 如果鼠标上移到大分类，则加载其子分类的内容，如果已经存在子分类，则不需要加载（懒加载）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;获取商品分类(一级分类)&quot;, notes = &quot;获取商品分类(一级分类)&quot;, httpMethod = &quot;GET&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/cats&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerResponse <span class="title">cats</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//引入redis缓存</span></span><br><span class="line">    List&lt;Category&gt; list;</span><br><span class="line">    String catStr = redisOperator.get(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(catStr))&#123;</span><br><span class="line">        list = categoryService.queryAllRootLevelCat();</span><br><span class="line">        redisOperator.set(<span class="string">&quot;cat&quot;</span>, JsonUtils.objectToJson(list));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        list = JsonUtils.jsonToList(catStr, Category.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ServerResponse.success(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据一级分类id查询下一层子分类信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;根据一级分类id查询下一层子分类信息&quot;, notes = &quot;根据一级分类id查询下一层子分类信息&quot;, httpMethod = &quot;GET&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/subCat/&#123;rootCatId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerResponse <span class="title">subCat</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@ApiParam(name = &quot;rootCatId&quot;, value = &quot;一级分类id&quot;, required = true)</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@PathVariable</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NotNull(message = &quot;分类不存在&quot;)</span></span></span></span><br><span class="line"><span class="function"><span class="params">    Integer rootCatId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;CategoryVO&gt; list;</span><br><span class="line">    String subCatStr = redisOperator.get(<span class="string">&quot;subCat:&quot;</span> + rootCatId);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(subCatStr))&#123;</span><br><span class="line">        list = categoryService.getSubCatList(rootCatId);</span><br><span class="line">        <span class="comment">/* Redis 防止缓存穿透</span></span><br><span class="line"><span class="comment">              查询的key在redis中不存在，</span></span><br><span class="line"><span class="comment">              对应的id在数据库也不存在，</span></span><br><span class="line"><span class="comment">              此时被非法用户进行攻击，大量的请求会直接打在db上，</span></span><br><span class="line"><span class="comment">              造成宕机，从而影响整个系统，</span></span><br><span class="line"><span class="comment">              这种现象称之为缓存穿透。</span></span><br><span class="line"><span class="comment">              解决方案：把空的数据也缓存起来，比如空字符串，空对象，空数组或list</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            redisOperator.set(<span class="string">&quot;subCat:&quot;</span> + rootCatId, JsonUtils.objectToJson(list));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redisOperator.set(<span class="string">&quot;subCat:&quot;</span> + rootCatId, JsonUtils.objectToJson(list), <span class="number">5</span>*<span class="number">60</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        list = JsonUtils.jsonToList(subCatStr, CategoryVO.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ServerResponse.success(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/%E4%B8%AD%E9%97%B4%E4%BB%B6-redis%E6%8C%87%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/%E4%B8%AD%E9%97%B4%E4%BB%B6-redis%E6%8C%87%E4%BB%A4/" itemprop="url">中间件-redis指令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T16:32:25+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E6%8C%87%E4%BB%A4/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis指令</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="redis指令"><a href="#redis指令" class="headerlink" title="redis指令"></a>redis指令</h1><ul>
<li>keys *：查看所有的key (不建议在生产上使用，有性能影响)</li>
<li>type key：key的类型</li>
<li>select index：切换数据库，总共默认16个</li>
<li>flushdb：删除当前下边db中的数据</li>
<li>flushall：删除所有db中的数据</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>string: 最简单的字符串类型键值对缓存，也是最基本的</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>get/set/del：查询/设置/删除</p>
</li>
<li><p>set rekey data：设置已经存在的key，会覆盖</p>
</li>
<li><p>setnx rekey data：设置已经存在的key，不会覆盖</p>
</li>
<li><p>set key value ex time：设置带过期时间的数据</p>
</li>
<li><p>expire key：设置过期时间</p>
</li>
<li><p>ttl：查看剩余时间，-1永不过期，-2过期</p>
</li>
<li><p>append key：合并字符串</p>
</li>
<li><p>strlen key：字符串长度</p>
</li>
<li><p>incr key：累加1</p>
</li>
<li><p>decr key：类减1</p>
</li>
<li><p>incrby key num：累加给定数值</p>
</li>
<li><p>decrby key num：累减给定数值</p>
</li>
<li><p>getrange key start end：截取数据，end=-1 代表到最后</p>
</li>
<li><p>setrange key start newdata：从start位置开始替换数据</p>
</li>
<li><p>mset：连续设值</p>
</li>
<li><p>mget：连续取值</p>
</li>
<li><p>msetnx：连续设置，如果存在则不设置</p>
</li>
</ul>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><h3 id="hash-1"><a href="#hash-1" class="headerlink" title="hash"></a>hash</h3><p>hash：类似map，存储结构化数据结构，比如存储一个对象（不能有嵌套对象）</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><ul>
<li>hset key property value：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt; hset user name imooc</span><br><span class="line">-&gt; 创建一个user对象，这个对象中包含name属性，name值为imooc</span><br></pre></td></tr></table></figure></li>
<li>hget user name：获得用户对象中name的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hmset：设置对象中的多个键值对</span><br><span class="line"> -&gt; hset user age 18 phone 139123123</span><br><span class="line"> hmsetnx：设置对象中的多个键值对，存在则不添加</span><br><span class="line"> -&gt; hset user age 18 phone 139123123</span><br></pre></td></tr></table></figure></li>
<li>hmget：获得对象中的多个属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt; hmget user age phone</span><br></pre></td></tr></table></figure></li>
<li>hgetall user：获得整个对象的内容</li>
<li>hincrby user age 2：累加属性</li>
<li>hincrbyfloat user age 2.2：累加属性</li>
<li>hlen user：有多少个属性</li>
<li>hexists user age：判断属性是否存在</li>
<li>hkeys user：获得所有属性</li>
<li>hvals user：获得所有值</li>
<li>hdel user：删除对象</li>
</ul>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h3 id="list-1"><a href="#list-1" class="headerlink" title="list"></a>list</h3><p>list：列表，[a, b, c, d, …]</p>
<h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><ul>
<li>lpush userList 1 2 3 4 5：构建一个list，从左边开始存入数据</li>
<li>rpush userList 1 2 3 4 5：构建一个list，从右边开始存入数据</li>
<li>lrange list start end：获得数据</li>
<li>lpop：从左侧开始拿出一个数据</li>
<li>rpop：从右侧开始拿出一个数据</li>
<li>llen list：list长度</li>
<li>lindex list index：获取list下标的值</li>
<li>lset list index value：把某个下标的值替换</li>
<li>linsert list before/after value：插入一个新的值</li>
<li>lrem list num value：删除几个相同数据</li>
<li>ltrim list start end：截取值，替换原来的list</li>
</ul>
<h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><h3 id="sorted-set："><a href="#sorted-set：" class="headerlink" title="sorted set："></a>sorted set：</h3><p>sorted set：排序的set，可以去重可以排序，比如可以根据用户积分做排名，积分作为set的一个数值，根据数值可以做排序。set中的每一个memeber都带有一个分数</p>
<h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>zadd zset 10 value1 20 value2 30 value3：设置member和对应的分数</p>
</li>
<li><p>zrange zset 0 -1：查看所有zset中的内容</p>
</li>
<li><p>zrange zset 0 -1 withscores：带有分数</p>
</li>
<li><p>zrank zset value：获得对应的下标</p>
</li>
<li><p>zscore zset value：获得对应的分数</p>
</li>
<li><p>zcard zset：统计个数</p>
</li>
<li><p>zcount zset 分数1 分数2：统计个数</p>
</li>
<li><p>zrangebyscore zset 分数1 分数2：查询分数之间的member(包含分数1 分数2)</p>
</li>
<li><p>zrangebyscore zset (分数1 (分数2：查询分数之间的member（不包含分数1 和 分数2）</p>
</li>
<li><p>zrangebyscore zset 分数1 分数2 limit start end：查询分数之间的member(包含分数1 分数2)，获得的结果集再次根据下标区间做查询</p>
</li>
<li><p>zrem zset value：删除member</p>
</li>
</ul>
<h2 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h2><h3 id="EXPIRE-PEXPIRE"><a href="#EXPIRE-PEXPIRE" class="headerlink" title="EXPIRE/PEXPIRE"></a>EXPIRE/PEXPIRE</h3><ul>
<li><strong>EXPIRE</strong> </li>
</ul>
<p>接口定义：EXPIRE key “seconds”</p>
<p>接口描述：设置一个key在当前时间”seconds”(秒)之后过期。返回1代表设置成功，返回0代表key不存在或者无法设置过期时间。</p>
<ul>
<li><strong>PEXPIRE</strong></li>
</ul>
<p>接口定义：PEXPIRE key “milliseconds”<br>接口描述：设置一个key在当前时间”milliseconds”(毫秒)之后过期。返回1代表设置成功，返回0代表key不存在或者无法设置过期时间。</p>
<h3 id="EXPIREAT-PEXPIREAT"><a href="#EXPIREAT-PEXPIREAT" class="headerlink" title="EXPIREAT/PEXPIREAT"></a>EXPIREAT/PEXPIREAT</h3><ul>
<li><strong>EXPIREAT</strong> </li>
</ul>
<p>接口定义：EXPIREAT key “timestamp”</p>
<p>接口描述：设置一个key在”timestamp”(时间戳(秒))之后过期。返回1代表设置成功，返回0代表key不存在或者无法设置过期时间</p>
<ul>
<li><strong>PEXPIREAT</strong> </li>
</ul>
<p>接口定义：PEXPIREAT key “milliseconds-timestamp”</p>
<p>接口描述：设置一个key在”milliseconds-timestamp”(时间戳(毫秒))之后过期。返回1代表设置成功，返回0代表key不存在或者无法设置过期时间</p>
<h3 id="TTL-PTTL"><a href="#TTL-PTTL" class="headerlink" title="TTL/PTTL"></a>TTL/PTTL</h3><ul>
<li><strong>TTL</strong> </li>
</ul>
<p>接口定义：TTL key<br>接口描述：获取key的过期时间。如果key存在过期时间，返回剩余生存时间(秒)；如果key是永久的，返回-1；如果key不存在或者已过期，返回-2。</p>
<ul>
<li><strong>PTTL</strong> </li>
</ul>
<p>接口定义：PTTL key<br>接口描述：获取key的过期时间。如果key存在过期时间，返回剩余生存时间(毫秒)；如果key是永久的，返回-1；如果key不存在或者已过期，返回-2。</p>
<h3 id="PERSIST"><a href="#PERSIST" class="headerlink" title="PERSIST"></a>PERSIST</h3><p>接口定义：PERSIST key<br>接口描述：移除key的过期时间，将其转换为永久状态。如果返回1，代表转换成功。如果返回0，代表key不存在或者之前就已经是永久状态。</p>
<h3 id="SETEX"><a href="#SETEX" class="headerlink" title="SETEX"></a>SETEX</h3><p>接口定义：SETEX key “seconds” “value”<br>接口描述：SETEX在逻辑上等价于SET和EXPIRE合并的操作，区别之处在于SETEX是一条命令，而命令的执行是原子性的，所以不会出现并发问题。</p>
<h2 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h2><h3 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h3><h3 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/%E4%B8%AD%E9%97%B4%E4%BB%B6-redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/%E4%B8%AD%E9%97%B4%E4%BB%B6-redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/" itemprop="url">中间件-redis内存淘汰机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T12:46:31+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis内存淘汰机制</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis设置过期时间"><a href="#Redis设置过期时间" class="headerlink" title="Redis设置过期时间"></a>Redis设置过期时间</h1><ul>
<li>expire key time(以秒为单位)–这是最常用的方式</li>
<li>setex(String key, int seconds, String value)–字符串独有的方式</li>
</ul>
<p>注意：</p>
<ul>
<li>除了字符串自己独有设置过期时间的方法外，其他方法都需要依靠expire方法来设置时间</li>
<li>如果没有设置时间，那缓存就是永不过期</li>
<li>如果设置了过期时间，之后又想让缓存永不过期，使用persist key</li>
</ul>
<h1 id="Redis-给缓存数据设置过期时间有啥用？"><a href="#Redis-给缓存数据设置过期时间有啥用？" class="headerlink" title="Redis 给缓存数据设置过期时间有啥用？"></a>Redis 给缓存数据设置过期时间有啥用？</h1><p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？</p>
<p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接Out of memory。</p>
<p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong></p>
<p>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在1分钟内有效，用户登录的 token 可能只在 1 天内有效。</p>
<p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p>
<h1 id="Redis是如何判断数据是否过期的呢？"><a href="#Redis是如何判断数据是否过期的呢？" class="headerlink" title="Redis是如何判断数据是否过期的呢？"></a>Redis是如何判断数据是否过期的呢？</h1><p>Redis  通过一个叫做过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个key(键)，过期字典的值是一个long long类型的整数，这个整数保存了key所指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。 </p>
<h1 id="Redis-过期键的删除策略"><a href="#Redis-过期键的删除策略" class="headerlink" title="Redis 过期键的删除策略"></a>Redis 过期键的删除策略</h1><p>A、<strong>定期删除策略</strong>。用一个<strong>定时器</strong>来负责检查 key，过期则删除 key，注意这里并不是检查所有的 key 而是<strong>随机抽取进行检查</strong>。定期策略虽然让内存及时释放，但也会<strong>额外消耗 CPU 资源</strong>，通常 CPU 应该将时间尽量用于处理业务请求，而不是删除 key。</p>
<p>B、<strong>惰性删除策略</strong>。在你<strong>获取</strong>某个 key 的时候，redis 会检查一下，这个 key <strong>如果设置了过期时间那么是否过期了</strong>，如果<strong>过期</strong>则删除该 key。</p>
<hr>
<h1 id="Redis-的回收策略（淘汰策略）"><a href="#Redis-的回收策略（淘汰策略）" class="headerlink" title="Redis 的回收策略（淘汰策略）"></a>Redis 的回收策略（淘汰策略）</h1><h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2><p>如果<strong>定期删除没删除 key</strong>，然后也<strong>没及时去请求 key</strong>，即<strong>惰性删除也没生效</strong>，持续下去 redis 的内存会越来越高，当超过 redis 设置的内存最大使用量时，就会进行内存数据淘汰。redis 有 6 种淘汰策略：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>volatile-lru</td>
<td>从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td>volatile-ttl</td>
<td>从已设置过期时间的数据集中挑选将要过期的数据淘汰</td>
</tr>
<tr>
<td>volatile-random</td>
<td>从已设置过期时间的数据集中任意选择数据淘汰</td>
</tr>
<tr>
<td>allkeys-lru</td>
<td>从所有数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td>allkeys-random</td>
<td>从所有数据集中任意选择数据进行淘汰</td>
</tr>
<tr>
<td>noeviction</td>
<td>当内存不足以容纳新写入数据时，新写入操作会报错。很少使用</td>
</tr>
</tbody></table>
<blockquote>
<p>注意这里的 6 种机制，前缀 volatile 和 allkeys 用于区分淘汰数据的数据集是从已设置过期时间的数据集还是从全部数据集中选取，后面的 lru、ttl 以及 random 是三种不同的淘汰策略，再加上一种 no-enviction 永不回收的策略。其中最常使用的是 volatile-lru/allkeys-lru。</p>
</blockquote>
<ul>
<li>allkeys-lru：如果期望用户请求呈现幂律分布(power-law distribution)，也就是，期望一部分子集元素被访问得远比其他元素多时，可以使用allkeys-lru策略。在你不确定时这是一个好的选择</li>
<li>allkeys-random：如果期望是循环周期的访问，所有的键被连续扫描，或者期望请求符合平均分布(每个元素以相同的概率被访问)，可以使用allkeys-random策略。</li>
<li>volatile-ttl：如果你期望能让 Redis 通过使用你创建缓存对象的时候设置的TTL值，确定哪些对象应该是较好的清除候选项，可以使用volatile-ttl策略。</li>
</ul>
<p>另外值得注意的是，为键设置过期时间需要消耗内存，所以使用像allkeys-lru这样的策略会更高效，因为在内存压力下没有必要为键的回收设置过期时间。</p>
<h2 id="常用缓存数据淘汰策略"><a href="#常用缓存数据淘汰策略" class="headerlink" title="常用缓存数据淘汰策略"></a>常用缓存数据淘汰策略</h2><ul>
<li>FIFO（First In First Out）： 先进先出算法，即先放入缓存的先被移除。</li>
<li>LRU（Least Recently Used）： 最近最少使用算法，使用时间距离现在最久的那个被移除。</li>
<li>LFU（Least Frequently Used）： 最不常用算法，一定时间段内使用次数（频率）最少的那个被移除。</li>
</ul>
<h1 id="Redis采用的过期策略"><a href="#Redis采用的过期策略" class="headerlink" title="Redis采用的过期策略"></a>Redis采用的过期策略</h1><p>惰性删除+定期删除</p>
<ul>
<li>惰性删除流程<ul>
<li>在进行get或setnx等操作时，先检查key是否过期，</li>
<li>若过期，删除key，然后执行相应操作；</li>
<li>若没过期，直接执行相应操作</li>
</ul>
</li>
<li>定期删除流程（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）<ul>
<li>遍历每个数据库（就是redis.conf中配置的”database”数量，默认为16）<ul>
<li>检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）<ul>
<li>如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历</li>
<li>随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key</li>
<li>判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/">&lt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/9/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <!--<a href="/archives/%7C%7Carchive">-->
                <a href="/archives/">
              
                  <span class="site-state-item-count">100</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">68</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">57</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuanyayuan" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:liyuan0707@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LiYuan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
