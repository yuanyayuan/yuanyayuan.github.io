<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="工作中技术总结">
<meta property="og:type" content="website">
<meta property="og:title" content="Hikari的Java之路">
<meta property="og:url" content="https://yuanyayuan.github.io/index.html">
<meta property="og:site_name" content="Hikari的Java之路">
<meta property="og:description" content="工作中技术总结">
<meta property="og:locale">
<meta property="article:author" content="LiYuan">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yuanyayuan.github.io/"/>





  <title>Hikari的Java之路</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hikari的Java之路</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Hello,world</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/09/SpringMVC%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/09/SpringMVC%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/" itemprop="url">SpringMVC数据绑定</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-09T00:10:17+08:00">
                2021-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6-SpringMVC%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">常用框架 - SpringMVC知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/139162484">SpringMVC参数绑定-细致总结（通俗易懂）</a></p>
<h1 id="基本类型、包装类型参数绑定"><a href="#基本类型、包装类型参数绑定" class="headerlink" title="基本类型、包装类型参数绑定"></a>基本类型、包装类型参数绑定</h1><h2 id="基本类型-int"><a href="#基本类型-int" class="headerlink" title="基本类型 int"></a>基本类型 int</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RequestMapping(<span class="string">&quot;baseType.do&quot;</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">baseType</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;age:&quot;</span> + age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;baseType.do?age&#x3D;30</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当我们请求时，返回结果：age:30</span><br></pre></td></tr></table></figure>

<ul>
<li>这种情况下，首先 <strong>key 值必须传入</strong>，否则会报 <strong>500 错误</strong>，提示当前 age 不能为空</li>
<li>其次，<strong>参数只能为 int 类型</strong>，否则报 <strong>400 参数异常错误</strong></li>
</ul>
<p><strong>是否可以使用<code>@RequestParam</code>的  required 属性，避免请求参数为空</strong></p>
<p>答案是不能，虽然这个注解设置 required = false 后不传值后台也不会报错，但是如果其中指定了基本数据类型。例如我们代码中的 int  这个时候如果不传值是依旧会报一个 500 错误因为其不传值就赋 null，但是 int 类型却不能为null，所以想要规避这个参数为空的问题，我们就可以选择包装类型 Integer</p>
<h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;packingType.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">packingType</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;age:&quot;</span> + age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;packingType.do?age&#x3D;30</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正常返回：age:30</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;packingType.do</span><br><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;packingType.do?</span><br><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;packingType.do?&#x3D;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数为空不报错，均返回：age:null</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>可以不传 key</strong>，后台接收到的数据则为 age=null</li>
<li>所以开发中，<strong>对于参数可能为空的数据，建议使用包装类型</strong></li>
<li>当然，我们也可以使用 @RequestParam 注解 来设置是否请求中必须包含该参数，此注解默认就是必须传参，否则报错</li>
</ul>
<h1 id="对象的参数绑定"><a href="#对象的参数绑定" class="headerlink" title="对象的参数绑定"></a>对象的参数绑定</h1><h2 id="多层级对象的绑定"><a href="#多层级对象的绑定" class="headerlink" title="多层级对象的绑定"></a>多层级对象的绑定</h2><ul>
<li>创建用户类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    ......补充其 get set toString 方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>直接在参数中写上对应 User 类型就可以了</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;objectType.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">objectType</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;objectType.do?id&#x3D;001&amp;name&#x3D;Steven</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回结果：User&#123;uid&#x3D;&#39;001&#39;, name&#x3D;&#39;Steven&#39;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个新的类 UserDetails</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    ......补充其 get set toString 方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 User 类中引入这个类，这种情况又该如何绑定参数呢</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> UserDetails userDetails;</span><br><span class="line">    </span><br><span class="line">    ......补充其 get set toString 方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;objectType.do?id&#x3D;1&amp;name&#x3D;Steven&amp;userDetails.age&#x3D;20&amp;userDetails.address&#x3D;BeiJing</span><br></pre></td></tr></table></figure>

<p>返回结果：User{uid=’1’, name=’Steven’, userDetails=UserDetails{age=20, address=’BeiJing’}}</p>
<ul>
<li>对于引入的对象成员复赋值，格式就例如：<code>userDetails.address=xxxxx</code></li>
<li>这里地址我没用中文，是因为我是直接返回的，没经过编码的处理，不然会显示</li>
</ul>
<h2 id="同属性对象参数绑定"><a href="#同属性对象参数绑定" class="headerlink" title="同属性对象参数绑定"></a>同属性对象参数绑定</h2><p>如果我们想要直接接收两个对象，有时候免不了有相同的成员，例如我们的 User 和 Student 类中均含有</p>
<p>Integer id 、String name 两个成员，我们试着请求一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;objectType2.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">objectType2</span><span class="params">(User user, Student student)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user.toString() + <span class="string">&quot; &quot;</span> + student.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;objectType2.do?id&#x3D;8&amp;name&#x3D;Steven</span><br></pre></td></tr></table></figure>

<p>返回结果：User{id=’8’, name=’Steven’} Student{id=’8’, name=’Steven’}</p>
<p>可以看到，两个对象的值都被赋上了，但是，大部分情况下，不同的对象的值一般都是不同的，为此，我们还有解决办法</p>
<p>@InitBinder 注解可以帮助我们分开绑定，下面的代码也就是说分别给 user、student 指定一个前缀</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InitBinder(&quot;user&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initUser</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line">    binder.setFieldDefaultPrefix(<span class="string">&quot;user.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@InitBinder(&quot;student&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initStudent</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line">    binder.setFieldDefaultPrefix(<span class="string">&quot;stu.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;objectType2.do?user.id&#x3D;1&amp;name&#x3D;Steven&amp;stu.id&#x3D;002</span><br></pre></td></tr></table></figure>

<p>当发起这样一个请求后，我们分别指定了 user 和 student 的 id 值，而 name 则是同样的 Steven</p>
<p>返回结果：User{id=’1’, name=’Steven’, userDetails=null} Student{id=’2’, name=’Steven’}</p>
<h1 id="数组类型参数绑定"><a href="#数组类型参数绑定" class="headerlink" title="数组类型参数绑定"></a>数组类型参数绑定</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;arrayType.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">arrayType</span><span class="params">(String[] nickname)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (String s : nickname) &#123;</span><br><span class="line">        sb.append(s).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;arrayType.do?nickname&#x3D;Jack&amp;nickname&#x3D;Steven&amp;nickname&#x3D;Tom</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回结果：Jack, Steven, Tom,</span><br></pre></td></tr></table></figure>

<h1 id="集合类型参数绑定"><a href="#集合类型参数绑定" class="headerlink" title="集合类型参数绑定"></a>集合类型参数绑定</h1><h2 id="List-类型"><a href="#List-类型" class="headerlink" title="List 类型"></a>List 类型</h2><p>集合是不能直接进行参数绑定的，所以我们需要创建出一个类，然后在类中进行对 List 的参数绑定</p>
<p>首先创建 UserList 类，其中我为了演示，只放了  <code>private List&lt;User&gt; users</code> 补充好 get set toString 方法</p>
<p>控制层方法中，参数就是这个创建出来的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;listType.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">listType</span><span class="params">(UserList userList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userList.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;listType.do?users[0].id&#x3D;1&amp;users[0].name&#x3D;Jack&amp;users[1].id&#x3D;2&amp;users[1].name&#x3D;Marry</span><br></pre></td></tr></table></figure>

<p>我们的请求，分别将两个user信息存入了 <code>List&lt;User&gt; users</code>中</p>
<p><strong>特别注意</strong>：如果你的 Tomcat 版本是 7.0 左右 那么上述请求是没问题的，但是如果版本比较高，例如我本身所用的 Tomcat 8.5 ，如果执行上述请求就会报 400 错误</p>
<blockquote>
<p><strong>HTTP Status 400 – Bad Request</strong><br><strong>Message</strong> Invalid character found in the request target. The valid characters are defined in RFC 7230 and RFC 3986</p>
</blockquote>
<p>这是因为Tomcat高的版本地址中不能使用“[”和“]” ，我们可以将其换成对应的16进制，即 “[” 换成 %5B，“]” 换成 %5D</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;listType.do?users%5B0%5D.id&#x3D;1&amp;users%5B0%5D.name&#x3D;Jack&amp;users%5B1%5D.id&#x3D;2&amp;users%5B1%5D.name&#x3D;Marry</span><br></pre></td></tr></table></figure>

<p>或者直接用 post 请求也是可以的</p>
<h2 id="Map-类型"><a href="#Map-类型" class="headerlink" title="Map 类型"></a>Map 类型</h2><p>map 类型是一样的套路，我们先创建一个 UserMap类，然后在其中声明 <code>private Map&lt;String,User&gt; users</code> 进而绑定参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;mapType.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">mapType</span><span class="params">(UserMap userMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userMap.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;mapType.do?users[&#39;userA&#39;].id&#x3D;1&amp;users[&#39;userA&#39;].name&#x3D;Jack&amp;users[&#39;userB&#39;].id&#x3D;2&amp;users[&#39;userB&#39;].name&#x3D;Tom</span><br></pre></td></tr></table></figure>

<p>同样 “[]” 会遇到上面的错误，所以如果想要在地址栏请求访问，就需要替换字符，或者发起一个 post 请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;mapType.do?users%5B%27userA%27%5D.id&#x3D;1&amp;users%5B%27userA%27%5D.name&#x3D;Jack&amp;users%5B%27userB%27%5D.id&#x3D;2&amp;users%5B%27userB%27%5D.name&#x3D;Tom</span><br></pre></td></tr></table></figure>

<p>返回结果：UserMap{users={userA=User{id=’1’, name=’Jack’}, userB=User{id=’2’, name=’Tom’}}}</p>
<h1 id="JSON-参数绑定"><a href="#JSON-参数绑定" class="headerlink" title="JSON 参数绑定"></a>JSON 参数绑定</h1><p>除了前面表单等提交的方式，我们还有一种ajax的提交方式，常常用来向后端传递以及接受 json 格式的数据，关于 json 字符串和对象之间的转换会用到下面的 jar包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>这一块的演示，我们创建一个 Admin 实体类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Admin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    ......补充其 get set toString 方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实体参数绑定"><a href="#实体参数绑定" class="headerlink" title="实体参数绑定"></a>实体参数绑定</h2><p>当 ajax 传递的参数很多的时候，使用参数名匹配，会非常麻烦，如果请求的参数在后台中有一个匹配的实体类，我们就可以选择前台传一个 json 到后台，后台使用匹配的实体类进行接收</p>
<p>提交 JSON： {“id”: “37”,”name”: “张三”}</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&quot;#btn&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//发送ajax请求</span></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url:<span class="string">&quot;ajaxType1.do&quot;</span>,</span><br><span class="line">            contentType:<span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">            data:<span class="string">&#x27;&#123;&quot;id&quot;:&quot;37&quot;,&quot;name&quot;:&quot;张三&quot;&#125;&#x27;</span>,</span><br><span class="line">            dataType:<span class="string">&quot;json&quot;</span>,</span><br><span class="line">            type:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">            success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//解析响应数据</span></span><br><span class="line">            alert(data.id);</span><br><span class="line">            alert(data.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>Contoller</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用实体接参数</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;ajaxType1.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Admin <span class="title">ajaxType1</span><span class="params">(<span class="meta">@RequestBody</span> Admin admin)</span> </span>&#123;</span><br><span class="line">    System.out.println(admin.toString());</span><br><span class="line">    admin.setName(<span class="string">&quot;测试管理员&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> admin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后端参数中的 admin 就会被绑定好参数，供开发者使用</p>
<p><code>@RequestBody</code> 注解常用来处理 <code>content-type</code>不是默认的<code>application/x-www-form-urlcoded</code>编码的内容，说常处理<code>application/json</code>类型</p>
<h2 id="Map-参数绑定"><a href="#Map-参数绑定" class="headerlink" title="Map 参数绑定"></a>Map 参数绑定</h2><p>还有一种情况，那就是请求的参数仍然挺多，但是后台也没有一个合适的实体进行匹配，我们也可以考虑使用map来接收</p>
<p>依旧提交 JSON： {“id”: “37”,”name”: “张三”}</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&quot;#btn&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//发送ajax请求</span></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url:<span class="string">&quot;ajaxType1.do&quot;</span>,</span><br><span class="line">            contentType:<span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">            data:<span class="string">&#x27;&#123;&quot;id&quot;:&quot;37&quot;,&quot;name&quot;:&quot;张三&quot;&#125;&#x27;</span>,</span><br><span class="line">            dataType:<span class="string">&quot;json&quot;</span>,</span><br><span class="line">            type:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">            success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//解析响应数据</span></span><br><span class="line">            alert(data.id);</span><br><span class="line">            alert(data.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>但是 Controller 中我们使用 map 来进行接收，然后简单给了一个实例，将map值封装到 Admin 对象中，然后返回到前端去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;ajaxType3.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Admin <span class="title">ajaxType3</span><span class="params">(<span class="meta">@RequestBody</span> Map&lt;String, String&gt; map)</span>  </span>&#123;</span><br><span class="line">    Integer id = <span class="keyword">null</span>;</span><br><span class="line">    String name = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(<span class="string">&quot;id&quot;</span>))&#123;</span><br><span class="line">        id = Integer.parseInt(map.get(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(<span class="string">&quot;name&quot;</span>))&#123;</span><br><span class="line">        name = map.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Admin admin = <span class="keyword">new</span> Admin();</span><br><span class="line">    admin.setId(id);</span><br><span class="line">    admin.setName(name);</span><br><span class="line">    <span class="keyword">return</span> admin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="List-参数绑定"><a href="#List-参数绑定" class="headerlink" title="List 参数绑定"></a>List 参数绑定</h2><p>同样的，我们还可以使用 list 方式进行接收，它时以 json 数组的形式传递的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> listType=[];</span><br><span class="line"><span class="keyword">var</span> admin=&#123;&#125;;</span><br><span class="line">admin.id=<span class="number">1</span>;</span><br><span class="line">admin.name=<span class="string">&#x27;汤姆&#x27;</span>;</span><br><span class="line">listType.push(admin);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> admin2=&#123;&#125;;</span><br><span class="line">admin2.id=<span class="number">2</span>;</span><br><span class="line">admin2.name=<span class="string">&#x27;杰克&#x27;</span>;</span><br><span class="line">listType.push(admin2);</span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&quot;#btn&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//发送ajax请求</span></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url:<span class="string">&quot;ajaxType1.do&quot;</span>,</span><br><span class="line">            contentType:<span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">            data:<span class="built_in">JSON</span>.stringify(listType),</span><br><span class="line">            dataType:<span class="string">&quot;json&quot;</span>,</span><br><span class="line">            type:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">            success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//解析响应数据</span></span><br><span class="line">            alert(data.id);</span><br><span class="line">            alert(data.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>去后台看一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;ajaxType5.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ajaxType5</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;Admin&gt; list)</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Admin admin : list)&#123;</span><br><span class="line">        System.out.println(admin.getId() + <span class="string">&quot; &quot;</span> + admin.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下控制台的输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Admin&#123;id=&#x27;1&#x27;, name=&#x27;汤姆&#x27;&#125;, Admin&#123;id=&#x27;2&#x27;, name=&#x27;杰克&#x27;&#125;]</span><br><span class="line">1 汤姆</span><br><span class="line">2 杰克</span><br></pre></td></tr></table></figure>

<h2 id="表单提交"><a href="#表单提交" class="headerlink" title="表单提交"></a>表单提交</h2><p>这是用来提交的表单</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;ajaxForm&quot;</span>  <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    id:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    name:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这是 ajax请求，我们也常用<code>$(&quot;#ajaxForm&quot;).serialize()</code> 进行一个表单的序列化，然后提交，但是它只是将Form序列化拼接成了简单的字符串，并不是JSON格式，它是例如这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=<span class="number">111</span>&amp;name=Steven</span><br></pre></td></tr></table></figure>

<p>所以刚才所说的json那一套就不管用了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&quot;#btn&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//发送ajax请求</span></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url:<span class="string">&quot;ajaxType1.do&quot;</span>,</span><br><span class="line">            contentType:<span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">            data:$(<span class="string">&quot;#ajaxForm&quot;</span>).serialize(),</span><br><span class="line">            dataType:<span class="string">&quot;json&quot;</span>,</span><br><span class="line">            type:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">            success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//解析响应数据</span></span><br><span class="line">            alert(data.id);</span><br><span class="line">            alert(data.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果想要使用序列化，同时还想要传递 json 格式到后台，也不是没办法</p>
<p>我们需要添加一个方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$.fn.serializeObject = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">this</span>.serializeArray();</span><br><span class="line">    $.each(a, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o[<span class="built_in">this</span>.name]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!o[<span class="built_in">this</span>.name].push) &#123;</span><br><span class="line">                o[<span class="built_in">this</span>.name] = [o[<span class="built_in">this</span>.name]];</span><br><span class="line">             &#125;</span><br><span class="line">            o[<span class="built_in">this</span>.name].push(<span class="built_in">this</span>.value || <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            o[<span class="built_in">this</span>.name] = <span class="built_in">this</span>.value || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同时将下面 ajax 中的 data修改为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:<span class="built_in">JSON</span>.stringify($(<span class="string">&quot;#ajaxForm&quot;</span>).serializeObject()),</span><br></pre></td></tr></table></figure>

<p>后台就能获取到 json 格式了</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;id&quot;</span>:<span class="string">&quot;111&quot;</span>,<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;Steven&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h1 id="XML-参数绑定"><a href="#XML-参数绑定" class="headerlink" title="XML 参数绑定"></a>XML 参数绑定</h1><p>后台非常简单，和前面没什么区别，我们需要在实体中进行一些操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;xmlType.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">xmlType</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> student.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下，我们需要借助一个jar包 —— spring-oxm，自己可以导入一下</p>
<p>然后我们需要在接受的实体那里，添加 @XmlRootElement 和 @XmlElement 注解，来代表根节点和子节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ideal.Object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.annotation.XmlElement;</span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.annotation.XmlRootElement;</span><br><span class="line"></span><br><span class="line"><span class="meta">@XmlRootElement(name = &quot;student&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XmlElement(name = &quot;id&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XmlElement(name = &quot;name&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&#x27;&quot;</span> + id + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如我们xml为</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span>&gt;</span>66<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>Steven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后发起请求，注意将Content-Type 改为 application/xml</p>
<p>返回的结果：Student{id=’66’, name=’Steven’}</p>
<h1 id="PropertyEditor、Formatter、Converter自定义格式化工具和类型转换器"><a href="#PropertyEditor、Formatter、Converter自定义格式化工具和类型转换器" class="headerlink" title="PropertyEditor、Formatter、Converter自定义格式化工具和类型转换器"></a>PropertyEditor、Formatter、Converter自定义格式化工具和类型转换器</h1><p>​     </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/08/Springboot%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/08/Springboot%E5%AD%A6%E4%B9%A0/" itemprop="url">Spring学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-08T23:45:08+08:00">
                2021-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6-Spring%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">常用框架 - Spring知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>参考：</strong><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93?id=_91-%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8jpa%e5%9c%a8%e6%95%b0%e6%8d%ae%e5%ba%93%e4%b8%ad%e9%9d%9e%e6%8c%81%e4%b9%85%e5%8c%96%e4%b8%80%e4%b8%aa%e5%ad%97%e6%ae%b5%ef%bc%9f">Spring 常见问题总结</a></p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="什么是-Spring-框架"><a href="#什么是-Spring-框架" class="headerlink" title="什么是 Spring 框架?"></a>什么是 Spring 框架?</h2><p>我们一般说 Spring 框架指的都是 Spring  Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context  组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。</p>
<p>Spring 官网列出的 Spring 的 6 个特征:</p>
<ul>
<li><strong>核心技术</strong> ：依赖注入(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。</li>
<li><strong>测试</strong> ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient。</li>
<li><strong>数据访问</strong> ：事务，DAO支持，JDBC，ORM，编组XML。</li>
<li><strong>Web支持</strong> : Spring MVC和Spring WebFlux Web框架。</li>
<li><strong>集成</strong> ：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。</li>
<li><strong>语言</strong> ：Kotlin，Groovy，动态语言。</li>
</ul>
<h2 id="列举一些重要的Spring模块？"><a href="#列举一些重要的Spring模块？" class="headerlink" title="列举一些重要的Spring模块？"></a>列举一些重要的Spring模块？</h2><p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/Springboot/Spring%E6%A8%A1%E5%9D%97.png" alt="Spring主要模块"></p>
<ul>
<li><strong>Spring Core：</strong> 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。</li>
<li><strong>Spring  Aspects</strong> ： 该模块为与AspectJ的集成提供支持。</li>
<li><strong>Spring AOP</strong> ：提供了面向切面的编程实现。</li>
<li><strong>Spring JDBC</strong> : Java数据库连接。</li>
<li><strong>Spring JMS</strong> ：Java消息服务。</li>
<li><strong>Spring ORM</strong> : 用于支持Hibernate等ORM工具。</li>
<li><strong>Spring Web</strong> : 为创建Web应用程序提供支持。</li>
<li><strong>Spring Test</strong> : 提供了对 JUnit 和 TestNG 测试的支持。</li>
</ul>
<h2 id="RestController-vs-Controller"><a href="#RestController-vs-Controller" class="headerlink" title="@RestController vs @Controller"></a>@RestController vs @Controller</h2><p><strong><code>Controller</code> 返回一个页面</strong></p>
<p>单独使用 <code>@Controller</code> 不加 <code>@ResponseBody</code>的话一般使用在要返回一个视图的情况，这种情况属于比较传统的Spring MVC 的应用，对应于前后端不分离的情况。</p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/Springboot/%40RestController%20vs%20%40Controller1.png" alt="SpringMVC 传统工作流程"></p>
<p><strong><code>@RestController</code> 返回JSON 或 XML 形式数据</strong></p>
<p>但<code>@RestController</code>只返回对象，对象数据直接以 JSON 或 XML 形式写入 HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是目前日常开发所接触的最常用的情况（前后端分离）。</p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/Springboot/%40RestController%20vs%20%40Controller2.png" alt="SpringMVC+RestController"></p>
<p><strong><code>@Controller +@ResponseBody</code> 返回JSON 或 XML 形式数据</strong></p>
<p>如果你需要在Spring4之前开发 RESTful Web服务的话，你需要使用<code>@Controller</code> 并结合<code>@ResponseBody</code>注解，也就是说<code>@Controller</code> +<code>@ResponseBody</code>= <code>@RestController</code>（Spring 4 之后新加的注解）。</p>
<blockquote>
<p><code>@ResponseBody</code> 注解的作用是将 <code>Controller</code> 的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到HTTP 响应(Response)对象的 body 中，通常用来返回 JSON 或者 XML 数据，返回 JSON 数据的情况比较多。</p>
</blockquote>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/Springboot/%40RestController%20vs%20%40Controller3.png" alt="Spring3.xMVC RESTfulWeb服务工作流程"></p>
<h2 id="Spring-IOC-amp-AOP"><a href="#Spring-IOC-amp-AOP" class="headerlink" title="Spring IOC &amp; AOP"></a>Spring IOC &amp; AOP</h2><h3 id="谈谈自己对于-Spring-IoC-和-AOP-的理解"><a href="#谈谈自己对于-Spring-IoC-和-AOP-的理解" class="headerlink" title="谈谈自己对于 Spring IoC 和 AOP 的理解"></a>谈谈自己对于 Spring IoC 和 AOP 的理解</h3><h4 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h4><p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong>  IoC 在其他语言中也有应用，并非 Spring 特有。 <strong>IoC 容器是 Spring 用来实现 IoC 的载体，  IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</strong></p>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。  <strong>IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong> </p>
<p>在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个  Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC  的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p>
<p><strong>Spring IoC的初始化过程：</strong> </p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/Springboot/Spring%20IoC%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="Spring IoC的初始化过程"></p>
<h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<p><strong>Spring AOP就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/Springboot/SpringAOP.png" alt="SpringAOPProcess"></p>
<p>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ  ，AspectJ  应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p>
<h5 id="Spring-中，优先使用哪种-AOP-呢"><a href="#Spring-中，优先使用哪种-AOP-呢" class="headerlink" title="Spring 中，优先使用哪种 AOP 呢"></a>Spring 中，优先使用哪种 AOP 呢</h5><p>（1）如果目标对象实现了接口，默认会采用 JDK 的动态代理，但也可以强制使用 CGLIB；</p>
<p>（2）如果目标对象没有实现了接口，则必须采用 CGLIB 库。</p>
<p>Spring 会自动在 JDK 动态代理和 CGLIB 之间转换。</p>
<h3 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h3><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p> Spring AOP 已经集成了 AspectJ  ，AspectJ  应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ  相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p>
<h3 id="说说-Spring-的-AOP-的原理是什么？实现-AOP-有哪些方式？"><a href="#说说-Spring-的-AOP-的原理是什么？实现-AOP-有哪些方式？" class="headerlink" title="说说 Spring 的 AOP 的原理是什么？实现 AOP 有哪些方式？"></a>说说 Spring 的 AOP 的原理是什么？实现 AOP 有哪些方式？</h3><p>Spring AOP 的底层使用的是<strong>动态代理</strong>，有两种实现方式：</p>
<p><strong>JDK 动态代理</strong>：利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用 InvokeHandler 来处理。</p>
<p><strong>CGlib 动态代理</strong>：以 CGLIB（Code Generation Library）的方式进行代理，它采用底层字节码技术，将代理对象类的 class 文件加载进来，通过修改其字节码生成子类来处理。</p>
<p><strong>区别:</strong></p>
<p>JDK 代理只能对实现接口的类生成代理；</p>
<p>CGLIB 是针对类实现代理，继承指定类并生成一个子类，因此不能代理 final 修饰的类。</p>
<h3 id="Spring-中，优先使用哪种-AOP-呢-1"><a href="#Spring-中，优先使用哪种-AOP-呢-1" class="headerlink" title="Spring 中，优先使用哪种 AOP 呢"></a>Spring 中，优先使用哪种 AOP 呢</h3><p>（1）如果目标对象实现了接口，默认会采用 JDK 的动态代理，但也可以强制使用 CGLIB；</p>
<p>（2）如果目标对象没有实现了接口，则必须采用 CGLIB 库。</p>
<p>Spring 会自动在 JDK 动态代理和 CGLIB 之间转换。</p>
<h2 id="Spring-bean"><a href="#Spring-bean" class="headerlink" title="Spring bean"></a>Spring bean</h2><h3 id="Spring-中的-bean-的作用域有哪些"><a href="#Spring-中的-bean-的作用域有哪些" class="headerlink" title="Spring 中的 bean 的作用域有哪些?"></a>Spring 中的 bean 的作用域有哪些?</h3><ul>
<li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>global-session：  全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet  都有不同的会话</li>
</ul>
<h3 id="Spring-中的单例-bean-的线程安全问题了解吗？"><a href="#Spring-中的单例-bean-的线程安全问题了解吗？" class="headerlink" title="Spring 中的单例 bean 的线程安全问题了解吗？"></a>Spring 中的单例 bean 的线程安全问题了解吗？</h3><p>的确是存在安全问题的。因为，当多个线程操作同一个对象的时候，对这个对象的成员变量的写操作会存在线程安全问题。</p>
<p>但是，一般情况下，我们常用的 <code>Controller</code>、<code>Service</code>、<code>Dao</code> 这些 Bean 是无状态的。无状态的 Bean 不能保存数据，因此是线程安全的。</p>
<p>常见的有 2 种解决办法：</p>
<ol>
<li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在  <code>ThreadLocal</code>  中（推荐的一种方式）。</li>
<li>改变 Bean 的作用域为 “prototype”：每次请求都会创建一个新的 bean 实例，自然不会存在线程安全问题。</li>
</ol>
<h3 id="Component-和-Bean-的区别是什么？"><a href="#Component-和-Bean-的区别是什么？" class="headerlink" title="@Component 和 @Bean 的区别是什么？"></a>@Component 和 @Bean 的区别是什么？</h3><ol>
<li>作用对象不同: <code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li>
<li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了Spring这是某个类的示例，当我需要用它的时候还给我。</li>
<li><code>@Bean</code> 注解比 <code>Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li>
</ol>
<p><code>@Bean</code>注解使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 上面的代码相当于下面的 xml 配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transferService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面这个例子是通过 <code>@Component</code> 无法实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OneService <span class="title">getService</span><span class="params">(status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> (status)  &#123;</span><br><span class="line">        when <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl1();</span><br><span class="line">        when <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl2();</span><br><span class="line">        when <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将一个类声明为Spring的-bean-的注解有哪些"><a href="#将一个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="将一个类声明为Spring的 bean 的注解有哪些?"></a>将一个类声明为Spring的 bean 的注解有哪些?</h3><p>我们一般使用 <code>@Autowired</code> 注解自动装配 bean，要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类,采用以下注解可实现：</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个Bean不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<h3 id="Spring-中的-bean-生命周期"><a href="#Spring-中的-bean-生命周期" class="headerlink" title="Spring 中的 bean 生命周期?"></a>Spring 中的 bean 生命周期?</h3><ul>
<li>Bean 容器找到配置文件中 Spring Bean 的定义。</li>
</ul>
<p><strong>（1）实例化 Bean：</strong></p>
<p>对于 BeanFactory 容器，当向容器请求一个尚未初始化的 bean 时，或初始化 bean 的时候需要注入另一个尚未初始化 bean 的依赖时，容器就会调用 createBean 进行实例化；</p>
<p>对于 ApplicationContext 容器，当容器启动结束后，通过获取 BeanDefinition 对象中的信息，实例化所有的 bean。</p>
<p><strong>（2）设置对象属性（依赖注入）：</strong></p>
<p>实例化后的 Bean 被封装在 BeanWrapper 对象中，然后 Spring 根据 BeanDefinition 中的信息以及通过 BeanWrapper 提供的设置属性的接口完成依赖注入。</p>
<p><strong>（3）处理 Aware 接口：</strong></p>
<p>Spring 会检测该 Bean 是否实现了 xxxAware 接口，并将相关的 xxxAware 实例注入给 Bean：</p>
<p>① 如果该 Bean 实现了 BeanNameAware 接口，会调用它实现的 setBeanName (String beanId) 方法，入参是 Spring 配置文件中 Bean 的 id 值；</p>
<p>② 如果该 Bean 实现了 BeanFactoryAware 接口，会调用它实现的 setBeanFactory () 方法，传递的是 Spring 工厂自身。</p>
<p>③ 如果该 Bean 已经实现了 ApplicationContextAware 接口，会调用 setApplicationContext (ApplicationContext) 方法，入参是 Spring 上下文；</p>
<p><strong>（4）处理 BeanPostProcessor 接口：</strong></p>
<p>如果该 Bean 实现了实现了 BeanPostProcessor 接口，那将会调用 postProcessBeforeInitialization (Object obj, String s) 方法；</p>
<p><strong>（5）InitializingBean 与 init-method：</strong><br> 如果该 Bean 在 xml 中配置了 init-method 属性，则会自动调用其配置的初始化方法。</p>
<p>以上几个步骤完成后，Bean 就已经被正确创建了，之后就可以使用这个 Bean 了。</p>
<p><strong>（6）处理 DisposableBean 接口：</strong></p>
<p>当 Bean 不再需要时，会经过清理阶段，如果 Bean 实现了 DisposableBean 这个接口，会调用其实现的 destroy () 方法；</p>
<p><strong>（7）处理 destroy-method 属性：</strong></p>
<p>最后，如果这个 Bean 的 Spring 配置中配置了 destroy-method 属性，会自动调用其配置的销毁方法。</p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/Springboot/Spring%20%E4%B8%AD%E7%9A%84%20bean%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Spring Bean 生命周期"></p>
<h3 id="Spring常见的依赖注入方式"><a href="#Spring常见的依赖注入方式" class="headerlink" title="Spring常见的依赖注入方式"></a>Spring常见的依赖注入方式</h3><ul>
<li>构造器注入：利用构造方法的参数注入依赖</li>
<li>Setter注入：调用Setter的方法注入依赖</li>
<li>字段注入：在字段上使用@Autowired/Resource注解</li>
</ul>
<h4 id="Autowired-VS-Resource"><a href="#Autowired-VS-Resource" class="headerlink" title="@Autowired VS @Resource"></a>@Autowired VS @Resource</h4><p>事实上，他们的基本功能都是通过注解实现依赖注入，只不过@Autowired是Spring定义的，而@Resource是JSR-250定义的。大致功能基本相同，但是还有一些细节不同：</p>
<ul>
<li>依赖识别方式：@Autowired默认是byType可以使用@Qualifier指定Name，@Resource默认ByName如果找不到则ByType</li>
<li>适用对象：@Autowired可以对构造器、方法、参数、字段使用，@Resource只能对方法、字段使用</li>
<li>提供方：@Autowired是Spring提供的，@Resource是JSR-250提供的</li>
</ul>
<h4 id="各种依赖注入方式的优缺点"><a href="#各种依赖注入方式的优缺点" class="headerlink" title="各种依赖注入方式的优缺点"></a>各种依赖注入方式的优缺点</h4><ul>
<li>构造器注入：强依赖性（即必须使用此依赖），不变性（各依赖不会经常变动）</li>
<li>Setter注入：可选（没有此依赖也可以工作），可变（依赖会经常变动）</li>
<li>Field注入：大多数情况下尽量少使用字段注入，一定要使用的话，@Resource相对@Autowired对IoC容器的耦合更低</li>
</ul>
<h4 id="Field注入的缺点"><a href="#Field注入的缺点" class="headerlink" title="Field注入的缺点"></a>Field注入的缺点</h4><ul>
<li>不能像构造器那样注入不可变的对象</li>
<li>依赖对外部不可见，外界可以看到构造器和setter，但无法看到私有字段，自然无法了解所需依赖</li>
<li>会导致组件与IoC容器紧耦合（这是最重要的原因，离开了IoC容器去使用组件，在注入依赖时就会十分困难）</li>
<li>导致单元测试也必须使用IoC容器，原因同上</li>
<li>依赖过多时不够明显，比如我需要10个依赖，用构造器注入就会显得庞大，这时候应该考虑一下此组件是不是违反了单一职责原则<br>为什么IDEA只对@Autowired警告</li>
</ul>
<h4 id="为什么IDEA只对-Autowired警告"><a href="#为什么IDEA只对-Autowired警告" class="headerlink" title="为什么IDEA只对@Autowired警告"></a>为什么IDEA只对@Autowired警告</h4><p>Field注入虽然有很多缺点，但它的好处也不可忽略：那就是太方便了。</p>
<p>使用构造器或者setter注入需要写更多业务无关的代码，十分麻烦，而字段注入大幅简化了它们。并且绝大多数情况下业务代码和框架就是强绑定的，完全松耦合只是一件理想上的事，牺牲了敏捷度去过度追求松耦合反而得不偿失。</p>
<p>为什么IDEA只对@Autowired警告，却对@Resource视而不见呢？</p>
<p>@Autowired是Spring提供的，它是特定IoC提供的特定注解，这就导致了应用与框架的强绑定，一旦换用了其他的IoC框架，是不能够支持注入的。</p>
<p>@Resource是JSR-250提供的，它是Java标准，我们使用的IoC容器应当去兼容它，这样即使更换容器，也可以正常工作。</p>
<h5 id="工作中的使用"><a href="#工作中的使用" class="headerlink" title="工作中的使用"></a>工作中的使用</h5><p>给类加<code>@RequiredArgsConstructor</code>注解，使用<code>private final</code>修饰注入对象</p>
<h3 id="我们在Service层能不能注入Controller的Bean？"><a href="#我们在Service层能不能注入Controller的Bean？" class="headerlink" title="我们在Service层能不能注入Controller的Bean？"></a>我们在Service层能不能注入Controller的Bean？</h3><blockquote>
<p>一般我们使用Spring的时候可以注入并正常使用的，但是使用SpringMVC+Spring的时候不能</p>
</blockquote>
<p>Spring和SpringMVC都会根据自己的配置文件去生成各自的容器，那Spring的叫做父容器，SpringMVC的叫做子容器。但是其主要区别在于：子容器可以访问父容器中的Bean，而父容器不能访问子容器中的Bean，所说我们可以在Controller中注入@Service，@Component，@Repository等Bean，但如果想要在Service中注入@Controller Bean是不可以的 ，因为父容器不能访问子容器中的Bean，实际我们也不会这样用。</p>
<h3 id="为什么要分两个容器来存放Bean呢，我使用Spring扫描全部的Bean有没有问题？"><a href="#为什么要分两个容器来存放Bean呢，我使用Spring扫描全部的Bean有没有问题？" class="headerlink" title="为什么要分两个容器来存放Bean呢，我使用Spring扫描全部的Bean有没有问题？"></a>为什么要分两个容器来存放Bean呢，我使用Spring扫描全部的Bean有没有问题？</h3><p>如果我们使用Spring扫描所有的Bean，那说明所有的Bean都在父容器中，那SpringMVC会找不到Controller对象的，因为HandleMapping在找Controller时默认是不会去父容器中找的（HandleMapping处理器映射器）。如果你真的想把Controller的Bean存入父容器中，可以通过手动配置让它从父容器中找。但是这样会对HandlerMapping的配置不太好，约定大于配置嘛！（另外，如果所有Bean都在父容器中时，Controller的Bean是可以注入到Service的，因为两者都在Spring容器中）</p>
<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="说说自己对于-Spring-MVC-了解"><a href="#说说自己对于-Spring-MVC-了解" class="headerlink" title="说说自己对于 Spring MVC 了解?"></a>说说自己对于 Spring MVC 了解?</h3><p>MVC 是一种设计模式。Spring MVC 可以帮助我们进行更简洁的Web层的开发，并且它天生与 Spring 框架集成。Spring  MVC 下我们一般把后端项目分为  Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。</p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/Springboot/Spring%20MVC.png" alt="img"></p>
<h3 id="SpringMVC-工作原理了解吗"><a href="#SpringMVC-工作原理了解吗" class="headerlink" title="SpringMVC 工作原理了解吗?"></a>SpringMVC 工作原理了解吗?</h3><p><strong>原理如下图所示：</strong></p>
<blockquote>
<p>笔误的：Spring MVC 的入口函数也就是前端控制器 <code>DispatcherServlet</code> 的作用是接收请求，响应结果。</p>
</blockquote>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/Springboot/SpringMVC%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="SpringMVC运行原理"></p>
<p><strong>流程说明（重要）：</strong></p>
<ol>
<li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</li>
<li>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</li>
<li><code>HandlerAdapter</code> 会根据 <code>Handler </code>来调用真正的处理器来处理请求，并处理相应的业务逻辑。</li>
<li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）<h2 id="Spring-框架中用到了哪些设计模式？"><a href="#Spring-框架中用到了哪些设计模式？" class="headerlink" title="Spring 框架中用到了哪些设计模式？"></a>Spring 框架中用到了哪些设计模式？</h2></li>
</ol>
<ul>
<li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
</ul>
<h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h2><h3 id="Spring-管理事务的方式有几种？"><a href="#Spring-管理事务的方式有几种？" class="headerlink" title="Spring 管理事务的方式有几种？"></a>Spring 管理事务的方式有几种？</h3><ol>
<li>编程式事务，在代码中硬编码。(不推荐使用)</li>
<li>声明式事务，在配置文件中配置（推荐使用）</li>
</ol>
<p><strong>声明式事务又分为两种：</strong></p>
<ol>
<li>基于XML的声明式事务</li>
<li>基于注解的声明式事务</li>
</ol>
<h3 id="Spring-事务中的隔离级别有哪几种"><a href="#Spring-事务中的隔离级别有哪几种" class="headerlink" title="Spring 事务中的隔离级别有哪几种?"></a>Spring 事务中的隔离级别有哪几种?</h3><p><strong>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</strong></p>
<ul>
<li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong>  使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong>   允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong>  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong>   最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h3 id="Spring-事务中哪几种事务传播行为"><a href="#Spring-事务中哪几种事务传播行为" class="headerlink" title="Spring 事务中哪几种事务传播行为?"></a>Spring 事务中哪几种事务传播行为?</h3><p><strong>支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRED：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li><strong>TransactionDefinition.PROPAGATION_SUPPORTS：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong>TransactionDefinition.PROPAGATION_MANDATORY：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
</ul>
<p><strong>不支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW：</strong> 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：</strong> 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NEVER：</strong> 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p><strong>其他情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_NESTED：</strong> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<h3 id="Transactional-rollbackFor-Exception-class-注解了解吗？"><a href="#Transactional-rollbackFor-Exception-class-注解了解吗？" class="headerlink" title="@Transactional(rollbackFor = Exception.class)注解了解吗？"></a>@Transactional(rollbackFor = Exception.class)注解了解吗？</h3><p>我们知道：Exception分为运行时异常RuntimeException和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p>
<p>当<code>@Transactional</code>注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p>
<p>在<code>@Transactional</code>注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚,加上<code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚。</p>
<h2 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h2><h3 id="如何使用JPA在数据库中非持久化一个字段？"><a href="#如何使用JPA在数据库中非持久化一个字段？" class="headerlink" title="如何使用JPA在数据库中非持久化一个字段？"></a>如何使用JPA在数据库中非持久化一个字段？</h3><p>假如我们有有下面一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Entity(name=<span class="string">&quot;USER&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.AUTO)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column(name=&quot;USER_NAME&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column(name=&quot;PASSWORD&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String secrect;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想让<code>secrect</code> 这个字段不被持久化，也就是不被数据库存储怎么办？我们可以采用下面几种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String transient1; <span class="comment">// not persistent because of static</span></span><br><span class="line"><span class="keyword">final</span> String transient2 = “Satish”; <span class="comment">// not persistent because of final</span></span><br><span class="line"><span class="keyword">transient</span> String transient3; <span class="comment">// not persistent because of transient</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line">String transient4; <span class="comment">// not persistent because of @Transient</span></span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%8C%E7%A9%BF%E9%80%8F%EF%BC%8C%E5%87%BB%E7%A9%BF%EF%BC%8C%E9%A2%84%E7%83%AD%EF%BC%8C%E6%9B%B4%E6%96%B0%EF%BC%8C%E9%99%8D%E7%BA%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%8C%E7%A9%BF%E9%80%8F%EF%BC%8C%E5%87%BB%E7%A9%BF%EF%BC%8C%E9%A2%84%E7%83%AD%EF%BC%8C%E6%9B%B4%E6%96%B0%EF%BC%8C%E9%99%8D%E7%BA%A7/" itemprop="url">redis缓存雪崩，穿透，击穿，预热，更新，降级</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T19:29:30+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="redis-雪崩："><a href="#redis-雪崩：" class="headerlink" title="redis 雪崩："></a>redis 雪崩：</h1><p>雪崩就是指缓存中<strong>大批量热点数据过期</strong>后系统涌入大量查询请求，因为<strong>大部分数据在Redis层已经失</strong>效，请求渗透到<strong>数据库层</strong>，大批量请求犹如洪水一般涌入，引起数据库压力造成查询堵塞甚至宕机。</p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.png" alt="image"></p>
<h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><ol>
<li>将缓存失效时间分散开，比如每个key的过期时间是随机，防止同一时间大量数据过期现象发生，这样不会出现同一时间全部请求都落在数据库层，如果缓存数据库是分布式部署，将热点数据均匀分布在不同Redis和数据库中，有效分担压力，别一个人扛。</li>
<li>简单粗暴，让Redis数据永不过期（如果业务准许，比如不用更新的名单类）。当然，如果业务数据准许的情况下可以，比如中奖名单用户，每期用户开奖后，名单不可能会变了，无需更新。</li>
<li>采用限流算法，限制请求流量，业务有损；</li>
<li>加锁访问，但是吞吐量会明显下降。</li>
<li>采购第三方Redis</li>
</ol>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A92.png" alt="image"></p>
<ol start="6">
<li>多缓存结合</li>
</ol>
<img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A93.png" style="zoom:33%;" />

<h1 id="击穿和穿透"><a href="#击穿和穿透" class="headerlink" title="击穿和穿透"></a>击穿和穿透</h1><h2 id="redis-穿透"><a href="#redis-穿透" class="headerlink" title="redis 穿透"></a>redis 穿透</h2><p>穿透是指绕过Reids，调用者发起的请求参数（key）在缓存和数据库中都不存在，通过不存在的key，成功穿透到系统底层，大规模不断发起不存在的key检索请求导致系统压力过大最后故障。</p>
<p>造成穿透的伪代码多为这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(redis.get(key) == <span class="keyword">null</span>)&#123;</span><br><span class="line">  <span class="comment">// redis数据不存在或已经过期 查询数据库</span></span><br><span class="line"> Object value = dao.query(key);</span><br><span class="line">  <span class="comment">// 重新将value刷入缓存。</span></span><br><span class="line">  redis.set(key);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> reids.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="以mall项目为例子"><a href="#以mall项目为例子" class="headerlink" title="以mall项目为例子"></a>以mall项目为例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;CategoryVO&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">String catsStr = redisOperator.get(<span class="string">&quot;subCat:&quot;</span> + rootCatId);</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isBlank(catsStr))&#123;</span><br><span class="line">    list = categoryService.getSubCatList(rootCatId);</span><br><span class="line">    redisOperator.set(<span class="string">&quot;subCat:&quot;</span> + rootCatId,JsonUtils.objectToJson(list));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    list = JsonUtils.jsonToList(catsStr,CategoryVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="攻击造成缓存穿透"><a href="#攻击造成缓存穿透" class="headerlink" title="攻击造成缓存穿透"></a>攻击造成缓存穿透</h3><p>不停地调用查询接口 查询 <strong>rootCatId == 99999</strong> 的子类造成不停查询数据库</p>
<h3 id="解决办法：-1"><a href="#解决办法：-1" class="headerlink" title="解决办法："></a>解决办法：</h3><ol>
<li><p>分布式布隆过滤器：布隆是BloomFilter音译过来的，Redis 自身支持BloomFilter。</p>
<p><strong>布隆过滤器缺点</strong>: 无法删除</p>
</li>
<li><p>返回空值：遇到数据库和Redis都查询不到的值，在Redis里set一个null value，过期时间很短，目的在于同一个key再次请求时直接返回null，避免穿透。</p>
</li>
<li><p>多级缓存。L1 为原始缓存（过期时间设置为短期），L2 为二级缓存（过期时间设置为长期）。L1 失效时可以继续访问 L2，避免同时失效。不过多了一级缓存，存储成本更高，而且多个缓存之间的数据一致性问题挑战也大。</p>
</li>
</ol>
<h2 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h2><p>BloomFilter：即布隆过滤器。可以用于检索一个元素是否在一个集合中。</p>
<h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><p>BloomFilter检索一个元素是否在一个集合中有一定的错误率（很低），但不会漏判。</p>
<ul>
<li><strong>如果判断一个key不在集合中，那一定不在</strong>。</li>
<li><strong>如果判断一个key存在，那不一定真的在</strong>。</li>
</ul>
<p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 <strong>“某样东西一定不存在或者可能存在”</strong>。</p>
<p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>基本思想是利用一个足够好的Hash函数将一个字符串映射到二进制位数组中的某一位，这样不管字符串如何长，都只有一位，因此存储空间就极大的提升了。但是不管hash函数如何高效，总是会存在Hash冲突，尤其是数据量变大的时候，而BloomFilter是利用多个不同的Hash函数来解决“冲突”，即一次采用多个Hash函数把数据映射到不同的位上，降低了冲突概率。如下图所示，</p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt="image">subCat:9999 会被误判为存在</p>
<p>如何根据输入元素个数n，确定位数组m的大小及Hash函数个数？已知文献证明，当Hash函数个数k=(ln2)*(m/n)时错误率最小。</p>
<p>BloomFilter有个缺点是不能删除数据，因为删除数据可能会影响到其它数据，有一些增强算法可以实现改功能，但代价比较大，不建议使用。</p>
<p>BloomFilter十分适合海量数据去重、过滤，尤其是当检测的字符串比较大时，极大地节省内存和存储空间，同时查询效率也十分高效。如果只是在内存使用，直接使用guava包的api即可；如果要做到分布式，结合Redis可以高效实现分布式的过滤效果。</p>
<h2 id="redis击穿"><a href="#redis击穿" class="headerlink" title="redis击穿"></a>redis击穿</h2><p>击穿和穿透概念类似，一般是指一个key被穿透，这个key是热点key，同一个key会被有成千上万次请求，比如微博热点排行榜，key是小时时间戳，value是个list的榜单。每个小时产生一个key，这个key会有百万QPS，如果这个key失效了，就像保险丝熔断，百万QPS直接压垮数据库。</p>
<h3 id="解决办法：-2"><a href="#解决办法：-2" class="headerlink" title="解决办法："></a>解决办法：</h3><p>业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。类似下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(key)</span> </span>&#123;</span><br><span class="line">    String value = redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">//代表缓存值过期</span></span><br><span class="line">        <span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line">        <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;  <span class="comment">//代表设置成功</span></span><br><span class="line">            value = db.get(key);</span><br><span class="line">            redis.set(key, value, expire_secs);</span><br><span class="line">            redis.del(key_mutex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">            sleep(<span class="number">50</span>);</span><br><span class="line">            get(key);  <span class="comment">//重试</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;      </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h1><p>缓存预热这个应该是一个比较常见的概念，相信都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p>解决思路：</p>
<p>1、直接写个缓存刷新页面，上线时手工操作下；</p>
<p>2、数据量不大，可以在项目启动的时候自动进行加载；</p>
<p>3、定时刷新缓存；</p>
<h1 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h1><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<p>（1）定时去清理过期的缓存；</p>
<p>（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</p>
<p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！</p>
<h1 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h1><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<p>（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p>
<p>（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</p>
<p>（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</p>
<p>（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/redis%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/redis%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5/" itemprop="url">redis缓存读写策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T16:43:29+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="如何保证缓存和数据库数据的一致性？-重要"><a href="#如何保证缓存和数据库数据的一致性？-重要" class="headerlink" title="如何保证缓存和数据库数据的一致性？(重要)"></a>如何保证缓存和数据库数据的一致性？(重要)</h1><p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p>
<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p>
<ol>
<li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li><strong>增加cache更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。</li>
</ol>
<h1 id="redis缓存读写策略"><a href="#redis缓存读写策略" class="headerlink" title="redis缓存读写策略"></a>redis缓存读写策略</h1><ul>
<li><p>Cache Aside （旁路缓存模式）</p>
<ul>
<li>先更新数据库，再更新缓存。这种做法最大的问题就是两个并发的写操作导致脏数据</li>
<li>先删除缓存，再更新数据库。这个逻辑是错误的，因为两个并发的读和写操作导致脏数据</li>
<li>先更新数据库，再删除缓存（在实际的系统中也推荐使用这种方式）</li>
</ul>
</li>
<li><p>Read/Write Through Pattern（读写穿透）</p>
</li>
<li><p>Write-behind caching（异步缓存写入）</p>
</li>
</ul>
<h2 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache Aside Pattern（旁路缓存模式）"></a>Cache Aside Pattern（旁路缓存模式）</h2><ul>
<li><p><strong>Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。</strong></p>
</li>
<li><p>Cache Aside Pattern 中服务端需要同时维系 DB 和 cache，并且是以 DB 的结果为准。</p>
</li>
<li><p>保证最终一致性的解决方案是缓存设置过期时间。</p>
</li>
</ul>
<h3 id="缓存读步骤"><a href="#缓存读步骤" class="headerlink" title="缓存读步骤"></a>缓存读步骤</h3><ul>
<li>从 cache 中读取数据，读取到就直接返回</li>
<li>cache中读取不到的话，就从 DB 中读取数据返回</li>
<li>再把数据放到 cache 中。</li>
</ul>
<img src="https://img-blog.csdnimg.cn/img_convert/a8c18b5f5b1aed03234bcbbd8c173a87.png" alt="img" style="zoom: 50%;" />

<h3 id="缓存写步骤"><a href="#缓存写步骤" class="headerlink" title="缓存写步骤"></a>缓存写步骤</h3><h4 id="方案一：先更新缓存，再更新数据库"><a href="#方案一：先更新缓存，再更新数据库" class="headerlink" title="方案一：先更新缓存，再更新数据库"></a>方案一：先更新缓存，再更新数据库</h4><p>不推荐。</p>
<ol>
<li>先更新缓存</li>
<li>若更新数据库失败，还需再更新缓存。</li>
</ol>
<h4 id="方案二：先更新数据库，再更新缓存"><a href="#方案二：先更新数据库，再更新缓存" class="headerlink" title="方案二：先更新数据库，再更新缓存"></a>方案二：先更新数据库，再更新缓存</h4><p>不推荐。</p>
<p>同时有请求A和请求B进行更新操作，请求A与B在不同线程，可能会出现：</p>
<ol>
<li>请求A更新了数据库</li>
<li>请求B更新了数据库</li>
<li>请求B更新了缓存</li>
<li>请求A更新了缓存</li>
</ol>
<p>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。</p>
<h4 id="方案三：先删除缓存，再更新数据库"><a href="#方案三：先删除缓存，再更新数据库" class="headerlink" title="方案三：先删除缓存，再更新数据库"></a>方案三：先删除缓存，再更新数据库</h4><p>有点问题。</p>
<p>有一个请求A进行更新操作，另一个请求B进行查询操作，可能会出现：</p>
<p>（1）、单个数据库</p>
<ol>
<li>请求A进行写操作，删除缓存</li>
<li>请求B查询发现缓存不存在</li>
<li>请求B去数据库查询得到旧值</li>
<li>请求B将旧值写入缓存</li>
<li>请求A将新值写入数据库</li>
</ol>
<p>（2）、读写分离架构</p>
<ol>
<li><p>请求A进行写操作，删除缓存</p>
</li>
<li><p>请求A将数据写入数据库了，</p>
</li>
<li><p>请求B查询缓存发现，缓存没有值</p>
</li>
<li><p>请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值</p>
</li>
<li><p>请求B将旧值写入缓存</p>
</li>
<li><p>数据库完成主从同步，从库变为新值</p>
</li>
</ol>
<p>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据</p>
<h5 id="解决方案：延时双删策略"><a href="#解决方案：延时双删策略" class="headerlink" title="解决方案：延时双删策略"></a>解决方案：延时双删策略</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void write(String key,Object data)&#123;</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">    db.updateData(data);</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先淘汰缓存</li>
<li>再写数据库（这两步和原来一样）</li>
<li>休眠1秒</li>
<li>再次淘汰缓存</li>
</ol>
<p>自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>
<p>对于MySQL读写分离架构，只是睡眠时间修改为在主从同步的延时时间基础上，加几百ms。</p>
<h4 id="方案四：先更新数据库，再删除缓存"><a href="#方案四：先更新数据库，再删除缓存" class="headerlink" title="方案四：先更新数据库，再删除缓存"></a>方案四：先更新数据库，再删除缓存</h4><img src="https://img-blog.csdnimg.cn/img_convert/5687fe759a1dac9ed9554d27e3a23b6d.png" alt="img" style="zoom:50%;" />

<p>极端情况有问题。</p>
<p>有一个请求A进行更新操作，另一个请求B进行查询操作，可能会出现：</p>
<ol>
<li>请求A查询数据库得到一个旧值</li>
<li>请求B将新值写入数据库</li>
<li>请求B删除缓存</li>
<li>请求A将查到的旧值写入缓存</li>
</ol>
<p>步骤2的<strong>写数据库操作比步骤1的读数据库操作耗时更短</strong>，才有可能使得步骤3先于步骤4。可是，数据库的<strong>读操作的速度远快于写操作</strong>的，因此步骤2耗时比步骤1更短，这一情形很难出现。</p>
<h5 id="解决方案：延时双删策略-1"><a href="#解决方案：延时双删策略-1" class="headerlink" title="解决方案：延时双删策略"></a>解决方案：延时双删策略</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void write(String key,Object data)&#123;</span><br><span class="line">    db.updateData(data);</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先写数据库</li>
<li>再淘汰缓存</li>
<li>休眠1秒</li>
<li>再次淘汰缓存</li>
</ol>
<h4 id="方案三与方案四还存在问题"><a href="#方案三与方案四还存在问题" class="headerlink" title="方案三与方案四还存在问题"></a>方案三与方案四还存在问题</h4><ul>
<li>问题一:同步双删导致并发降低</li>
<li>问题二:比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况。</li>
</ul>
<h5 id="问题一解决方案"><a href="#问题一解决方案" class="headerlink" title="问题一解决方案"></a>问题一解决方案</h5><p>异步。</p>
<h5 id="问题二解决方案"><a href="#问题二解决方案" class="headerlink" title="问题二解决方案"></a>问题二解决方案</h5><p>提供一个保障的重试机制。</p>
<h6 id="方案一：消息队列方式"><a href="#方案一：消息队列方式" class="headerlink" title="方案一：消息队列方式"></a>方案一：消息队列方式</h6><p>更新数据库数据<br>缓存因为种种问题删除失败<br>将需要删除的key发送至消息队列<br>自己消费消息，获得需要删除的key<br>继续重试删除操作，直到成功</p>
<p>业务线代码侵入较大。</p>
<h6 id="方案二：订阅binlong方式"><a href="#方案二：订阅binlong方式" class="headerlink" title="方案二：订阅binlong方式"></a>方案二：订阅binlong方式</h6><p>更新数据库数据<br>数据库会将操作信息写入binlog日志当中<br>订阅程序提取出所需要的数据以及key<br>另起一段非业务代码，获得该信息<br>尝试删除缓存操作，发现删除失败<br>将这些信息发送至消息队列<br>重新从消息队列中获得该数据，重试操作。</p>
<blockquote>
<p>订阅binlog程序在MySQL中有阿里开源的中间件叫canal。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试也可。</p>
</blockquote>
<p><strong>总结</strong></p>
<p>根据数据实时性要求，以及系统并发量考虑。</p>
<p>实时性不强，则可以选择设定缓存过期时间，先删缓存再更新数据库或先更新数据库再删缓存方案都可行。</p>
<p>实时性较强的，又有大并发量可以考虑延迟双删策略。</p>
<p>至于其他如请求串行化，放入同一个队列中依次执行的，复杂没必要。</p>
<h3 id="Cache-Aside-Pattern的缺陷"><a href="#Cache-Aside-Pattern的缺陷" class="headerlink" title="Cache Aside Pattern的缺陷"></a>Cache Aside Pattern的缺陷</h3><ul>
<li><p>缺陷1：首次请求数据一定不在 cache 的问题</p>
<p>解决办法：可以将热点数据可以提前放入cache 中。</p>
</li>
<li><p>写操作比较频繁的话导致cache中的数据会被频繁被删除，这样会影响缓存命中率 。</p>
<p>解决办法：</p>
<ul>
<li>数据库和缓存数据强一致场景 ：更新DB的时候同样更新cache，不过我们需要加一个锁/分布式锁来保证更新cache的时候不存在线程安全问题。</li>
<li>可以短暂地允许数据库和缓存数据不一致的场景 ：更新DB的时候同样更新cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li>
</ul>
</li>
</ul>
<h2 id="Read-Write-Through-Pattern（读写穿透）"><a href="#Read-Write-Through-Pattern（读写穿透）" class="headerlink" title="Read/Write Through Pattern（读写穿透）"></a>Read/Write Through Pattern（读写穿透）</h2><p>Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。</p>
<p>这种缓存读写策略在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为使用的分布式缓存 Redis 并没有提供 cache 将数据写入DB的功能。</p>
<p><strong>写（Write Through）：</strong></p>
<ul>
<li>先查 cache，cache 中不存在，直接更新 DB。</li>
<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（<strong>同步更新 cache 和 DB</strong>）。</li>
</ul>
<p>简单画了一张图帮助大家理解写的步骤。</p>
<p><img src="https://img-blog.csdnimg.cn/20210201100340808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70&ynotemdtimestamp=1617437153078" alt="img"></p>
<p><strong>读(Read Through)：</strong></p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回 。</li>
<li>读取不到的话，先从 DB 加载，写入到 cache 后返回响应。</li>
</ul>
<p>简单画了一张图帮助大家理解读的步骤。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9ada757c78614934aca11306f334638d.png?ynotemdtimestamp=1617437153078" alt="img"></p>
<p>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。</p>
<p>和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。</p>
<h1 id="Write-Behind-Pattern（异步缓存写入）"><a href="#Write-Behind-Pattern（异步缓存写入）" class="headerlink" title="Write Behind Pattern（异步缓存写入）"></a>Write Behind Pattern（异步缓存写入）</h1><p>Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 DB 的读写。</p>
<p>但是，两个又有很大的不同：<strong>Read/Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。</strong></p>
<p>很明显，这种方式对数据一致性带来了更大的挑战，比如cache数据可能还没异步更新DB的话，cache服务可能就就挂掉了。</p>
<p>这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 InnoDB Buffer Pool 机制都用到了这种策略。</p>
<p>Write Behind Pattern 下 DB 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/redis%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/redis%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/" itemprop="url">redis实际应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T16:32:57+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis知识点</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/redis-redis%E5%BA%94%E7%94%A8/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis应用</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis-最适合的场景是什么？"><a href="#Redis-最适合的场景是什么？" class="headerlink" title="Redis 最适合的场景是什么？"></a>Redis 最适合的场景是什么？</h1><p>1、会话缓存（Session Cache）</p>
<p>最常用的一种使用 Redis 的情景是会话缓存（session cache）。用 Redis 缓存会话比其他存储（如 Memcached）的优势在于：Redis 提供持久化。</p>
<p>2、全页缓存（FPC）</p>
<p>除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。能帮助你以最快速度加载你曾浏览过的页面。</p>
<p>3、队列</p>
<p>Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push/pop 操作。</p>
<p>4，排行榜/计数器</p>
<p>Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的 10个用户，我们只需要像下面一样执行即可： 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES。</p>
<p>5、发布/订阅</p>
<p>最后（但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。在社交网络中甚至可以用 Redis 的发布/订阅功能来建立聊天系统！</p>
<h1 id="Redis-做异步队列（发布-订阅）"><a href="#Redis-做异步队列（发布-订阅）" class="headerlink" title="Redis 做异步队列（发布/订阅）"></a>Redis 做异步队列（发布/订阅）</h1><p>一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。</p>
<h2 id="可不可以不用-sleep-呢？"><a href="#可不可以不用-sleep-呢？" class="headerlink" title="可不可以不用 sleep 呢？"></a>可不可以不用 sleep 呢？</h2><p>list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。</p>
<h2 id="能不能生产一次消费多次呢？"><a href="#能不能生产一次消费多次呢？" class="headerlink" title="能不能生产一次消费多次呢？"></a>能不能生产一次消费多次呢？</h2><p>使用 pub/sub 主题订阅者模式，可以实现1:N 的消息队列。</p>
<h2 id="pub-sub-有什么缺点？"><a href="#pub-sub-有什么缺点？" class="headerlink" title="pub/sub 有什么缺点？"></a>pub/sub 有什么缺点？</h2><p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 RabbitMQ等。</p>
<h2 id="redis-如何实现延时队列？"><a href="#redis-如何实现延时队列？" class="headerlink" title="redis 如何实现延时队列？"></a>redis 如何实现延时队列？</h2><p>使用 sortedset，拿时间戳作为score，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。<br>40.使用过 Redis 分布式锁么，它是什么回事？</p>
<h1 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h1><p>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止忘记释放</p>
<h1 id="Redis-Cookie分布式会话"><a href="#Redis-Cookie分布式会话" class="headerlink" title="Redis+Cookie分布式会话"></a>Redis+Cookie分布式会话</h1><h2 id="如果在setnx之后执行expire之前进程意外crash或者重启维护了，怎么办？"><a href="#如果在setnx之后执行expire之前进程意外crash或者重启维护了，怎么办？" class="headerlink" title="如果在setnx之后执行expire之前进程意外crash或者重启维护了，怎么办？"></a>如果在setnx之后执行expire之前进程意外crash或者重启维护了，怎么办？</h2><p>setnx和expire合成一条指令</p>
<h1 id="redis批量查询优化"><a href="#redis批量查询优化" class="headerlink" title="redis批量查询优化"></a>redis批量查询优化</h1><h2 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 大量key查询</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/getALot&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getALot</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; resutl = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String k:keys) &#123;</span><br><span class="line">        resutl.add(redisOperator.get(k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resutl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h2><h3 id="mget进行批量查询"><a href="#mget进行批量查询" class="headerlink" title="mget进行批量查询"></a>mget进行批量查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量查询 mget</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/mget&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">mget</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; keysList = Arrays.asList(keys);</span><br><span class="line">    <span class="keyword">return</span> redisOperator.mget(keysList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pipeline-进行批量查询"><a href="#pipeline-进行批量查询" class="headerlink" title="pipeline 进行批量查询"></a>pipeline 进行批量查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量查询 pipeline</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/batchGet&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">batchGet</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; keysList = Arrays.asList(keys);</span><br><span class="line">    <span class="keyword">return</span> redisOperator.batchGet(keysList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="redis热点数据问题"><a href="#redis热点数据问题" class="headerlink" title="redis热点数据问题"></a>redis热点数据问题</h1><h2 id="MySQL-里有-2000w-数据，Redis-中只存-20w-的数据，如何保证Redis-中的数据都是热点数据？"><a href="#MySQL-里有-2000w-数据，Redis-中只存-20w-的数据，如何保证Redis-中的数据都是热点数据？" class="headerlink" title="MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证Redis 中的数据都是热点数据？"></a>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证Redis 中的数据都是热点数据？</h2><p>限定 Redis 占用的内存，Redis 会根据自身数据淘汰策略，加载热数据到内存。 所以，计算一下 20W 数据大约占用的内存，然后设置一下 Redis 内存限制即可。</p>
<p>Redis存储数据会限制它内存大小，如果超过了最大内存容量，会触发数据淘汰策略</p>
<h2 id="由于内存限制，导致了Redis中只能存储最多1W条的数据信息，如何确保这1w条数据是最热门的数据？"><a href="#由于内存限制，导致了Redis中只能存储最多1W条的数据信息，如何确保这1w条数据是最热门的数据？" class="headerlink" title="由于内存限制，导致了Redis中只能存储最多1W条的数据信息，如何确保这1w条数据是最热门的数据？"></a>由于内存限制，导致了Redis中只能存储最多1W条的数据信息，如何确保这1w条数据是最热门的数据？</h2><h3 id="热点数据排序（点击次数）"><a href="#热点数据排序（点击次数）" class="headerlink" title="热点数据排序（点击次数）"></a>热点数据排序（点击次数）</h3><p>既然热门数据，那么就需要有排序，使用redis中的zset数据类型是很自然的想法。数据中的某个唯一字段作为zset中的value，而点击次数作为score，记为click_zset。这样就可选出最热门的数据。而数据，则直接用HashMap存储。</p>
<h3 id="热点数据时间（近期访问）"><a href="#热点数据时间（近期访问）" class="headerlink" title="热点数据时间（近期访问）"></a>热点数据时间（近期访问）</h3><p>既然只能存1w条数据且需要是热门数据，那么，点击次数是一方面，时效性也是一方面，如何保证？可以另起一个zset，数据的字段为value，而每次点击时更新当前时间戳为其score，记为time_zset这样，就可以记录时间。在后台跑一个任务，间隔一定时间段删除两个zset中长时间没有发生点击事件的键，并删除hash数据，为产生的新数据腾出数据空间。</p>
<h3 id="处理新热点数据"><a href="#处理新热点数据" class="headerlink" title="处理新热点数据"></a>处理新热点数据</h3><p>如果有空间，则保存到自己的hashmap，并将key存到两个zset中。 而没有空间时，就应该在click_zset中取出点击次数排在最前第1w位后面的键，删除对应的hash数据。然后看这1w个score的值，然后把key放入两个zset中即可。</p>
<h1 id="redis在自己工作中的使用"><a href="#redis在自己工作中的使用" class="headerlink" title="redis在自己工作中的使用"></a>redis在自己工作中的使用</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37334135/article/details/77751562?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.channel_param">参考</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/yuanyayuan/yymall/blob/master/mall_api/src/main/java/com/nexus/mall/api/controller/ShopcatController.java">源代码(登录状态购物车修改)</a>，<a target="_blank" rel="noopener" href="https://github.com/yuanyayuan/yymall/blob/master/mall_api/src/main/java/com/nexus/mall/api/controller/PassportController.java">源代码(用户登录后购物车同步)</a></p>
<p>未实现购物车数量修改，未登录时由前端修改cookie</p>
<h2 id="redis结合cookie实现购物车"><a href="#redis结合cookie实现购物车" class="headerlink" title="redis结合cookie实现购物车"></a>redis结合cookie实现购物车</h2><h3 id="未登录状态下购物车功能实现"><a href="#未登录状态下购物车功能实现" class="headerlink" title="未登录状态下购物车功能实现"></a>未登录状态下购物车功能实现</h3><blockquote>
<p> 把购物车信息写入cookie。</p>
</blockquote>
<ul>
<li>优点：<br>1、不占用服务端存储空间<br>2、用户体验好。<br>3、代码实现简单。</li>
<li>缺点：<br>1、cookie中保存的容量有限。最大4k<br>2、把购物车信息保存在cookie中，更换设备购物车信息不能同步。</li>
</ul>
<h4 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h4><ol>
<li><p>完全由前端实现，操作cookie存储购物车信息修改</p>
</li>
<li><p>后端提供接口，实现cookie的信息修改</p>
<ul>
<li>购物车新增商品分析：</li>
</ul>
<ol>
<li>从cookie中获取购物车列表</li>
<li>遍历购物车列表，判断需要添加的商品在购物车列表是否存在</li>
<li>商品存在的话，那么取出该商品原来的数量+添加的数量作为该商品现在的数量</li>
<li>如果商品不存在，那么调用服务，根据传来的商品id查询商品数量，设置商品的数量为页面传来的数量，取商品的第一张图片(购物车列表只展示一张图片)。</li>
<li>把修改后的购物车列表重新存入到cookie中</li>
</ol>
<ul>
<li>购物车删除商品分析</li>
</ul>
<ol>
<li>从cookie中获取购物车列表</li>
<li>遍历，查找到要删除的商品</li>
<li>将该商品从购物车列表移除</li>
<li>更新后的购物车列表重新写入cookie</li>
</ol>
<ul>
<li>购物车列表页面修改商品数量(点击“+”或者“-”)</li>
</ul>
<ol>
<li>从cookie中获取购物车列表</li>
<li>取所选择的需要更新的商品</li>
<li>更新商品数量</li>
<li>物车信息写入cookie</li>
</ol>
</li>
</ol>
<h3 id="登录状态下购物车功能的实现"><a href="#登录状态下购物车功能的实现" class="headerlink" title="登录状态下购物车功能的实现"></a>登录状态下购物车功能的实现</h3><blockquote>
<p>未登录状态下，把购物车数据保存到cookie中。登录状态下，需要把购物车数据保存到服务端。需要永久保存，可以保存到数据库中也可以把购物车数据保存到redis中，但数据库和redis同时保存购物车信息时需考虑数据一致性问题</p>
</blockquote>
<h4 id="redis使用的数据类型"><a href="#redis使用的数据类型" class="headerlink" title="redis使用的数据类型"></a>redis使用的数据类型</h4><ol>
<li> 使用hash数据类型</li>
<li>Hash的key应该是用户id。Hash中的field是商品id，value可以是把商品信息转换成json</li>
</ol>
<h4 id="实现方式：-1"><a href="#实现方式：-1" class="headerlink" title="实现方式："></a>实现方式：</h4><p>把购物车数据保存到redis(<em>数据类型是hash  key:用户id   field:商品id  value:商品信息</em>)</p>
<ul>
<li>购物车新增商品分析</li>
</ul>
<ol>
<li>判断商品是否存在</li>
<li>如果存在,把 value中的json转换成购物车对象，增加数量，写回redis</li>
<li>如果存在，根据商品id取商品信息，设置购物车数量，添加到购物车列表</li>
</ol>
<ul>
<li><p>修改购物车商品数量</p>
<ol>
<li>根据用户id，商品id从redis中取出对应的商品</li>
<li> 设置商品的数量</li>
<li> 该商品更新到redis中</li>
</ol>
</li>
<li><p>删除购物车商品</p>
<ol>
<li>获取redis中购物车</li>
<li>如果redis中已经有购物车了，判断购物车中是否存在已有商品，如果有的话则删除</li>
</ol>
</li>
<li><p>用户登录，购物车同步</p>
<ol>
<li>redis中无数据，<pre><code>     - 如果cookie中的购物车为空，那么这个时候不做任何处理
     - 如果cookie中的购物车不为空，此时直接放入redis中
</code></pre>
</li>
<li>redis中有数据，<ul>
<li>如果cookie中的购物车为空，那么直接把redis的购物车覆盖本地cookie</li>
<li>如果cookie中的购物车不为空，如果cookie中的某个商品在redis中存在，则以cookie为主，删除redis中的，把cookie中的商品直接覆盖redis中（参考京东）</li>
</ul>
</li>
<li>同步到redis中去了以后，覆盖本地cookie购物车的数据，保证本地购物车的数据是同步最新的</li>
</ol>
</li>
</ul>
<h2 id="缓存用户权限，不用每次登陆都去数据库查询"><a href="#缓存用户权限，不用每次登陆都去数据库查询" class="headerlink" title="缓存用户权限，不用每次登陆都去数据库查询"></a>缓存用户权限，不用每次登陆都去数据库查询</h2><p><a target="_blank" rel="noopener" href="http://www.macrozheng.com/#/technology/redis_permission">参考</a></p>
<h3 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h3><p>用户登录请求会经过<code>JwtAuthenticationTokenFilter </code>验证token，其中有一步会从数据库中查询登录用户信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String authHeader = request.getHeader(<span class="keyword">this</span>.tokenHeader);</span><br><span class="line">    <span class="keyword">if</span> (authHeader != <span class="keyword">null</span> &amp;&amp; authHeader.startsWith(<span class="keyword">this</span>.tokenHead)) &#123;</span><br><span class="line">        <span class="comment">// The part after &quot;Bearer &quot;</span></span><br><span class="line">        String authToken = authHeader.substring(<span class="keyword">this</span>.tokenHead.length());</span><br><span class="line">        String username = jwtTokenUtil.getUserNameFromToken(authToken);</span><br><span class="line">        log.info(<span class="string">&quot;checking username:&#123;&#125;&quot;</span>, username);</span><br><span class="line">        <span class="keyword">if</span> (username != <span class="keyword">null</span> &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//此处会从数据库中获取登录用户信息</span></span><br><span class="line">            UserDetails userDetails = <span class="keyword">this</span>.userDetailsService.loadUserByUsername(username);</span><br><span class="line">            <span class="keyword">if</span> (jwtTokenUtil.validateToken(authToken, userDetails)) &#123;</span><br><span class="line">                UsernamePasswordAuthenticationToken authentication = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(userDetails, <span class="keyword">null</span>, userDetails.getAuthorities());</span><br><span class="line">                authentication.setDetails(<span class="keyword">new</span> WebAuthenticationDetailsSource().buildDetails(request));</span><br><span class="line">                log.info(<span class="string">&quot;authenticated user:&#123;&#125;&quot;</span>, username);</span><br><span class="line">                SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问任何接口，都会从数据库中查询用户信息和用户所拥有的资源信息，每次访问接口都触发这种操作，有的时候会带来一定的性能问题。</p>
<h3 id="使用redis作为缓存"><a href="#使用redis作为缓存" class="headerlink" title="使用redis作为缓存"></a>使用redis作为缓存</h3><blockquote>
<p>主要是获取用户信息和获取用户的资源信息这两个操作。当查询数据时，先去Redis缓存中查询，如果Redis中没有，再从数据库查询，查询到以后在把数据存储到Redis中去。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UmsAdminService实现类</span></span><br><span class="line"><span class="comment"> * Created by macro on 2018/4/26.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UmsAdminServiceImpl</span> <span class="keyword">implements</span> <span class="title">UmsAdminService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//专门用来操作Redis缓存的业务类</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UmsAdminCacheService adminCacheService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UmsAdmin <span class="title">getAdminByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先从缓存中获取数据</span></span><br><span class="line">        BackendAdmin admin = adminCacheService.getAdmin(username);</span><br><span class="line">        <span class="keyword">if</span>(admin!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>  admin;</span><br><span class="line">        &#125;</span><br><span class="line">        Example example = <span class="keyword">new</span> Example(BackendAdmin.class);</span><br><span class="line">        Example.Criteria criteria = example.createCriteria();</span><br><span class="line">        criteria.andEqualTo(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line">        List&lt;BackendAdmin&gt; adminList = adminMapper.selectByExample(example);</span><br><span class="line">        <span class="keyword">if</span> (adminList != <span class="keyword">null</span> &amp;&amp; adminList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            admin = adminList.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//将数据库中的数据存入缓存中</span></span><br><span class="line">            adminCacheService.setAdmin(admin);</span><br><span class="line">            <span class="keyword">return</span> admin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;UmsResource&gt; <span class="title">getResourceList</span><span class="params">(Long adminId)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先从缓存中获取数据</span></span><br><span class="line">        List&lt;BackendResource&gt; resourceList = adminCacheService.getResourceList(adminId);</span><br><span class="line">        <span class="keyword">if</span>(CollUtil.isNotEmpty(resourceList))&#123;</span><br><span class="line">            <span class="keyword">return</span>  resourceList;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//缓存中没有从数据库中获取</span></span><br><span class="line">        resourceList = adminRoleRelationMapperCustom.getResourceList(adminId);</span><br><span class="line">        <span class="keyword">if</span>(CollUtil.isNotEmpty(resourceList))&#123;</span><br><span class="line">            <span class="comment">//将数据库中的数据存入缓存中</span></span><br><span class="line">            adminCacheService.setResourceList(adminId,resourceList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resourceList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/yuanyayuan/yymall/blob/master/mall_backend_service/src/main/java/com/nexus/mall/service/backend/BackendAdminCacheService.java">后台用户缓存操作类</a></p>
<h3 id="使用AOP处理缓存操作异常"><a href="#使用AOP处理缓存操作异常" class="headerlink" title="使用AOP处理缓存操作异常"></a>使用AOP处理缓存操作异常</h3><blockquote>
<p>为什么要用AOP来解决这个问题呢？因为我们的缓存业务类<code>UmsAdminCacheService</code>已经写好了，要保证缓存业务类中的方法执行不影响正常的业务逻辑，就需要在所有方法中添加<code>try catch</code>逻辑。使用AOP，我们可以在一个地方写上<code>try catch</code>逻辑，然后应用到所有方法上去</p>
</blockquote>
<ol>
<li><p>定义切面，在相关缓存业务类上面应用，在它的环绕通知中直接处理掉异常，保障后续操作能执行</p>
<blockquote>
<p>不过并不是所有的方法都需要处理异常的，比如我们的验证码存储，如果我们的Redis宕机了，我们的验证码存储接口需要的是报错，而不是返回执行成功。</p>
<p>对于上面这种需求我们可以通过自定义注解来完成，首先我们自定义一个<code>CacheException</code>注解，如果方法上面有这个注解，发生异常则直接抛出。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义注解，有该注解的缓存方法会抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CacheException &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(2)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * com.nexus.mall.service.backend.*CacheService.*(..)) || execution(public * com.nexus.mall.service.*CacheService.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Around(&quot;cacheAspect()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) signature;</span><br><span class="line">        Method method = methodSignature.getMethod();</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="comment">//有CacheException注解的方法需要抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(CacheException.class)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> throwable;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.error(throwable.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>接下来我们需要把<code>@CacheException</code>注解应用到存储和获取验证码的方法上去，这里需要注意的是要<strong>应用在实现类上而不是接口上，因为<code>isAnnotationPresent</code>方法只能获取到当前方法上的注解，而不能获取到它实现接口方法上的注解。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UmsMemberCacheService实现类</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/3/14.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UmsMemberCacheServiceImpl</span> <span class="keyword">implements</span> <span class="title">UmsMemberCacheService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheException</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthCode</span><span class="params">(String telephone, String authCode)</span> </span>&#123;</span><br><span class="line">        String key = REDIS_DATABASE + <span class="string">&quot;:&quot;</span> + REDIS_KEY_AUTH_CODE + <span class="string">&quot;:&quot;</span> + telephone;</span><br><span class="line">        redisService.set(key,authCode,REDIS_EXPIRE_AUTH_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheException</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAuthCode</span><span class="params">(String telephone)</span> </span>&#123;</span><br><span class="line">        String key = REDIS_DATABASE + <span class="string">&quot;:&quot;</span> + REDIS_KEY_AUTH_CODE + <span class="string">&quot;:&quot;</span> + telephone;</span><br><span class="line">        <span class="keyword">return</span> (String) redisService.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="缓存一些热点数据"><a href="#缓存一些热点数据" class="headerlink" title="缓存一些热点数据"></a>缓存一些热点数据</h2><blockquote>
<p>缓存一些不常修改但是经常被访问的数据</p>
</blockquote>
<p>缓存商品分类，并防止缓存穿透</p>
<ul>
<li>显示一级分类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 首页分类展示需求：</span></span><br><span class="line"><span class="comment">     * 1. 第一次刷新主页查询大分类，渲染展示到首页</span></span><br><span class="line"><span class="comment">     * 2. 如果鼠标上移到大分类，则加载其子分类的内容，如果已经存在子分类，则不需要加载（懒加载）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;获取商品分类(一级分类)&quot;, notes = &quot;获取商品分类(一级分类)&quot;, httpMethod = &quot;GET&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/cats&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerResponse <span class="title">cats</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//引入redis缓存</span></span><br><span class="line">    List&lt;Category&gt; list;</span><br><span class="line">    String catStr = redisOperator.get(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(catStr))&#123;</span><br><span class="line">        list = categoryService.queryAllRootLevelCat();</span><br><span class="line">        redisOperator.set(<span class="string">&quot;cat&quot;</span>, JsonUtils.objectToJson(list));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        list = JsonUtils.jsonToList(catStr, Category.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ServerResponse.success(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据一级分类id查询下一层子分类信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;根据一级分类id查询下一层子分类信息&quot;, notes = &quot;根据一级分类id查询下一层子分类信息&quot;, httpMethod = &quot;GET&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/subCat/&#123;rootCatId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerResponse <span class="title">subCat</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@ApiParam(name = &quot;rootCatId&quot;, value = &quot;一级分类id&quot;, required = true)</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@PathVariable</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NotNull(message = &quot;分类不存在&quot;)</span></span></span></span><br><span class="line"><span class="function"><span class="params">    Integer rootCatId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;CategoryVO&gt; list;</span><br><span class="line">    String subCatStr = redisOperator.get(<span class="string">&quot;subCat:&quot;</span> + rootCatId);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(subCatStr))&#123;</span><br><span class="line">        list = categoryService.getSubCatList(rootCatId);</span><br><span class="line">        <span class="comment">/* Redis 防止缓存穿透</span></span><br><span class="line"><span class="comment">              查询的key在redis中不存在，</span></span><br><span class="line"><span class="comment">              对应的id在数据库也不存在，</span></span><br><span class="line"><span class="comment">              此时被非法用户进行攻击，大量的请求会直接打在db上，</span></span><br><span class="line"><span class="comment">              造成宕机，从而影响整个系统，</span></span><br><span class="line"><span class="comment">              这种现象称之为缓存穿透。</span></span><br><span class="line"><span class="comment">              解决方案：把空的数据也缓存起来，比如空字符串，空对象，空数组或list</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            redisOperator.set(<span class="string">&quot;subCat:&quot;</span> + rootCatId, JsonUtils.objectToJson(list));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redisOperator.set(<span class="string">&quot;subCat:&quot;</span> + rootCatId, JsonUtils.objectToJson(list), <span class="number">5</span>*<span class="number">60</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        list = JsonUtils.jsonToList(subCatStr, CategoryVO.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ServerResponse.success(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/redis%E6%8C%87%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/redis%E6%8C%87%E4%BB%A4/" itemprop="url">redis指令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T16:32:25+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis知识点</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/redis-redis%E5%BA%94%E7%94%A8/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis应用</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="redis指令"><a href="#redis指令" class="headerlink" title="redis指令"></a>redis指令</h1><ul>
<li>keys *：查看所有的key (不建议在生产上使用，有性能影响)</li>
<li>type key：key的类型</li>
<li>select index：切换数据库，总共默认16个</li>
<li>flushdb：删除当前下边db中的数据</li>
<li>flushall：删除所有db中的数据</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>string: 最简单的字符串类型键值对缓存，也是最基本的</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>get/set/del：查询/设置/删除</p>
</li>
<li><p>set rekey data：设置已经存在的key，会覆盖</p>
</li>
<li><p>setnx rekey data：设置已经存在的key，不会覆盖</p>
</li>
<li><p>set key value ex time：设置带过期时间的数据</p>
</li>
<li><p>expire key：设置过期时间</p>
</li>
<li><p>ttl：查看剩余时间，-1永不过期，-2过期</p>
</li>
<li><p>append key：合并字符串</p>
</li>
<li><p>strlen key：字符串长度</p>
</li>
<li><p>incr key：累加1</p>
</li>
<li><p>decr key：类减1</p>
</li>
<li><p>incrby key num：累加给定数值</p>
</li>
<li><p>decrby key num：累减给定数值</p>
</li>
<li><p>getrange key start end：截取数据，end=-1 代表到最后</p>
</li>
<li><p>setrange key start newdata：从start位置开始替换数据</p>
</li>
<li><p>mset：连续设值</p>
</li>
<li><p>mget：连续取值</p>
</li>
<li><p>msetnx：连续设置，如果存在则不设置</p>
</li>
</ul>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><h3 id="hash-1"><a href="#hash-1" class="headerlink" title="hash"></a>hash</h3><p>hash：类似map，存储结构化数据结构，比如存储一个对象（不能有嵌套对象）</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><ul>
<li>hset key property value：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt; hset user name imooc</span><br><span class="line">-&gt; 创建一个user对象，这个对象中包含name属性，name值为imooc</span><br></pre></td></tr></table></figure></li>
<li>hget user name：获得用户对象中name的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hmset：设置对象中的多个键值对</span><br><span class="line"> -&gt; hset user age 18 phone 139123123</span><br><span class="line"> hmsetnx：设置对象中的多个键值对，存在则不添加</span><br><span class="line"> -&gt; hset user age 18 phone 139123123</span><br></pre></td></tr></table></figure></li>
<li>hmget：获得对象中的多个属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt; hmget user age phone</span><br></pre></td></tr></table></figure></li>
<li>hgetall user：获得整个对象的内容</li>
<li>hincrby user age 2：累加属性</li>
<li>hincrbyfloat user age 2.2：累加属性</li>
<li>hlen user：有多少个属性</li>
<li>hexists user age：判断属性是否存在</li>
<li>hkeys user：获得所有属性</li>
<li>hvals user：获得所有值</li>
<li>hdel user：删除对象</li>
</ul>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h3 id="list-1"><a href="#list-1" class="headerlink" title="list"></a>list</h3><p>list：列表，[a, b, c, d, …]</p>
<h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><ul>
<li>lpush userList 1 2 3 4 5：构建一个list，从左边开始存入数据</li>
<li>rpush userList 1 2 3 4 5：构建一个list，从右边开始存入数据</li>
<li>lrange list start end：获得数据</li>
<li>lpop：从左侧开始拿出一个数据</li>
<li>rpop：从右侧开始拿出一个数据</li>
<li>llen list：list长度</li>
<li>lindex list index：获取list下标的值</li>
<li>lset list index value：把某个下标的值替换</li>
<li>linsert list before/after value：插入一个新的值</li>
<li>lrem list num value：删除几个相同数据</li>
<li>ltrim list start end：截取值，替换原来的list</li>
</ul>
<h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><h3 id="sorted-set："><a href="#sorted-set：" class="headerlink" title="sorted set："></a>sorted set：</h3><p>sorted set：排序的set，可以去重可以排序，比如可以根据用户积分做排名，积分作为set的一个数值，根据数值可以做排序。set中的每一个memeber都带有一个分数</p>
<h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>zadd zset 10 value1 20 value2 30 value3：设置member和对应的分数</p>
</li>
<li><p>zrange zset 0 -1：查看所有zset中的内容</p>
</li>
<li><p>zrange zset 0 -1 withscores：带有分数</p>
</li>
<li><p>zrank zset value：获得对应的下标</p>
</li>
<li><p>zscore zset value：获得对应的分数</p>
</li>
<li><p>zcard zset：统计个数</p>
</li>
<li><p>zcount zset 分数1 分数2：统计个数</p>
</li>
<li><p>zrangebyscore zset 分数1 分数2：查询分数之间的member(包含分数1 分数2)</p>
</li>
<li><p>zrangebyscore zset (分数1 (分数2：查询分数之间的member（不包含分数1 和 分数2）</p>
</li>
<li><p>zrangebyscore zset 分数1 分数2 limit start end：查询分数之间的member(包含分数1 分数2)，获得的结果集再次根据下标区间做查询</p>
</li>
<li><p>zrem zset value：删除member</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/" itemprop="url">redis内存淘汰机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T12:46:31+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis设置过期时间"><a href="#Redis设置过期时间" class="headerlink" title="Redis设置过期时间"></a>Redis设置过期时间</h1><ul>
<li>expire key time(以秒为单位)–这是最常用的方式</li>
<li>setex(String key, int seconds, String value)–字符串独有的方式</li>
</ul>
<p>注意：</p>
<ul>
<li>除了字符串自己独有设置过期时间的方法外，其他方法都需要依靠expire方法来设置时间</li>
<li>如果没有设置时间，那缓存就是永不过期</li>
<li>如果设置了过期时间，之后又想让缓存永不过期，使用persist key</li>
</ul>
<h1 id="Redis-给缓存数据设置过期时间有啥用？"><a href="#Redis-给缓存数据设置过期时间有啥用？" class="headerlink" title="Redis 给缓存数据设置过期时间有啥用？"></a>Redis 给缓存数据设置过期时间有啥用？</h1><p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？</p>
<p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接Out of memory。</p>
<p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong></p>
<p>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在1分钟内有效，用户登录的 token 可能只在 1 天内有效。</p>
<p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p>
<h1 id="Redis是如何判断数据是否过期的呢？"><a href="#Redis是如何判断数据是否过期的呢？" class="headerlink" title="Redis是如何判断数据是否过期的呢？"></a>Redis是如何判断数据是否过期的呢？</h1><p>Redis  通过一个叫做过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个key(键)，过期字典的值是一个long long类型的整数，这个整数保存了key所指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。 </p>
<h1 id="Redis-过期键的删除策略"><a href="#Redis-过期键的删除策略" class="headerlink" title="Redis 过期键的删除策略"></a>Redis 过期键的删除策略</h1><p>A、<strong>定期删除策略</strong>。用一个<strong>定时器</strong>来负责检查 key，过期则删除 key，注意这里并不是检查所有的 key 而是<strong>随机抽取进行检查</strong>。定期策略虽然让内存及时释放，但也会<strong>额外消耗 CPU 资源</strong>，通常 CPU 应该将时间尽量用于处理业务请求，而不是删除 key。</p>
<p>B、<strong>惰性删除策略</strong>。在你<strong>获取</strong>某个 key 的时候，redis 会检查一下，这个 key <strong>如果设置了过期时间那么是否过期了</strong>，如果<strong>过期</strong>则删除该 key。</p>
<hr>
<h1 id="Redis-的回收策略（淘汰策略）"><a href="#Redis-的回收策略（淘汰策略）" class="headerlink" title="Redis 的回收策略（淘汰策略）"></a>Redis 的回收策略（淘汰策略）</h1><h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2><p>如果<strong>定期删除没删除 key</strong>，然后也<strong>没及时去请求 key</strong>，即<strong>惰性删除也没生效</strong>，持续下去 redis 的内存会越来越高，当超过 redis 设置的内存最大使用量时，就会进行内存数据淘汰。redis 有 6 种淘汰策略：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>volatile-lru</td>
<td>从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td>volatile-ttl</td>
<td>从已设置过期时间的数据集中挑选将要过期的数据淘汰</td>
</tr>
<tr>
<td>volatile-random</td>
<td>从已设置过期时间的数据集中任意选择数据淘汰</td>
</tr>
<tr>
<td>allkeys-lru</td>
<td>从所有数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td>allkeys-random</td>
<td>从所有数据集中任意选择数据进行淘汰</td>
</tr>
<tr>
<td>noeviction</td>
<td>当内存不足以容纳新写入数据时，新写入操作会报错。很少使用</td>
</tr>
</tbody></table>
<blockquote>
<p>注意这里的 6 种机制，前缀 volatile 和 allkeys 用于区分淘汰数据的数据集是从已设置过期时间的数据集还是从全部数据集中选取，后面的 lru、ttl 以及 random 是三种不同的淘汰策略，再加上一种 no-enviction 永不回收的策略。其中最常使用的是 volatile-lru/allkeys-lru。</p>
</blockquote>
<ul>
<li>allkeys-lru：如果期望用户请求呈现幂律分布(power-law distribution)，也就是，期望一部分子集元素被访问得远比其他元素多时，可以使用allkeys-lru策略。在你不确定时这是一个好的选择</li>
<li>allkeys-random：如果期望是循环周期的访问，所有的键被连续扫描，或者期望请求符合平均分布(每个元素以相同的概率被访问)，可以使用allkeys-random策略。</li>
<li>volatile-ttl：如果你期望能让 Redis 通过使用你创建缓存对象的时候设置的TTL值，确定哪些对象应该是较好的清除候选项，可以使用volatile-ttl策略。</li>
</ul>
<p>另外值得注意的是，为键设置过期时间需要消耗内存，所以使用像allkeys-lru这样的策略会更高效，因为在内存压力下没有必要为键的回收设置过期时间。</p>
<h2 id="常用缓存数据淘汰策略"><a href="#常用缓存数据淘汰策略" class="headerlink" title="常用缓存数据淘汰策略"></a>常用缓存数据淘汰策略</h2><ul>
<li>FIFO（First In First Out）： 先进先出算法，即先放入缓存的先被移除。</li>
<li>LRU（Least Recently Used）： 最近最少使用算法，使用时间距离现在最久的那个被移除。</li>
<li>LFU（Least Frequently Used）： 最不常用算法，一定时间段内使用次数（频率）最少的那个被移除。</li>
</ul>
<h2 id="缓存数据更新策略"><a href="#缓存数据更新策略" class="headerlink" title="缓存数据更新策略"></a>缓存数据更新策略</h2><ul>
<li>定时任务从数据库直接更新缓存：适用于对时间不敏感的数据。</li>
<li>查询时写缓存，即查询优先查询缓存，若缓存未命中，查询数据库，将返回结果写入缓存，数据更新时先 delete缓存，再更新缓存。</li>
<li>MQ 消息异步更新缓存。</li>
</ul>
<h1 id="Redis采用的过期策略"><a href="#Redis采用的过期策略" class="headerlink" title="Redis采用的过期策略"></a>Redis采用的过期策略</h1><p>惰性删除+定期删除</p>
<ul>
<li>惰性删除流程<ul>
<li>在进行get或setnx等操作时，先检查key是否过期，</li>
<li>若过期，删除key，然后执行相应操作；</li>
<li>若没过期，直接执行相应操作</li>
</ul>
</li>
<li>定期删除流程（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）<ul>
<li>遍历每个数据库（就是redis.conf中配置的”database”数量，默认为16）<ul>
<li>检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）<ul>
<li>如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历</li>
<li>随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key</li>
<li>判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" itemprop="url">redis线程模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T01:19:02+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis单线程原理"><a href="#Redis单线程原理" class="headerlink" title="Redis单线程原理"></a>Redis单线程原理</h1><p>Redis是单进程，Redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。</p>
<h1 id="Redis的线程模型"><a href="#Redis的线程模型" class="headerlink" title="Redis的线程模型"></a>Redis的线程模型</h1><p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="image"></p>
<p><strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型</strong>，Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接， <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">多个 socket（客户端连接）</span><br><span class="line">IO 多路复用程序（支持多个客户端连接的关键）</span><br><span class="line">文件事件分派器（将 socket 关联到相应的事件处理器）</span><br><span class="line">事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</span><br></pre></td></tr></table></figure>

<h2 id="Redis-单线程模型详解"><a href="#Redis-单线程模型详解" class="headerlink" title="Redis 单线程模型详解"></a>Redis 单线程模型详解</h2><p><strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型</strong>，Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接， <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong></p>
<p>主要是包含 4 个部分：</p>
<ul>
<li>多个 socket（客户端连接）</li>
<li>IO 多路复用程序（支持多个客户端连接的关键）</li>
<li>文件事件分派器（将 socket 关联到相应的事件处理器）</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<h1 id="Redis-是单进程单线程的吗？为何它那么快那么高效？"><a href="#Redis-是单进程单线程的吗？为何它那么快那么高效？" class="headerlink" title="Redis 是单进程单线程的吗？为何它那么快那么高效？"></a>Redis 是单进程单线程的吗？为何它那么快那么高效？</h1><h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>Redis是单线程的，redis 利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。</p>
<h2 id="速度快"><a href="#速度快" class="headerlink" title="速度快"></a>速度快</h2><p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p>
<p>2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p>
<p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p>
<p>4、使用多路I/O复用模型，非阻塞IO；</p>
<p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p>
<hr>
<h1 id="redis为什么不采用多线程处理"><a href="#redis为什么不采用多线程处理" class="headerlink" title="redis为什么不采用多线程处理"></a>redis为什么不采用多线程处理</h1><ol>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的性能瓶颈不再 CPU ，主要在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ol>
<h2 id="Redis6-0-之后为何引入了多线程"><a href="#Redis6-0-之后为何引入了多线程" class="headerlink" title="Redis6.0 之后为何引入了多线程"></a>Redis6.0 之后为何引入了多线程</h2><p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了， 执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</p>
<h1 id="单线程处理的缺点？"><a href="#单线程处理的缺点？" class="headerlink" title="单线程处理的缺点？"></a>单线程处理的缺点？</h1><p>1.耗时的命令会导致并发的下降，不只是读并发，写并发也会下降</p>
<p>2.无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url">redis数据结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T01:18:46+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis知识点</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/redis-redis%E5%BA%94%E7%94%A8/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis应用</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis-的数据类型？"><a href="#Redis-的数据类型？" class="headerlink" title="Redis 的数据类型？"></a>Redis 的数据类型？</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>键(key)——值(value) (字符串格式)</p>
<h4 id="动态字符串（Redis字符串的实现方式）"><a href="#动态字符串（Redis字符串的实现方式）" class="headerlink" title="动态字符串（Redis字符串的实现方式）"></a>动态字符串（Redis字符串的实现方式）</h4><p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * 保存字符串对象的结构  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span>  </span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度  </span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// buf 中剩余可用空间的长度  </span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;  </span><br><span class="line">    <span class="comment">// 数据空间  </span></span><br><span class="line">    <span class="keyword">char</span> buf[];  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>len 变量，用于记录buf 中已经使用的空间长度。</li>
<li>free 变量，用于记录buf 中还空余的空间，初次分配空间，一般没有空余，在对字符串修改的时候，会有剩余空间出现，这样做是为了杜绝C语言中缓冲区溢出的可能性，当我们需要对一个SDS进行修改的时候，Redis 会在执行拼接操作之前，预先检查给定SDS空间是否足够，如果不够，会先拓展SDS的空间，然后再执行拼接操作。</li>
<li>buf 字符数组，用于记录我们的字符串（记录Redis）。</li>
</ol>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>字符串拥有一些操作命令，如：</p>
<ul>
<li>get 获取值</li>
<li>set key value设置值</li>
<li>del 删除</li>
<li>incr key 加一</li>
<li>decr key 减一</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><p>计数器 string类型的<code>incr</code>和<code>decr</code>命令的作用是将key中储存的数字值<strong>加一/减一</strong>，这两个操作具有原子性，总能安全地进行加减操作</p>
<p> 因此可以用string类型进行计数，如微博的评论数、点赞数、分享数，抖音作品的收藏数，京东商品的销售量、评价数等。</p>
</li>
<li><p>分布式锁 String类型的<code>setnx</code>的作用是<strong>当key不存在时，设值并返回1，当key已经存在时，不设值并返回0</strong>，<strong>判断key是否存在</strong>和<strong>设值</strong>两个操作是原子性地执行的，因此可以用string类型作为分布式锁，返回1表示获得锁，返回0表示没有获得锁。</p>
<p> 例如，为了保证定时任务的高可用，往往会同时部署多个具备相同定时任务的服务，但是业务上只希望其中的某一台服务执行定时任务，当定时任务的时间点触发时，多个服务同时竞争一个分布式锁，获取到锁的执行定时任务，没获取到的放弃执行定时任务。</p>
<p> 定时任务执行完时通过del命令删除key即释放锁，如果担心del命令操作失败而导致锁一直未释放，可以通过expire命令给锁设置一个合理的自动过期时间，确保即使del命令失败，锁也能被释放。不过expire命令同样存在失败的可能性，如果你用的是Java语言，建议使用JedisCommands接口提供的<code>String set(String key, String value, String nxxx, String expx, long time)</code>方法，这个方法可以将setnx和expire原子性地执行，具体使用方式如下（相信其它语言的Redis客户端也应当提供了类似的方法）。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jedisCommands.set(<span class="string">&quot;IAmAKey&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, <span class="number">60</span>);<span class="comment">//如果&quot;IAmAKey&quot;不存	 在，则将其设值为1，同时设置60秒的自动过期时间</span></span><br></pre></td></tr></table></figure></li>
<li><p>限流</p>
</li>
<li><p>分布式Session</p>
</li>
<li><p>存储对象 利用JSON强大的兼容性、可读性和易用性，将对象转换为JSON字符串，再存储在string类型中，是个不错的选择，如用户信息、商品信息等。</p>
</li>
</ol>
<h2 id="列表-List"><a href="#列表-List" class="headerlink" title="列表(List)"></a>列表(List)</h2><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p>一个列表结构可以有序地存储多个字符串</p>
<h4 id="链表数据结构，List-底层结构"><a href="#链表数据结构，List-底层结构" class="headerlink" title="链表数据结构，List 底层结构"></a>链表数据结构，List 底层结构</h4><p>链表还是常规的普通双端链表，可以支持反向查找和遍历，更方便操作，通过增删节点来灵活地调整链表的长度，双端链表在Redis内部也是被多次使用：</p>
<ol>
<li>事务模块使用双端链表依序保存输入的命令。</li>
<li>服务器模块使用双端链表来保存多个客户端。</li>
<li>订阅/发送模块使用双端链表来保存订阅模式的多个客户端。</li>
<li>事件模块使用双端链表来保存时间事件（time event）。</li>
</ol>
<h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><ul>
<li>lpush list a b c d (从左添加元素)</li>
<li>rpush list 1 2 3 4 (从右边添加元素)</li>
<li>lrange list 0 -1 (从0 到 -1 元素查看：也就表示查看所有)</li>
<li>lpop list （从左边取，删除）</li>
<li>rpop list (从右边取，删除)</li>
</ul>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><p>消息队列 list类型的lpop和rpush（或者反过来，lpush和rpop）能实现队列的功能，故而可以用Redis的list类型实现简单的点对点的消息队列，但有更好的rabbitmq和kafka</p>
</li>
<li><p>排行榜 list类型的lrange命令可以分页查看队列中的数据。可将每隔一段时间计算一次的排行榜存储在list类型中，如京东每日的手机销量排行、学校每次月考学生的成绩排名、斗鱼年终盛典主播排名等。</p>
</li>
</ol>
<blockquote>
<p>排行榜，每日计算一次，存储在list类型中，接口访问时，通过page和size分页获取 </p>
</blockquote>
<img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/QQ%E9%9F%B3%E4%B9%90%E6%8E%92%E8%A1%8C%E6%A6%9C.png" style="zoom:50%;" />

<blockquote>
<p>但是，并不是所有的排行榜都能用list类型实现，只有定时计算的排行榜才适合使用list类型存储，与定时计算的排行榜相对应的是实时计算的排行榜，list类型不能支持实时计算的排行榜，实时计算的排行榜使用有序集合sorted set实现。</p>
</blockquote>
<ol start="3">
<li>最新列表 list类型的lpush命令和lrange命令能实现最新列表的功能，每次通过lpush命令往列表里插入新的元素，然后通过lrange命令读取最新的元素列表，如朋友圈的点赞列表、评论列表。</li>
</ol>
<blockquote>
<p>但是，并不是所有的最新列表都能用list类型实现， 因为对于频繁更新的列表，list类型的分页可能导致列表元素重复或漏掉 ，举个例子，当前列表里由表头到表尾依次有（E，D，C，B，A）五个元素， 每页获取3个元素，用户第一次获取到（E，D，C）三个元素，然后表头新增了一个元素F， 列表变成了（F，E，D，C，B，A），此时用户取第二页拿到（C，B，A）， 元素C重复了。</p>
</blockquote>
<h4 id="list和sorted-set"><a href="#list和sorted-set" class="headerlink" title="list和sorted set"></a>list和sorted set</h4><ul>
<li><p>只有不需要分页（比如每次都只取列表的前5个元素）或者更新频率低（比如每天凌晨更新一次）的列表才适合用list类型实现。</p>
</li>
<li><p>对于需要分页并且会频繁更新的列表，需用使用有序集合sorted set类型实现。</p>
</li>
<li><p>需要通过时间范围查找的最新列表，list类型也实现不了，也需要通过有序集合sorted set类型实现，如以成交时间范围作为条件来查询的订单列表。</p>
</li>
</ul>
<h5 id="如何选用"><a href="#如何选用" class="headerlink" title="如何选用"></a>如何选用</h5><blockquote>
<p>对于排行榜和最新列表两种应用场景，那为什么还要使用list类型去实现排行榜或最新列表呢，直接用sorted set类型不是更好吗？</p>
</blockquote>
<p>原因是sorted <strong>set类型占用的内存容量是list类型的数倍之多</strong>，对于<strong>列表数量不多</strong>的情况，可以用sorted set类型来实现，比如上文中举例的打擂金曲排行榜，每天全国只有一份，两种数据类型的内存容量差距可以忽略不计，但是如果要实现某首歌曲的翻唱作品地区排行榜，数百万的歌曲，300多个地区，会产生数量庞大的榜单，或者数量更加庞大的朋友圈点赞列表，就需要慎重地考虑容量的问题了</p>
<h2 id="hash类型"><a href="#hash类型" class="headerlink" title="hash类型"></a>hash类型</h2><h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p>hash类型是一个string类型的field和value的映射表</p>
<h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><ul>
<li>hdel (HDEL key field1 [field2]) 删除一个或多个哈希表字段</li>
<li>hlen</li>
<li>hgetall</li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-hashes.html">更多方法</a></li>
</ul>
<h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h4><p>以用户id为key，商品id为field，商品数量为value，恰好构成了购物车的3个要素，如下图所示。</p>
<img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/%E8%B4%AD%E7%89%A9%E8%BD%A6.png" style="zoom:50%;" />

<h4 id="存储对象"><a href="#存储对象" class="headerlink" title="存储对象"></a>存储对象</h4><p>存储对象 hash类型的(key, field, value)的结构与对象的(对象id, 属性, 值)的结构相似，也可以用来存储对象。</p>
<h5 id="存储对象时，到底用string-json还是用hash"><a href="#存储对象时，到底用string-json还是用hash" class="headerlink" title="存储对象时，到底用string + json还是用hash"></a>存储对象时，到底用string + json还是用hash</h5><p>两种存储方式的对比如下表所示。</p>
<table>
<thead>
<tr>
<th></th>
<th>string + json</th>
<th>hash</th>
</tr>
</thead>
<tbody><tr>
<td>效率</td>
<td>很高</td>
<td>高</td>
</tr>
<tr>
<td>容量</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td>灵活性</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>序列化</td>
<td>简单</td>
<td>复杂</td>
</tr>
</tbody></table>
<ul>
<li>当对象的某个属性需要频繁修改时，不适合用string+json，因为它不够灵活，每次修改都需要重新将整个对象序列化并赋值</li>
<li>如果使用hash类型，则可以针对某个属性单独修改，没有序列化，也不需要修改整个对象。比如，商品的价格、销量、关注数、评价数等可能经常发生变化的属性，就适合存储在hash类型里。</li>
</ul>
<p>当然，不常变化的属性存储在hash类型里也没有问题，比如商品名称、商品描述、上市日期等。但是，当对象的某个属性<strong>不是基本类型或字符串时</strong>，使用hash类型就必须手动进行复杂序列化</p>
<p>比如，商品的标签是一个标签对象的列表，商品可领取的优惠券是一个优惠券对象的列表（如下图所示）等，即使以coupons（优惠券）作为field，value想存储优惠券对象列表也还是要使用json来序列化，这样的话序列化工作就太繁琐了，不如直接用string + json的方式存储商品信息来的简单。 </p>
<img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/%E4%BC%98%E6%83%A0%E5%8D%B7.png" style="zoom:33%;" />

<p><strong>综上，一般对象用string+json存储，对象中某些频繁变化的基本类型或字符串的属性抽出来用hash存储。</strong></p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p>set类型是string类型的集合，其特点是集合元素无序且不重复</p>
<h3 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h3><ul>
<li>SINTER KEY KEY1..KEYN 回给定所有给定集合的交集</li>
<li>SISMEMBER KEY VALUE 判断成员元素是否是集合的成员</li>
<li>SCARD KEY_NAME 返回集合中元素的数量</li>
<li>SMOVE SOURCE DESTINATION MEMBER 命令将指定成员 member 元素从 source 集合移动到 destination 集合。</li>
<li>SRANDMEMBER KEY [count] 用于返回集合中的一个随机元素。</li>
</ul>
<h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><p>好友/关注/粉丝/感兴趣的人集合</p>
<p>set类型唯一的特点使得其适合用于存储好友/关注/粉丝/感兴趣的人集合，集合中的元素数量可能很多，每次全部取出来成本不小，set类型提供了一些很实用的命令用于直接操作这些集合</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. sinter命令可以获得A和B两个用户的共同好友</span><br><span class="line">2. sismember命令可以判断A是否是B的好友</span><br><span class="line">3. scard命令可以获取好友数量</span><br><span class="line">4. 关注时，smove命令可以将B从A的粉丝集合转移到A的好友集合</span><br></pre></td></tr></table></figure>
<p><strong>需要注意</strong>:</p>
<p>如果你用的是<strong>Redis Cluster集群</strong>，对于<strong>sinter、smove这种操作     多个key的命令</strong>，要求这两个key必须存储在<strong>同一个slot（槽位）中</strong>，否则会报出<code>(error) CROSSSLOT Keys in request don&#39;t hash to the same slot </code>错误。</p>
<p>Redis Cluster一共有<strong>16384</strong>个slot，每个key都是通过哈希算法CRC16(key)获取数值哈希，再模16384来定位slot的。要使得两个key处于同一slot，除了两个key一模一样，还有没有别的方法呢？</p>
<p>Redis提供了一种<strong>Hash Tag</strong>的功能，在key中使用<code>&#123;&#125;</code>括起key中的一部分，在进行<code>CRC16(key) mod 16384</code>的过程中，只会对<code>&#123;&#125;</code>内的字符串计算，例如<strong>friend_set:{123456}<strong>和</strong>fans_set:{123456}<strong>，分别表示</strong>用户123456</strong>的<strong>好友集合</strong>和<strong>粉丝集合</strong>，在定位slot时，只对<code>&#123;&#125;</code>内的<code>123456</code>进行计算，所以这两个集合肯定是在同一个slot内的，当用户123456关注某个粉丝时，就可以通过smove命令将这个粉丝从用户123456的粉丝集合移动到好友集合。</p>
<p>相比于通过srem命令先将这个粉丝从粉丝集合中删除，再通过sadd命令将这个粉丝加到好友集合，smove命令的优势是它是<strong>原子性</strong>的，不会出现这个粉丝从粉丝集合中被删除，却没有加到好友集合的情况。</p>
<p>然而，对于通过sinter获取共同好友而言，Hash Tag则无能为力，例如，要用sinter去获取<strong>用户123456</strong>和<strong>用户456789</strong>两个用户的共同好友，除非我们将key定义为**{friend_set}:123456<strong>和</strong>{friend_set}:456789**，否则不能保证两个key会处于同一个slot，但是如果真这样做的话，所有用户的好友集合都会堆积在同一个slot中，数据分布会严重不均匀，不可取，</p>
<p><strong>所以，在实战中使用Redis Cluster时，sinter这个命令其实是不适合作用于两个不同用户对应的集合的（同理其它操作多个key的命令）。</strong></p>
</li>
<li><p>随机展示 通常，app首页的展示区域有限，但是又不能总是展示固定的内容，一种做法是先确定一批需要展示的内容，再从中随机获取。如下图所示，酷狗音乐K歌擂台赛当日的打擂歌曲共29首，首页随机展示5首；昨日打擂金曲共200首，首页随机展示30首。</p>
</li>
</ol>
<img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/%E6%89%93%E6%93%82.png" style="zoom:33%;" />

<p>set类型适合存放所有需要展示的内容，而<code>srandmember</code>命令则可以从中随机获取几个。</p>
<h2 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted set"></a>sorted set</h2><h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员</p>
<p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p><strong>有序集合的成员是唯一的</strong>,但分数(score)却可以重复。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。</p>
<h4 id="跳跃表，sorted-set底层结构"><a href="#跳跃表，sorted-set底层结构" class="headerlink" title="跳跃表，sorted set底层结构"></a>跳跃表，sorted set底层结构</h4><p>Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，（如果你还不了解红黑树，需要先额外补补功课），HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score，使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。</p>
<p>那为什么Redis的作者使用 SkipList 结构而不是红黑树？</p>
<ul>
<li>红黑树：红黑树的查找效率很高，但是在进行重新平衡时，会涉及到大量节点的变化，因此实现和操作起来都比较复杂。</li>
<li>跳跃表：通过简单的多层索引结构，实现简单，且能达到近似于红黑树的查找效率，插入节点（多层插入）不需要像红黑树那样有额外操作。而且跳跃表还能实现范围查找及输出，而红黑树只支持单个元素查找，对于范围查找效率低。</li>
</ul>
<h3 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h3><ol>
<li>Zadd</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD KEY_NAME SCORE1 VALUE1.. SCOREN VALUEN</span><br></pre></td></tr></table></figure>

<ol>
<li>Zincrby 对有序集合中指定成员的分数加上增量 increment</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY key increment member</span><br></pre></td></tr></table></figure>

<ol>
<li>Zrange 返回有序集中，指定区间内的成员</li>
</ol>
<p>其中成员的位置按分数值递增(从小到大)来排序。 具有相同分数值的成员按字典序(lexicographical order )来排列。</p>
<p><strong>下标参数</strong> start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。</p>
<p>你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure>

<ol>
<li>Zrevrange 命令返回有序集中，指定区间内的成员。</li>
</ol>
<p><strong>下标参数</strong> start 和 stop 其中成员的位置按分数值递减(从大到小)来排列。 具有相同分数值的成员按字典序的逆序(reverse lexicographical order)排列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure>

<ol>
<li>Zrem 命令用于移除有序集中的一个或多个成员，不存在的成员将被忽略。 当 key 存在但不是有序集类型时，返回一个错误。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREM key member [member ...]</span><br></pre></td></tr></table></figure>

<ol>
<li>Zcard 命令用于计算集合中元素的数量。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCARD KEY_NAME</span><br></pre></td></tr></table></figure>

<ol>
<li></li>
</ol>
<p>Zrangebyscore 返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)次序排列。</p>
<p>具有相同分数值的成员按字典序来排列(该属性是有序集提供的，不需要额外的计算)。</p>
<p>默认情况下，<strong>区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br></pre></td></tr></table></figure>

<ul>
<li>ZRANGEBYSCORE zset (1 5 == 1 &lt; score &lt;= 5</li>
<li>ZRANGEBYSCORE zset (5 (10 == 5 &lt; score &lt; 10</li>
<li>ZRANGEBYSCORE salary -inf +inf # 显示整个有序集</li>
<li>ZRANGEBYSCORE salary -inf +inf WITHSCORES #显示整个有序集及成员的 score 值</li>
<li>ZRANGEBYSCORE salary -inf 5000 WITHSCORES # 显示工资 &lt;=5000 的所有成员</li>
<li>ZRANGEBYSCORE salary (5000 400000 # 显示工资大于 5000 小于等于 400000 的成员</li>
</ul>
<ol>
<li>Zrevrangebyscore 返回有序集中指定分数区间内的所有的成员。有序集成员按分数值递减(从大到小)的次序排列。 具有相同分数值的成员按字典序的逆序(reverse lexicographical order )排列。</li>
<li>Zcount 命令用于计算有序集合中指定分数区间的成员数量。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCOUNT key min max</span><br></pre></td></tr></table></figure>

<h3 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>游戏排名</li>
<li>微博热点话题</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/03/31/hashmap%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/31/hashmap%E5%AD%A6%E4%B9%A0/" itemprop="url">hashmap学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-31T22:36:51+08:00">
                2021-03-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80-Java%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础 - Java容器</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <!--<a href="/archives/%7C%7Carchive">-->
                <a href="/archives/">
              
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuanyayuan" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:liyuan0707@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LiYuan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
