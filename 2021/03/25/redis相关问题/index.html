<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="redis,面试," />










<meta name="description" content="什么是 Redis? 内存数据库，速度快，也支持数据的持久化 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案 Redis 除了做缓存之外，Redis也经常用来做分布式锁，甚至是消息队列。  Red">
<meta property="og:type" content="article">
<meta property="og:title" content="redis相关问题">
<meta property="og:url" content="https://yuanyayuan.github.io/2021/03/25/redis%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/index.html">
<meta property="og:site_name" content="Hikari的Java之路">
<meta property="og:description" content="什么是 Redis? 内存数据库，速度快，也支持数据的持久化 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案 Redis 除了做缓存之外，Redis也经常用来做分布式锁，甚至是消息队列。  Red">
<meta property="og:locale">
<meta property="og:image" content="https://nexus-oss-test.oss-cn-shanghai.aliyuncs.com/redis%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6.png">
<meta property="og:image" content="https://nexus-oss-test.oss-cn-shanghai.aliyuncs.com/%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5.png">
<meta property="og:image" content="https://nexus-oss-test.oss-cn-shanghai.aliyuncs.com/Redis%E6%97%A0%E7%A3%81%E7%9B%98%E5%8C%96%E5%A4%8D%E5%88%B6.png">
<meta property="og:image" content="https://nexus-oss-test.oss-cn-shanghai.aliyuncs.com/Master-Slaver%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F.png">
<meta property="og:image" content="https://nexus-oss-test.oss-cn-shanghai.aliyuncs.com/Sentinel%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.png">
<meta property="og:image" content="https://nexus-oss-test.oss-cn-shanghai.aliyuncs.com/Cluster%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F.png">
<meta property="article:published_time" content="2021-03-25T14:32:27.000Z">
<meta property="article:modified_time" content="2021-03-25T14:37:44.061Z">
<meta property="article:author" content="LiYuan">
<meta property="article:tag" content="redis">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nexus-oss-test.oss-cn-shanghai.aliyuncs.com/redis%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yuanyayuan.github.io/2021/03/25/redis相关问题/"/>





  <title>redis相关问题 | Hikari的Java之路</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hikari的Java之路</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Hello,world</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/03/25/redis%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">redis相关问题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-25T22:32:27+08:00">
                2021-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis理论知识</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="什么是-Redis"><a href="#什么是-Redis" class="headerlink" title="什么是 Redis?"></a>什么是 Redis?</h1><ul>
<li>内存数据库，速度快，也支持数据的持久化</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案</li>
<li>Redis 除了做缓存之外，Redis也经常用来做分布式锁，甚至是消息队列。</li>
</ul>
<h1 id="Redis的key和value大小限制"><a href="#Redis的key和value大小限制" class="headerlink" title="Redis的key和value大小限制"></a>Redis的key和value大小限制</h1><p>redis的key和string类型value限制均为512MB。</p>
<hr>
<h1 id="Redis服务器和客户端的通信"><a href="#Redis服务器和客户端的通信" class="headerlink" title="Redis服务器和客户端的通信"></a>Redis服务器和客户端的通信</h1><p>Redis客户端使用RESP（Redis序列化协议）与Redis服务器进行通信</p>
<hr>
<h1 id="使用-Redis-有哪些好处？"><a href="#使用-Redis-有哪些好处？" class="headerlink" title="使用 Redis 有哪些好处？"></a>使用 Redis 有哪些好处？</h1><p>（1）速度快，因为数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O1)</p>
<p>（2）支持丰富数据类型，支持 string，list，set，Zset，hash 等</p>
<p>（3）支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</p>
<p>（4）丰富的特性：可用于缓存，消息，按 key 设置过期时间，过期后将会自动删除</p>
<hr>
<h1 id="Redis如何解决key冲突？"><a href="#Redis如何解决key冲突？" class="headerlink" title="Redis如何解决key冲突？"></a>Redis如何解决key冲突？</h1><p>拉链法。这个问题可以考虑到另一个问题，HashMap是如何解决key冲突的，同样也是采用拉链地址法。如果被问到解决key值冲突还有什么方法？一般来说解决key值冲突的方法有俩种，一种是开放地址法，另一种就是拉链法。</p>
<hr>
<h1 id="缓存数据的处理流程是怎样的？"><a href="#缓存数据的处理流程是怎样的？" class="headerlink" title="缓存数据的处理流程是怎样的？"></a>缓存数据的处理流程是怎样的？</h1><ol>
<li>如果用户请求的数据在缓存中就直接返回。</li>
<li>缓存中不存在的话就看数据库中是否存在。</li>
<li>数据库中存在的话就更新缓存中的数据。</li>
<li>数据库中不存在的话就返回空数据。</li>
</ol>
<h1 id="为什么选择redis"><a href="#为什么选择redis" class="headerlink" title="为什么选择redis"></a>为什么选择redis</h1><p>磁盘IO及网络开销是直接请求内存IO千百上千倍，通过缓存技术，减少数据传输时间，提高处理效率</p>
<ul>
<li>首先 Redis 支持丰富的数据结构，新版本数据结构从最初的5种变成9种。</li>
<li>其次 Redis 是读写单进程单线程，不用考虑并发读写的复杂场景，速度也快。</li>
<li>Reids 功能完备，支持数据持久化，支持主从复制和集群。</li>
<li>还有Lua脚本，事务，发布订阅模型，Reids 都支持。</li>
</ul>
<hr>
<h1 id="Memcached-与-Redis-的区别都有哪些？"><a href="#Memcached-与-Redis-的区别都有哪些？" class="headerlink" title="Memcached 与 Redis 的区别都有哪些？"></a>Memcached 与 Redis 的区别都有哪些？</h1><ol>
<li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。</li>
<li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中。</strong></li>
<li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li>
<li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li>
<li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的.</strong></li>
<li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 引入了多线程 IO ）</li>
<li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li>
<li><strong>Memcached过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></li>
</ol>
<h1 id="Redis相比Memcached有哪些优势"><a href="#Redis相比Memcached有哪些优势" class="headerlink" title="Redis相比Memcached有哪些优势"></a>Redis相比Memcached有哪些优势</h1><ol>
<li>Memcached所有的值均是简单的字符串，redis作为其代替者，支持更为丰富的数据类型</li>
<li>Redis的速度比Memcached快得多</li>
<li>Redis可以持久化数据</li>
</ol>
<hr>
<h1 id="Redis单线程原理"><a href="#Redis单线程原理" class="headerlink" title="Redis单线程原理"></a>Redis单线程原理</h1><p>Redis是单进程，Redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。</p>
<h2 id="Redis-单线程模型详解"><a href="#Redis-单线程模型详解" class="headerlink" title="Redis 单线程模型详解"></a>Redis 单线程模型详解</h2><p><strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型</strong>，Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接， <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong></p>
<p>主要是包含 4 个部分：</p>
<ul>
<li>多个 socket（客户端连接）</li>
<li>IO 多路复用程序（支持多个客户端连接的关键）</li>
<li>文件事件分派器（将 socket 关联到相应的事件处理器）</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<h1 id="Redis-是单进程单线程的吗？为何它那么快那么高效？"><a href="#Redis-是单进程单线程的吗？为何它那么快那么高效？" class="headerlink" title="Redis 是单进程单线程的吗？为何它那么快那么高效？"></a>Redis 是单进程单线程的吗？为何它那么快那么高效？</h1><h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>Redis是单线程的，redis 利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。</p>
<h2 id="速度快"><a href="#速度快" class="headerlink" title="速度快"></a>速度快</h2><p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p>
<p>2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p>
<p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p>
<p>4、使用多路I/O复用模型，非阻塞IO；</p>
<p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p>
<hr>
<h1 id="redis为什么不采用多线程处理"><a href="#redis为什么不采用多线程处理" class="headerlink" title="redis为什么不采用多线程处理"></a>redis为什么不采用多线程处理</h1><ol>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的性能瓶颈不再 CPU ，主要在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ol>
<h2 id="Redis6-0-之后为何引入了多线程"><a href="#Redis6-0-之后为何引入了多线程" class="headerlink" title="Redis6.0 之后为何引入了多线程"></a>Redis6.0 之后为何引入了多线程</h2><p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了， 执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</p>
<h1 id="单线程处理的缺点？"><a href="#单线程处理的缺点？" class="headerlink" title="单线程处理的缺点？"></a>单线程处理的缺点？</h1><p>1.耗时的命令会导致并发的下降，不只是读并发，写并发也会下降</p>
<p>2.无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善</p>
<h1 id="Redis-的持久化机制是什么？各自的优缺点？"><a href="#Redis-的持久化机制是什么？各自的优缺点？" class="headerlink" title="Redis 的持久化机制是什么？各自的优缺点？"></a>Redis 的持久化机制是什么？各自的优缺点？</h1><p>redis 提供两种持久化方式。</p>
<p>一种是 <strong>RDB（Redis DataBase）</strong>，用数据集快照的方式，定时将 redis 存储的数据生成快照并存储到磁盘等介质上即在指定目录下生成一个 dump.rdb 文件；</p>
<p>Redis 提供了 SAVE 和BGSAVE两个命令来生成RDB文件，区别是前者是阻塞的，后者是后台 fork 子进程进行，不会阻塞主进程处理命令请求</p>
<p>持久化key之前，会检查是否过期，过期的key不进入RDB文件。数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）。</p>
<p>另外一种是 <strong>AOF（Append -only file）</strong>，Redis默认不开启，它采用日志的形式来记录每个写操作，生成一个appendonly.aof 文件，并将日志追加到文件末尾。Redis重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<p>重写时，会先判断key是否过期，已过期的key不会重写到aof文件。</p>
<p>如果同时存在<code>RDB</code>和<code>AOF</code>的话会优先使用<code>AOF</code> 重建数据集，因为其保存的数据更完整。</p>
<h2 id="RDB-的优点："><a href="#RDB-的优点：" class="headerlink" title="RDB 的优点："></a>RDB 的优点：</h2><p>A 特别适合备份；</p>
<p>B. 性能最大化，fork 子进程来完成写操作，让主进程继续处理命令且不会进行任何 IO 操作的，这样就确保了 redis 极高的性能；</p>
<p>C. 相对于数据集大时，比 AOF 的启动效率更高。</p>
<h2 id="RDB-的缺点："><a href="#RDB-的缺点：" class="headerlink" title="RDB 的缺点："></a>RDB 的缺点：</h2><p>数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发 生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候；</p>
<p>备份时占用内存，因为Redis在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍），最后再将临时文件替换之前的备份文件</p>
<h2 id="AOF-的优点："><a href="#AOF-的优点：" class="headerlink" title="AOF 的优点："></a>AOF 的优点：</h2><p>A. 数据安全，aof 持久化可以配置 append fsync 属性，比如无 fsync，每秒钟一次 fsync，或者每次执行写入命令时 fsync，一般只会丢失一秒钟的数据，或者最后一次执行的数据，对缓存来说，这已经足够。<br>B. 某些场景下还可以恢复数据。比如说某同学在操作 redis 时，不小心执行了 FLUSHALL，导致 redis 内存中的数据全部被清空了。如果 AOF 文件还没有被重写（rewrite），我们就可以用最快的速度暂停 redis 并编辑 AOF 文件，将最后一行的 FLUSHALL 命令删除，然后重启 redis，就可以恢复 redis 的所有数据到 FLUSHALL 之前的状态了。</p>
<h2 id="AOF-的缺点："><a href="#AOF-的缺点：" class="headerlink" title="AOF 的缺点："></a>AOF 的缺点：</h2><p>A. AOF 文件比 RDB 文件大，且根据不同的 fsync 策略，其恢复速度可能较慢；</p>
<p>B 数据集大的时候，比 rdb 启动效率低。</p>
<h2 id="RDB-和-AOF-对比："><a href="#RDB-和-AOF-对比：" class="headerlink" title="RDB 和 AOF 对比："></a>RDB 和 AOF 对比：</h2><table>
<thead>
<tr>
<th>命令</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>丢数据</td>
<td>根据策略决定</td>
</tr>
<tr>
<td>轻重</td>
<td>重</td>
<td>轻</td>
</tr>
</tbody></table>
<h2 id="AOF-文件太大会怎么样？"><a href="#AOF-文件太大会怎么样？" class="headerlink" title="AOF 文件太大会怎么样？"></a>AOF 文件太大会怎么样？</h2><p>AOF 文件过大时，后台会自动地对 AOF 进行重写（rewrite)，重写时会压缩 AOF 文件的内容，只保留可以恢复数据的最小指令集。比如说，假如我们调用了 100 次 INCR 指令，在 AOF 文件中就要存储 100 条指令，但这明显是很低效的，完全可以把这 100 条指令合并成一条 SET 指令。</p>
<p>在进行 AOF 重写时，仍然是采用先写临时文件，全部完成后再替换的流程，所以断电、磁盘满等问题都不会影响 AOF 文件的可用性。</p>
<hr>
<h1 id="Redis-常见性能问题和解决方案有哪些"><a href="#Redis-常见性能问题和解决方案有哪些" class="headerlink" title="Redis 常见性能问题和解决方案有哪些?"></a>Redis 常见性能问题和解决方案有哪些?</h1><p>（1）Master 最好不要写内存快照，如果 Master 写内存快照，save 命令调度 rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务；</p>
<p>（2）如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次；</p>
<p>（3）为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网；</p>
<p>（4）尽量避免在压力很大的主库上增加从库；</p>
<hr>
<h1 id="Redis-给缓存数据设置过期时间有啥用？"><a href="#Redis-给缓存数据设置过期时间有啥用？" class="headerlink" title="Redis 给缓存数据设置过期时间有啥用？"></a>Redis 给缓存数据设置过期时间有啥用？</h1><p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？</p>
<p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接Out of memory。</p>
<p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong></p>
<p>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在1分钟内有效，用户登录的 token 可能只在 1 天内有效。</p>
<p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p>
<h1 id="Redis是如何判断数据是否过期的呢？"><a href="#Redis是如何判断数据是否过期的呢？" class="headerlink" title="Redis是如何判断数据是否过期的呢？"></a>Redis是如何判断数据是否过期的呢？</h1><p>Redis  通过一个叫做过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个key(键)，过期字典的值是一个long long类型的整数，这个整数保存了key所指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。 </p>
<h1 id="Redis-过期键的删除策略"><a href="#Redis-过期键的删除策略" class="headerlink" title="Redis 过期键的删除策略"></a>Redis 过期键的删除策略</h1><p>A、<strong>定期删除策略</strong>。用一个<strong>定时器</strong>来负责检查 key，过期则删除 key，注意这里并不是检查所有的 key 而是<strong>随机抽取进行检查</strong>。定期策略虽然让内存及时释放，但也会<strong>额外消耗 CPU 资源</strong>，通常 CPU 应该将时间尽量用于处理业务请求，而不是删除 key。</p>
<p>B、<strong>惰性删除策略</strong>。在你<strong>获取</strong>某个 key 的时候，redis 会检查一下，这个 key <strong>如果设置了过期时间那么是否过期了</strong>，如果<strong>过期</strong>则删除该 key。</p>
<hr>
<h1 id="Redis-的回收策略（淘汰策略）"><a href="#Redis-的回收策略（淘汰策略）" class="headerlink" title="Redis 的回收策略（淘汰策略）?"></a>Redis 的回收策略（淘汰策略）?</h1><p>内存淘汰机制<br>如果<strong>定期删除没删除 key</strong>，然后也<strong>没及时去请求 key</strong>，即<strong>惰性删除也没生效</strong>，持续下去 redis 的内存会越来越高，当超过 redis 设置的内存最大使用量时，就会进行内存数据淘汰。redis 有 6 种淘汰策略：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>volatile-lru</td>
<td>从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td>volatile-ttl</td>
<td>从已设置过期时间的数据集中挑选将要过期的数据淘汰</td>
</tr>
<tr>
<td>volatile-random</td>
<td>从已设置过期时间的数据集中任意选择数据淘汰</td>
</tr>
<tr>
<td>allkeys-lru</td>
<td>从所有数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td>allkeys-random</td>
<td>从所有数据集中任意选择数据进行淘汰</td>
</tr>
<tr>
<td>noeviction</td>
<td>当内存不足以容纳新写入数据时，新写入操作会报错。很少使用</td>
</tr>
</tbody></table>
<blockquote>
<p>注意这里的 6 种机制，前缀 volatile 和 allkeys 用于区分淘汰数据的数据集是从已设置过期时间的数据集还是从全部数据集中选取，后面的 lru、ttl 以及 random 是三种不同的淘汰策略，再加上一种 no-enviction 永不回收的策略。其中最常使用的是 volatile-lru/allkeys-lru。</p>
</blockquote>
<h2 id="常用缓存数据淘汰策略"><a href="#常用缓存数据淘汰策略" class="headerlink" title="常用缓存数据淘汰策略"></a>常用缓存数据淘汰策略</h2><ul>
<li>FIFO（First In First Out）： 先进先出算法，即先放入缓存的先被移除。</li>
<li>LRU（Least Recently Used）： 最近最少使用算法，使用时间距离现在最久的那个被移除。</li>
<li>LFU（Least Frequently Used）： 最不常用算法，一定时间段内使用次数（频率）最少的那个被移除。</li>
</ul>
<h2 id="缓存数据更新策略"><a href="#缓存数据更新策略" class="headerlink" title="缓存数据更新策略"></a>缓存数据更新策略</h2><ul>
<li>定时任务从数据库直接更新缓存：适用于对时间不敏感的数据。</li>
<li>查询时写缓存，即查询优先查询缓存，若缓存未命中，查询数据库，将返回结果写入缓存，数据更新时先 delete缓存，再更新缓存。</li>
<li>MQ 消息异步更新缓存。</li>
</ul>
<hr>
<h1 id="为什么Redis-需要把所有数据放到内存中？"><a href="#为什么Redis-需要把所有数据放到内存中？" class="headerlink" title="为什么Redis 需要把所有数据放到内存中？"></a>为什么Redis 需要把所有数据放到内存中？</h1><p>Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以 redis 具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘 I/O 速度为严重影响 redis 的性能。在内存越来越便宜的今天，redis 将会越来越受欢迎。如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p>
<hr>
<h1 id="Redis-的同步机制了解么？"><a href="#Redis-的同步机制了解么？" class="headerlink" title="Redis 的同步机制了解么？"></a>Redis 的同步机制了解么？</h1><p>Redis的主从结构可以采用一主多从或者级联结构，Redis主从复制可以根据是否是全量分为全量同步和增量同步</p>
<p><img src="https://nexus-oss-test.oss-cn-shanghai.aliyuncs.com/redis%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6.png"></p>
<h2 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h2><p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下：</p>
<ul>
<li> 从服务器连接主服务器，发送SYNC命令；</li>
<li> 主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；</li>
<li> 主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；</li>
<li> 从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；</li>
<li> 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；</li>
<li> 从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li>
</ul>
<p><img src="https://nexus-oss-test.oss-cn-shanghai.aliyuncs.com/%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5.png" alt="image"></p>
<p>完成上面几个步骤后就完成了从服务器数据初始化的所有操作，从服务器此时可以接收来自用户的读请求。</p>
<h2 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h2><p>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。<br>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</p>
<h2 id="Redis主从同步策略"><a href="#Redis主从同步策略" class="headerlink" title="Redis主从同步策略"></a>Redis主从同步策略</h2><p>主从刚刚连接的时候，进行全量同步；</p>
<p>全同步结束后，进行增量同步。</p>
<p>当然，如果有需要，slave 在任何时候都可以发起全量同步。</p>
<p>redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p>
<h2 id="全量同步时需要注意："><a href="#全量同步时需要注意：" class="headerlink" title="全量同步时需要注意："></a>全量同步时需要注意：</h2><p>如果多个Slave断线了，需重启时，因为只要Slave启动，就会发送sync请求和主机全量同步，当多个同时出现的时候，可能会导致Master IO剧增宕机。</p>
<h2 id="Redis主从复制重要内容"><a href="#Redis主从复制重要内容" class="headerlink" title="Redis主从复制重要内容"></a>Redis主从复制重要内容</h2><blockquote>
<p>Redis主从复制的配置十分简单，它可以使从服务器是主服务器的完全拷贝。需要清楚知道Redis主从复制的几点重要内容：</p>
</blockquote>
<p>1）Redis使用异步复制。但从Redis 2.8开始，从服务器会周期性的应答从复制流中处理的数据量。</p>
<p>2）一个主服务器可以有多个从服务器。</p>
<p>3）从服务器也可以接受其他从服务器的连接。除了多个从服务器连接到一个主服务器之外，多个从服务器也可以连接到一个从服务器上，形成一个图状结构。</p>
<p>4）Redis主从复制不阻塞主服务器端。也就是说当若干个从服务器在进行初始同步时，主服务器仍然可以处理请求。</p>
<p>5）主从复制也不阻塞从服务器端。当从服务器进行初始同步时，它使用旧版本的数据来应对查询请求，假设你在redis.conf配置文件是这么配置的。否则的话，你可以配置当复制流关闭时让从服务器给客户端返回一个错误。但是当初始同步完成后，需删除旧数据集和加载新的数据集，在这个短暂时间内，从服务器会阻塞连接进来的请求。</p>
<p>6）主从复制可以用来增强扩展性，使用多个从服务器来处理只读的请求（比如，繁重的排序操作可以放到从服务器去做），也可以简单的用来做数据冗余。</p>
<p>7）使用主从复制可以为主服务器免除把数据写入磁盘的消耗：在主服务器的redis.conf文件中配置“避免保存”（注释掉所有“保存“命令），然后连接一个配置为“进行保存”的从服务器即可。但是这个配置要确保主服务器不会自动重启</p>
<h2 id="主从复制的特点"><a href="#主从复制的特点" class="headerlink" title="主从复制的特点"></a>主从复制的特点</h2><p>1）采用异步复制；</p>
<p>2）一个主redis可以含有多个从redis；</p>
<p>3）每个从redis可以接收来自其他从redis服务器的连接；</p>
<p>4）主从复制对于主redis服务器来说是非阻塞的，这意味着当从服务器在进行主从复制同步过程中，主redis仍然可以处理外界的访问请求；</p>
<p>5）主从复制对于从redis服务器来说也是非阻塞的，这意味着，即使从redis在进行主从复制过程中也可以接受外界的查询请求，只不过这时候从redis返回的是以前老的数据，如果你不想这样，那么在启动redis时，可以在配置文件中进行设置，那么从redis在复制同步过程中来自外界的查询请求都会返回错误给客户端；（虽然说主从复制过程中对于从redis是非阻塞的，但是当从redis从主redis同步过来最新的数据后还需要将新数据加载到内存中，在加载到内存的过程中是阻塞的，在这段时间内的请求将会被阻，但是即使对于大数据集，加载到内存的时间也是比较多的）；</p>
<p>6）主从复制提高了redis服务的扩展性，避免单个redis服务器的读写访问压力过大的问题，同时也可以给为数据备份及冗余提供一种解决方案；</p>
<p>7）为了编码主redis服务器写磁盘压力带来的开销，可以配置让主redis不在将数据持久化到磁盘，而是通过连接让一个配置的从redis服务器及时的将相关数据持久化到磁盘，不过这样会存在一个问题，就是主redis服务器一旦重启，因为主redis服务器数据为空，这时候通过主从同步可能导致从redis服务器上的数据也被清空；</p>
<h2 id="主从同步注意问题"><a href="#主从同步注意问题" class="headerlink" title="主从同步注意问题"></a>主从同步注意问题</h2><p>1）在上面的全量同步过程中，master会将数据保存在rdb文件中然后发送给slave服务器，但是如果master上的磁盘空间有效怎么办呢？那么此时全部同步对于master来说将是一份十分有压力的操作了。此时可以通过无盘复制来达到目的，由master直接开启一个socket将rdb文件发送给slave服务器。（无盘复制一般应用在磁盘空间有限但是网络状态良好的情况下）</p>
<p>2）主从复制结构，一般slave服务器不能进行写操作，但是这不是死的，之所以这样是为了更容易的保证主和各个从之间数据的一致性，如果slave服务器上数据进行了修改，那么要保证所有主从服务器都能一致，可能在结构上和处理逻辑上更为负责。不过你也可以通过配置文件让从服务器支持写操作。（不过所带来的影响还得自己承担哦。。。）</p>
<p>3）主从服务器之间会定期进行通话，但是如果master上设置了密码，那么如果不给slave设置密码就会导致slave不能跟master进行任何操作，所以如果你的master服务器上有密码，那么也给slave相应的设置一下密码吧（通过设置配置文件中的masterauth）;</p>
<p>4）关于slave服务器上过期键的处理，由master服务器负责键的过期删除处理，然后将相关删除命令已数据同步的方式同步给slave服务器，slave服务器根据删除命令删除本地的key。</p>
<h2 id="当主服务器不进行持久化时复制的安全性"><a href="#当主服务器不进行持久化时复制的安全性" class="headerlink" title="当主服务器不进行持久化时复制的安全性"></a>当主服务器不进行持久化时复制的安全性</h2><p>在进行主从复制设置时，强烈建议在主服务器上开启持久化，当不能这么做时，比如考虑到延迟的问题，应该将实例配置为避免自动重启。</p>
<h3 id="为什么不持久化的主服务器自动重启非常危险呢？"><a href="#为什么不持久化的主服务器自动重启非常危险呢？" class="headerlink" title="为什么不持久化的主服务器自动重启非常危险呢？"></a>为什么不持久化的主服务器自动重启非常危险呢？</h3><p>为了更好的理解这个问题，看下面这个失败的例子，其中主服务器和从服务器中数据库都被删除了</p>
<p>设置节点A为主服务器，关闭持久化，节点B和C从节点A复制数据。这时出现了一个崩溃，但Redis具有自动重启系统，重启了进程，因为关闭了持久化，节点重启后只有一个空的数据集。节点B和C从节点A进行复制，现在节点A是空的，所以节点B和C上的复制数据也会被删除。当在高可用系统中使用Redis Sentinel，关闭了主服务器的持久化，并且允许自动重启，这种情况是很危险的。比如主服务器可能在很短的时间就完成了重启，以至于Sentinel都无法检测到这次失败，那么上面说的这种失败的情况就发生了。如果数据比较重要，并且在使用主从复制时关闭了主服务器持久化功能的场景中，都应该禁止实例自动重启。</p>
<hr>
<h1 id="Redis无磁盘化复制"><a href="#Redis无磁盘化复制" class="headerlink" title="Redis无磁盘化复制"></a>Redis无磁盘化复制</h1><p>通过内存之间的传输，通过socket实现。</p>
<p><img src="https://nexus-oss-test.oss-cn-shanghai.aliyuncs.com/Redis%E6%97%A0%E7%A3%81%E7%9B%98%E5%8C%96%E5%A4%8D%E5%88%B6.png" alt="image"></p>
<p>磁盘有普通机械硬盘和SSD固定硬盘。如果是普通机械硬盘，硬盘读写效率低下。这样就出现了无磁盘化复制，从而提高了效率。</p>
<p>默认是关闭的</p>
<p>repl-diskless-sync no</p>
<p>使用的时候将no改为yes即可。</p>
<h1 id="Pipeline-有什么好处，为什么要用-Pipeline？"><a href="#Pipeline-有什么好处，为什么要用-Pipeline？" class="headerlink" title="Pipeline 有什么好处，为什么要用 Pipeline？"></a>Pipeline 有什么好处，为什么要用 Pipeline？</h1><p>多个指令之间没有依赖关系，可以使用 pipeline 一次性执行多个指令，减少 IO，缩减时间。</p>
<hr>
<h1 id="是否使用过-Redis-集群，集群的原理是什么？"><a href="#是否使用过-Redis-集群，集群的原理是什么？" class="headerlink" title="是否使用过 Redis 集群，集群的原理是什么？"></a>是否使用过 Redis 集群，集群的原理是什么？</h1><h2 id="Master-Slaver主从模式："><a href="#Master-Slaver主从模式：" class="headerlink" title="Master-Slaver主从模式："></a>Master-Slaver主从模式：</h2><p><img src="https://nexus-oss-test.oss-cn-shanghai.aliyuncs.com/Master-Slaver%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F.png" alt="image"><br>主从模式就是N个redis实例，可以是1主N从，也可以N主N从（N主N从则不是严格意义上的主从模式了，N主N从就是N+N个redis实例）</p>
<p><strong>优点</strong>：1.备份数据，这样当一个节点损坏（指不可恢复的硬件损坏）时，数据因为有备份，可以方便恢复。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>所有客户端都访问一个节点肯定会影响Redis工作效率，有了主从以后，查询操作就可以通过查询从节点来完成。</p>
<p><strong>缺点</strong>：master节点挂了以后，redis就不能对外提供写服务了，因为剩下的slave不能成为master。</p>
<p><strong>使用场景</strong>：读请求较多场景</p>
<h2 id="Sentinel哨兵模式"><a href="#Sentinel哨兵模式" class="headerlink" title="Sentinel哨兵模式"></a>Sentinel哨兵模式</h2><p><img src="https://nexus-oss-test.oss-cn-shanghai.aliyuncs.com/Sentinel%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.png" alt="image"></p>
<p>主从模式中slave节点不能主动选举一个master节点出来，那么就安排一个或多个sentinel来做这件事，当sentinel发现master节点挂了以后，sentinel就会从slave中重新选举一个master。</p>
<p><strong>优点</strong>：解决了主从模式下master挂了无法提供写服务的情况</p>
<p><strong>缺点</strong>：当数据量过大到一台服务器存放不下的情况（内存不够时），主从模式或sentinel模式就不能满足需求了</p>
<p><strong>使用场景</strong>：存储量不大，单机可承受。</p>
<p><strong>部署归约</strong>：1.哨兵节点要有至少3个或者奇数个节点 2.哨兵分布式部署到不同计算机节点上 3.一组哨兵只监控一组主从</p>
<p><strong>注意</strong>：原master恢复后不会成为master，等待下次选举</p>
<h2 id="Cluster集群模式"><a href="#Cluster集群模式" class="headerlink" title="Cluster集群模式"></a>Cluster集群模式</h2><p><img src="https://nexus-oss-test.oss-cn-shanghai.aliyuncs.com/Cluster%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F.png" alt="image"></p>
<p>cluster的出现是为了解决单机Redis容量有限的问题，将Redis的数据根据一定的规则分配到多台机器。一个 Redis 集群包含 16384 个哈希槽（hash slot），数据库中的每个键都属于这 16384 个哈希槽的其中一个，集群中的每个节点负责处理一部分哈希槽。</p>
<p><strong>优点</strong>：</p>
<ol>
<li>无中心架构：三机房部署，其中一主一从构成一个分片，之间通过异步复制同步数据，异步复制存在数据不一致的时间窗口，保证高性能的同时牺牲了部分一致性一旦某个机房掉线，则分片上位于另一个机房的 slave 会被提升为 master 从而可以继续提供服务</li>
<li>可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除。</li>
<li>降低运维成本，提高系统的扩展性和可用性。</li>
</ol>
<p><strong>使用场景</strong>：数据量大，高并发场景</p>
<h3 id="Redis-Cluster-实现的功能："><a href="#Redis-Cluster-实现的功能：" class="headerlink" title="Redis Cluster 实现的功能："></a>Redis Cluster 实现的功能：</h3><ul>
<li>将数据分片到多个实例 (按照 slot 存储)；</li>
<li>集群节点宕掉会自动 failover；</li>
<li>提供相对平滑扩容 (缩容) 节点。</li>
</ul>
<h1 id="Redis-集群方案什么情况下会导致整个集群不可用？"><a href="#Redis-集群方案什么情况下会导致整个集群不可用？" class="headerlink" title="Redis 集群方案什么情况下会导致整个集群不可用？"></a>Redis 集群方案什么情况下会导致整个集群不可用？</h1><p>有 A，B，C 三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。</p>
<h1 id="Redis-支持的-Java-客户端都有哪些？官方推荐用哪个？"><a href="#Redis-支持的-Java-客户端都有哪些？官方推荐用哪个？" class="headerlink" title="Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？"></a>Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？</h1><p>Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。</p>
<h1 id="Jedis-与-Redisson-对比有什么优缺点？"><a href="#Jedis-与-Redisson-对比有什么优缺点？" class="headerlink" title="Jedis 与 Redisson 对比有什么优缺点？"></a>Jedis 与 Redisson 对比有什么优缺点？</h1><p>Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持；</p>
<p>Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等 Redis 特性。</p>
<p>Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<h1 id="Redis-如何设置密码及验证密码？"><a href="#Redis-如何设置密码及验证密码？" class="headerlink" title="Redis 如何设置密码及验证密码？"></a>Redis 如何设置密码及验证密码？</h1><p>设置密码： config set requirepass 123456<br>授权密码： auth 123456</p>
<h1 id="说说-Redis-哈希槽的概念？"><a href="#说说-Redis-哈希槽的概念？" class="headerlink" title="说说 Redis 哈希槽的概念？"></a>说说 Redis 哈希槽的概念？</h1><p>Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p>
<h1 id="Redis-集群的主从复制模型是怎样的？"><a href="#Redis-集群的主从复制模型是怎样的？" class="headerlink" title="Redis 集群的主从复制模型是怎样的？"></a>Redis 集群的主从复制模型是怎样的？</h1><p>为了是在部分节点失败或者大部分节点无法通信的的情况下集群仍然可用，所以集群使用了主从复制模型，<br>每个节点都会有N-1个复制品</p>
<h1 id="Redis-集群会有写操作丢失吗？为什么？"><a href="#Redis-集群会有写操作丢失吗？为什么？" class="headerlink" title="Redis 集群会有写操作丢失吗？为什么？"></a>Redis 集群会有写操作丢失吗？为什么？</h1><p>Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p>
<h1 id="Redis-集群之间是如何复制的？"><a href="#Redis-集群之间是如何复制的？" class="headerlink" title="Redis 集群之间是如何复制的？"></a>Redis 集群之间是如何复制的？</h1><p>异步复制</p>
<h1 id="Redis-集群最大节点个数是多少？"><a href="#Redis-集群最大节点个数是多少？" class="headerlink" title="Redis 集群最大节点个数是多少？"></a>Redis 集群最大节点个数是多少？</h1><p>16384 个。</p>
<h1 id="Redis-集群如何选择数据库？"><a href="#Redis-集群如何选择数据库？" class="headerlink" title="Redis 集群如何选择数据库？"></a>Redis 集群如何选择数据库？</h1><p>目前无法做数据库选择，默认在0数据库，可以在application.yml中配置</p>
<h1 id="怎么测试-Redis-的连通性？"><a href="#怎么测试-Redis-的连通性？" class="headerlink" title="怎么测试 Redis 的连通性？"></a>怎么测试 Redis 的连通性？</h1><p>ping</p>
<h1 id="怎么理解-Redis-事务？"><a href="#怎么理解-Redis-事务？" class="headerlink" title="怎么理解 Redis 事务？"></a>怎么理解 Redis 事务？</h1><p>1）事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>2）事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<h1 id="Redis-事务相关的命令有哪几个？"><a href="#Redis-事务相关的命令有哪几个？" class="headerlink" title="Redis 事务相关的命令有哪几个？"></a>Redis 事务相关的命令有哪几个？</h1><ul>
<li>MULTI</li>
</ul>
<p>使用该命令，标记一个事务块的开始，通常在执行之后会回复OK，（但不一定真的OK），这个时候用户可以输入多个操作来代替逐条操作，redis会将这些操作放入队列中。</p>
<ul>
<li>EXEC</li>
</ul>
<p>执行这个事务内的所有命令</p>
<ul>
<li>DISCARD</li>
</ul>
<p>放弃事务，即该事务内的所有命令都将取消</p>
<ul>
<li>WATCH</li>
</ul>
<p>监控一个或者多个key，如果这些key在提交事务（EXEC）之前被其他用户修改过，那么事务将执行失败，需要重新获取最新数据重头操作（类似于乐观锁）。</p>
<h1 id="redis事务的性质"><a href="#redis事务的性质" class="headerlink" title="redis事务的性质"></a>redis事务的性质</h1><ol>
<li>单独的隔离操作：事务中的所有命令会被序列化、按顺序执行，在执行的过程中不会被其他客户端发送来的命令打断</li>
<li>没有隔离级别的概念：队列中的命令在事务没有被提交之前不会被实际执行</li>
<li>不保证原子性：redis中的一个事务中如果存在命令执行失败，那么其他命令依然会被执行，没有回滚机制</li>
</ol>
<h1 id="Redis-key-的过期时间和永久有效分别怎么设置？"><a href="#Redis-key-的过期时间和永久有效分别怎么设置？" class="headerlink" title="Redis key 的过期时间和永久有效分别怎么设置？"></a>Redis key 的过期时间和永久有效分别怎么设置？</h1><p>EXPIRE 和 PERSIST 命令。</p>
<h1 id="Redis-如何做内存优化？"><a href="#Redis-如何做内存优化？" class="headerlink" title="Redis 如何做内存优化？"></a>Redis 如何做内存优化？</h1><p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key,而是应该把这个用户的所有信息存储到一张散列表里面。</p>
<h1 id="Redis-回收进程如何工作的？"><a href="#Redis-回收进程如何工作的？" class="headerlink" title="Redis 回收进程如何工作的？"></a>Redis 回收进程如何工作的？</h1><p>一个客户端运行了新的命令，添加了新的数据。Redi 检查内存使用情况，如<br>果大于 maxmemory 的限制, 则根据设定好的策略进行回收。一个新的命令被执<br>行，等等。所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地<br>回收回到边界以下。如果一个命令的结果导致大量内存被使用（例如很大的集合<br>的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。 </p>
<h1 id="都有哪些办法可以降低-Redis-的内存使用情况呢？"><a href="#都有哪些办法可以降低-Redis-的内存使用情况呢？" class="headerlink" title="都有哪些办法可以降低 Redis 的内存使用情况呢？"></a>都有哪些办法可以降低 Redis 的内存使用情况呢？</h1><p>如果你使用的是 32 位的 Redis 实例，可以好好利用 Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的 Key-Value 可以用更紧凑的方式存放到一起。</p>
<h1 id="Redis-的内存用完了会发生什么？"><a href="#Redis-的内存用完了会发生什么？" class="headerlink" title="Redis 的内存用完了会发生什么？"></a>Redis 的内存用完了会发生什么？</h1><p>如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以将 Redis 当缓存来使用配置淘汰机制，当 Redis 达到内存上限时会冲刷掉旧的内容。</p>
<h1 id="一个-Redis-实例最多能存放多少的-keys？List、Set、Sorted-Set他们最多能存放多少元素？"><a href="#一个-Redis-实例最多能存放多少的-keys？List、Set、Sorted-Set他们最多能存放多少元素？" class="headerlink" title="一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set他们最多能存放多少元素？"></a>一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set他们最多能存放多少元素？</h1><p>理论上 Redis 可以处理多达 232 的 keys，每个实例至少存放了 2 亿 5 千万的 keys。任何 list、set、和 sorted set 都可以放 232 个元素。换句话说，Redis 的存储极限是系统中的可用内存值<br>。</p>
<h1 id="MySQL-里有-2000w-数据，Redis-中只存-20w-的数据，如何保证Redis-中的数据都是热点数据？"><a href="#MySQL-里有-2000w-数据，Redis-中只存-20w-的数据，如何保证Redis-中的数据都是热点数据？" class="headerlink" title="MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证Redis 中的数据都是热点数据？"></a>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证Redis 中的数据都是热点数据？</h1><p>限定 Redis 占用的内存，Redis 会根据自身数据淘汰策略，加载热数据到内存。 所以，计算一下 20W 数据大约占用的内存，然后设置一下 Redis 内存限制即可。</p>
<p>Redis存储数据会限制它内存大小，如果超过了最大内存容量，会触发数据淘汰策略</p>
<p>淘汰策略共有六种<br>1)volatile-lru: 从已设置过期时间的数据集中，挑选最新最少使用用的数据淘汰</p>
<p>2)volatile-ttl: 从已设置过期时间的数据集中，挑选将要过期的数据淘汰</p>
<p>3)volatile-random: 从已设置过期时间的数据集中任意选择数据淘汰</p>
<p>4)allkeys-lru: 从数据集中，挑选最近最少使用用的数据淘汰</p>
<p>5)allkeys-random: 从数据集中，任意选择数据淘汰</p>
<p>6)no-enviction (驱逐): 禁止驱逐数据</p>
<h1 id="Redis-最适合的场景是什么？"><a href="#Redis-最适合的场景是什么？" class="headerlink" title="Redis 最适合的场景是什么？"></a>Redis 最适合的场景是什么？</h1><p>1、会话缓存（Session Cache）</p>
<p>最常用的一种使用 Redis 的情景是会话缓存（session cache）。用 Redis 缓存会话比其他存储（如 Memcached）的优势在于：Redis 提供持久化。</p>
<p>2、全页缓存（FPC）</p>
<p>除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。能帮助你以最快速度加载你曾浏览过的页面。</p>
<p>3、队列</p>
<p>Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push/pop 操作。</p>
<p>4，排行榜/计数器</p>
<p>Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的 10个用户，我们只需要像下面一样执行即可： 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES。</p>
<p>5、发布/订阅</p>
<p>最后（但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。在社交网络中甚至可以用 Redis 的发布/订阅功能来建立聊天系统！</p>
<h1 id="假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h1><p>使用 keys 指令可以扫出指定模式的 key 列表。</p>
<h2 id="如果这个-redis-正在给线上的业务提供服务，那使用-keys-指令会有什么问题？"><a href="#如果这个-redis-正在给线上的业务提供服务，那使用-keys-指令会有什么问题？" class="headerlink" title="如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问题？"></a>如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问题？</h2><blockquote>
<p>这个时候你要回答 redis 关键的一个特性：redis 的单线程的。</p>
</blockquote>
<p>keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。</p>
<h1 id="如果有大量的-key-需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的-key-需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的 key 需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</h1><p>如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，redis 可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p>
<h1 id="使用过-Redis-做异步队列么，你是怎么用的？"><a href="#使用过-Redis-做异步队列么，你是怎么用的？" class="headerlink" title="使用过 Redis 做异步队列么，你是怎么用的？"></a>使用过 Redis 做异步队列么，你是怎么用的？</h1><p>一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。</p>
<h2 id="如果对方追问可不可以不用-sleep-呢？"><a href="#如果对方追问可不可以不用-sleep-呢？" class="headerlink" title="如果对方追问可不可以不用 sleep 呢？"></a>如果对方追问可不可以不用 sleep 呢？</h2><p>list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。</p>
<h2 id="如果对方追问能不能生产一次消费多次呢？"><a href="#如果对方追问能不能生产一次消费多次呢？" class="headerlink" title="如果对方追问能不能生产一次消费多次呢？"></a>如果对方追问能不能生产一次消费多次呢？</h2><p>使用 pub/sub 主题订阅者模式，可以实现1:N 的消息队列。</p>
<h2 id="如果对方追问-pub-sub-有什么缺点？"><a href="#如果对方追问-pub-sub-有什么缺点？" class="headerlink" title="如果对方追问 pub/sub 有什么缺点？"></a>如果对方追问 pub/sub 有什么缺点？</h2><p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 RabbitMQ等。</p>
<h2 id="如果对方追问-redis-如何实现延时队列？"><a href="#如果对方追问-redis-如何实现延时队列？" class="headerlink" title="如果对方追问 redis 如何实现延时队列？"></a>如果对方追问 redis 如何实现延时队列？</h2><p>使用 sortedset，拿时间戳作为score，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。<br>40.使用过 Redis 分布式锁么，它是什么回事？</p>
<h1 id="redis缓存模式"><a href="#redis缓存模式" class="headerlink" title="redis缓存模式"></a>redis缓存模式</h1><ul>
<li>Cache Aside <ul>
<li>先更新数据库，再更新缓存。这种做法最大的问题就是两个并发的写操作导致脏数据</li>
<li>先删除缓存，再更新数据库。这个逻辑是错误的，因为两个并发的读和写操作导致脏数据</li>
<li>先更新数据库，再删除缓存（在实际的系统中也推荐使用这种方式）</li>
</ul>
</li>
<li>Read-through 通读 </li>
<li>Write-through 通写</li>
<li>Write-behind caching</li>
</ul>
<h1 id="缓存与数据库双写不一致解决方案（了解）"><a href="#缓存与数据库双写不一致解决方案（了解）" class="headerlink" title="缓存与数据库双写不一致解决方案（了解）"></a>缓存与数据库双写不一致解决方案（了解）</h1><p>保证最终一致性的解决方案是缓存设置过期时间。</p>
<h2 id="方案一：先更新缓存，再更新数据库"><a href="#方案一：先更新缓存，再更新数据库" class="headerlink" title="方案一：先更新缓存，再更新数据库"></a>方案一：先更新缓存，再更新数据库</h2><p>不推荐。</p>
<ol>
<li>先更新缓存</li>
<li>若更新数据库失败，还需再更新缓存。</li>
</ol>
<h2 id="方案二：先更新数据库，再更新缓存"><a href="#方案二：先更新数据库，再更新缓存" class="headerlink" title="方案二：先更新数据库，再更新缓存"></a>方案二：先更新数据库，再更新缓存</h2><p>不推荐。</p>
<p>同时有请求A和请求B进行更新操作，请求A与B在不同线程，可能会出现：</p>
<ol>
<li>请求A更新了数据库</li>
<li>请求B更新了数据库</li>
<li>请求B更新了缓存</li>
<li>请求A更新了缓存</li>
</ol>
<p>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。</p>
<h2 id="方案三：先删除缓存，再更新数据库"><a href="#方案三：先删除缓存，再更新数据库" class="headerlink" title="方案三：先删除缓存，再更新数据库"></a>方案三：先删除缓存，再更新数据库</h2><p>有点问题。</p>
<p>有一个请求A进行更新操作，另一个请求B进行查询操作，可能会出现：</p>
<p>（1）、单个数据库</p>
<ol>
<li>请求A进行写操作，删除缓存</li>
<li>请求B查询发现缓存不存在</li>
<li>请求B去数据库查询得到旧值</li>
<li>请求B将旧值写入缓存</li>
<li>请求A将新值写入数据库</li>
</ol>
<p>（2）、读写分离架构</p>
<ol>
<li>请求A进行写操作，删除缓存</li>
<li>请求A将数据写入数据库了，</li>
<li>请求B查询缓存发现，缓存没有值</li>
<li>请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值</li>
<li>请求B将旧值写入缓存</li>
</ol>
<p>数据库完成主从同步，从库变为新值</p>
<p>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据</p>
<h3 id="解决方案：延时双删策略"><a href="#解决方案：延时双删策略" class="headerlink" title="解决方案：延时双删策略"></a>解决方案：延时双删策略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void write(String key,Object data)&#123;</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">    db.updateData(data);</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先淘汰缓存</li>
<li>再写数据库（这两步和原来一样）</li>
<li>休眠1秒</li>
<li>再次淘汰缓存</li>
</ol>
<p>自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>
<p>对于MySQL读写分离架构，只是睡眠时间修改为在主从同步的延时时间基础上，加几百ms。</p>
<h2 id="方案四：先更新数据库，再删除缓存"><a href="#方案四：先更新数据库，再删除缓存" class="headerlink" title="方案四：先更新数据库，再删除缓存"></a>方案四：先更新数据库，再删除缓存</h2><p>极端情况有问题。</p>
<p>有一个请求A进行更新操作，另一个请求B进行查询操作，可能会出现：</p>
<ol>
<li>请求A查询数据库得到一个旧值</li>
<li>请求B将新值写入数据库</li>
<li>请求B删除缓存</li>
<li>请求A将查到的旧值写入缓存</li>
</ol>
<p>步骤2的写数据库操作比步骤1的读数据库操作耗时更短，才有可能使得步骤3先于步骤4。可是，大家想想，数据库的读操作的速度远快于写操作的，因此步骤2耗时比步骤1更短，这一情形很难出现。</p>
<h3 id="解决方案：延时双删策略-1"><a href="#解决方案：延时双删策略-1" class="headerlink" title="解决方案：延时双删策略"></a>解决方案：延时双删策略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void write(String key,Object data)&#123;</span><br><span class="line">    db.updateData(data);</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先写数据库</li>
<li>再淘汰缓存</li>
<li>休眠1秒</li>
<li>再次淘汰缓存</li>
</ol>
<h2 id="方案三与方案四还存在问题"><a href="#方案三与方案四还存在问题" class="headerlink" title="方案三与方案四还存在问题"></a>方案三与方案四还存在问题</h2><ul>
<li>问题一:同步双删导致并发降低</li>
<li>问题二:比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况。</li>
</ul>
<h3 id="问题一解决方案"><a href="#问题一解决方案" class="headerlink" title="问题一解决方案"></a>问题一解决方案</h3><p>异步。</p>
<h3 id="问题二解决方案"><a href="#问题二解决方案" class="headerlink" title="问题二解决方案"></a>问题二解决方案</h3><p>提供一个保障的重试机制。</p>
<p><strong>方案一：消息队列方式</strong></p>
<p>更新数据库数据<br>缓存因为种种问题删除失败<br>将需要删除的key发送至消息队列<br>自己消费消息，获得需要删除的key<br>继续重试删除操作，直到成功</p>
<p>业务线代码侵入较大。</p>
<p><strong>方案二：订阅binlong方式</strong></p>
<p>更新数据库数据<br>数据库会将操作信息写入binlog日志当中<br>订阅程序提取出所需要的数据以及key<br>另起一段非业务代码，获得该信息<br>尝试删除缓存操作，发现删除失败<br>将这些信息发送至消息队列<br>重新从消息队列中获得该数据，重试操作。</p>
<p>订阅binlog程序在MySQL中有阿里开源的中间件叫canal。</p>
<p>如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试也可。</p>
<p><strong>总结</strong></p>
<p>根据数据实时性要求，以及系统并发量考虑。</p>
<p>实时性不强，则可以选择设定缓存过期时间，先删缓存再更新数据库或先更新数据库再删缓存方案都可行。</p>
<p>实时性较强的，又有大并发量可以考虑延迟双删策略。</p>
<p>至于其他如请求串行化，放入同一个队列中依次执行的，复杂没必要。</p>
<h1 id="如何保证缓存和数据库数据的一致性？-重要"><a href="#如何保证缓存和数据库数据的一致性？-重要" class="headerlink" title="如何保证缓存和数据库数据的一致性？(重要)"></a>如何保证缓存和数据库数据的一致性？(重要)</h1><p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p>
<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p>
<ol>
<li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li><strong>增加cache更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。</li>
</ol>
<h1 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h1><p>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止忘记释放</p>
<h2 id="如果在setnx之后执行expire之前进程意外crash或者重启维护了，怎么办？"><a href="#如果在setnx之后执行expire之前进程意外crash或者重启维护了，怎么办？" class="headerlink" title="如果在setnx之后执行expire之前进程意外crash或者重启维护了，怎么办？"></a>如果在setnx之后执行expire之前进程意外crash或者重启维护了，怎么办？</h2><p>setnx和expire合成一条指令</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/redis/" rel="tag"># redis</a>
          
            <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/03/25/redis%E5%AE%89%E8%A3%85/" rel="next" title="redis安装">
                <i class="fa fa-chevron-left"></i> redis安装
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <!--<a href="/archives/%7C%7Carchive">-->
                <a href="/archives/">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuanyayuan" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:liyuan0707@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Redis"><span class="nav-number">1.</span> <span class="nav-text">什么是 Redis?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E7%9A%84key%E5%92%8Cvalue%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6"><span class="nav-number">2.</span> <span class="nav-text">Redis的key和value大小限制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">3.</span> <span class="nav-text">Redis服务器和客户端的通信</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Redis-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">使用 Redis 有哪些好处？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3key%E5%86%B2%E7%AA%81%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">Redis如何解决key冲突？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">缓存数据的处理流程是怎样的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9redis"><span class="nav-number">7.</span> <span class="nav-text">为什么选择redis</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Memcached-%E4%B8%8E-Redis-%E7%9A%84%E5%8C%BA%E5%88%AB%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">Memcached 与 Redis 的区别都有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E7%9B%B8%E6%AF%94Memcached%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF"><span class="nav-number">9.</span> <span class="nav-text">Redis相比Memcached有哪些优势</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86"><span class="nav-number">10.</span> <span class="nav-text">Redis单线程原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3"><span class="nav-number">10.1.</span> <span class="nav-text">Redis 单线程模型详解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E6%98%AF%E5%8D%95%E8%BF%9B%E7%A8%8B%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BD%95%E5%AE%83%E9%82%A3%E4%B9%88%E5%BF%AB%E9%82%A3%E4%B9%88%E9%AB%98%E6%95%88%EF%BC%9F"><span class="nav-number">11.</span> <span class="nav-text">Redis 是单进程单线程的吗？为何它那么快那么高效？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="nav-number">11.1.</span> <span class="nav-text">单线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9F%E5%BA%A6%E5%BF%AB"><span class="nav-number">11.2.</span> <span class="nav-text">速度快</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%87%87%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86"><span class="nav-number">12.</span> <span class="nav-text">redis为什么不采用多线程处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis6-0-%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BD%95%E5%BC%95%E5%85%A5%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">12.1.</span> <span class="nav-text">Redis6.0 之后为何引入了多线程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">单线程处理的缺点？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%90%84%E8%87%AA%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">14.</span> <span class="nav-text">Redis 的持久化机制是什么？各自的优缺点？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB-%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="nav-number">14.1.</span> <span class="nav-text">RDB 的优点：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB-%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="nav-number">14.2.</span> <span class="nav-text">RDB 的缺点：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF-%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="nav-number">14.3.</span> <span class="nav-text">AOF 的优点：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF-%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="nav-number">14.4.</span> <span class="nav-text">AOF 的缺点：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB-%E5%92%8C-AOF-%E5%AF%B9%E6%AF%94%EF%BC%9A"><span class="nav-number">14.5.</span> <span class="nav-text">RDB 和 AOF 对比：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF-%E6%96%87%E4%BB%B6%E5%A4%AA%E5%A4%A7%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="nav-number">14.6.</span> <span class="nav-text">AOF 文件太大会怎么样？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E5%B8%B8%E8%A7%81%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">15.</span> <span class="nav-text">Redis 常见性能问题和解决方案有哪些?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E7%BB%99%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E6%9C%89%E5%95%A5%E7%94%A8%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">Redis 给缓存数据设置过期时间有啥用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E8%BF%87%E6%9C%9F%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="nav-number">17.</span> <span class="nav-text">Redis是如何判断数据是否过期的呢？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="nav-number">18.</span> <span class="nav-text">Redis 过期键的删除策略</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E7%9A%84%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%EF%BC%88%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%EF%BC%89"><span class="nav-number">19.</span> <span class="nav-text">Redis 的回收策略（淘汰策略）?</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">19.1.</span> <span class="nav-text">常用缓存数据淘汰策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="nav-number">19.2.</span> <span class="nav-text">缓存数据更新策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Redis-%E9%9C%80%E8%A6%81%E6%8A%8A%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BE%E5%88%B0%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%9F"><span class="nav-number">20.</span> <span class="nav-text">为什么Redis 需要把所有数据放到内存中？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F"><span class="nav-number">21.</span> <span class="nav-text">Redis 的同步机制了解么？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5"><span class="nav-number">21.1.</span> <span class="nav-text">全量同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5"><span class="nav-number">21.2.</span> <span class="nav-text">增量同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5"><span class="nav-number">21.3.</span> <span class="nav-text">Redis主从同步策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%EF%BC%9A"><span class="nav-number">21.4.</span> <span class="nav-text">全量同步时需要注意：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%87%8D%E8%A6%81%E5%86%85%E5%AE%B9"><span class="nav-number">21.5.</span> <span class="nav-text">Redis主从复制重要内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">21.6.</span> <span class="nav-text">主从复制的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98"><span class="nav-number">21.7.</span> <span class="nav-text">主从同步注意问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%93%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8D%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%E6%97%B6%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">21.8.</span> <span class="nav-text">当主服务器不进行持久化时复制的安全性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%87%AA%E5%8A%A8%E9%87%8D%E5%90%AF%E9%9D%9E%E5%B8%B8%E5%8D%B1%E9%99%A9%E5%91%A2%EF%BC%9F"><span class="nav-number">21.8.1.</span> <span class="nav-text">为什么不持久化的主服务器自动重启非常危险呢？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E6%97%A0%E7%A3%81%E7%9B%98%E5%8C%96%E5%A4%8D%E5%88%B6"><span class="nav-number">22.</span> <span class="nav-text">Redis无磁盘化复制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Pipeline-%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-Pipeline%EF%BC%9F"><span class="nav-number">23.</span> <span class="nav-text">Pipeline 有什么好处，为什么要用 Pipeline？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8%E8%BF%87-Redis-%E9%9B%86%E7%BE%A4%EF%BC%8C%E9%9B%86%E7%BE%A4%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">24.</span> <span class="nav-text">是否使用过 Redis 集群，集群的原理是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Master-Slaver%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">24.1.</span> <span class="nav-text">Master-Slaver主从模式：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">24.2.</span> <span class="nav-text">负载均衡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sentinel%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="nav-number">24.3.</span> <span class="nav-text">Sentinel哨兵模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cluster%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="nav-number">24.4.</span> <span class="nav-text">Cluster集群模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-Cluster-%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="nav-number">24.4.1.</span> <span class="nav-text">Redis Cluster 实现的功能：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%95%B4%E4%B8%AA%E9%9B%86%E7%BE%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%EF%BC%9F"><span class="nav-number">25.</span> <span class="nav-text">Redis 集群方案什么情况下会导致整个集群不可用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E6%94%AF%E6%8C%81%E7%9A%84-Java-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90%E7%94%A8%E5%93%AA%E4%B8%AA%EF%BC%9F"><span class="nav-number">26.</span> <span class="nav-text">Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Jedis-%E4%B8%8E-Redisson-%E5%AF%B9%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">27.</span> <span class="nav-text">Jedis 与 Redisson 对比有什么优缺点？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81%E5%8F%8A%E9%AA%8C%E8%AF%81%E5%AF%86%E7%A0%81%EF%BC%9F"><span class="nav-number">28.</span> <span class="nav-text">Redis 如何设置密码及验证密码？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-Redis-%E5%93%88%E5%B8%8C%E6%A7%BD%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9F"><span class="nav-number">29.</span> <span class="nav-text">说说 Redis 哈希槽的概念？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E9%9B%86%E7%BE%A4%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-number">30.</span> <span class="nav-text">Redis 集群的主从复制模型是怎样的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E9%9B%86%E7%BE%A4%E4%BC%9A%E6%9C%89%E5%86%99%E6%93%8D%E4%BD%9C%E4%B8%A2%E5%A4%B1%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">31.</span> <span class="nav-text">Redis 集群会有写操作丢失吗？为什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E9%9B%86%E7%BE%A4%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%8D%E5%88%B6%E7%9A%84%EF%BC%9F"><span class="nav-number">32.</span> <span class="nav-text">Redis 集群之间是如何复制的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E9%9B%86%E7%BE%A4%E6%9C%80%E5%A4%A7%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="nav-number">33.</span> <span class="nav-text">Redis 集群最大节点个数是多少？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E9%9B%86%E7%BE%A4%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F"><span class="nav-number">34.</span> <span class="nav-text">Redis 集群如何选择数据库？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E6%B5%8B%E8%AF%95-Redis-%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7%EF%BC%9F"><span class="nav-number">35.</span> <span class="nav-text">怎么测试 Redis 的连通性？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3-Redis-%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="nav-number">36.</span> <span class="nav-text">怎么理解 Redis 事务？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3%E7%9A%84%E5%91%BD%E4%BB%A4%E6%9C%89%E5%93%AA%E5%87%A0%E4%B8%AA%EF%BC%9F"><span class="nav-number">37.</span> <span class="nav-text">Redis 事务相关的命令有哪几个？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-number">38.</span> <span class="nav-text">redis事务的性质</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-key-%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E5%92%8C%E6%B0%B8%E4%B9%85%E6%9C%89%E6%95%88%E5%88%86%E5%88%AB%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%EF%BC%9F"><span class="nav-number">39.</span> <span class="nav-text">Redis key 的过期时间和永久有效分别怎么设置？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E5%A6%82%E4%BD%95%E5%81%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">40.</span> <span class="nav-text">Redis 如何做内存优化？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E5%9B%9E%E6%94%B6%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="nav-number">41.</span> <span class="nav-text">Redis 回收进程如何工作的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%9E%E6%B3%95%E5%8F%AF%E4%BB%A5%E9%99%8D%E4%BD%8E-Redis-%E7%9A%84%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E5%91%A2%EF%BC%9F"><span class="nav-number">42.</span> <span class="nav-text">都有哪些办法可以降低 Redis 的内存使用情况呢？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E7%9A%84%E5%86%85%E5%AD%98%E7%94%A8%E5%AE%8C%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">43.</span> <span class="nav-text">Redis 的内存用完了会发生什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA-Redis-%E5%AE%9E%E4%BE%8B%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91%E7%9A%84-keys%EF%BC%9FList%E3%80%81Set%E3%80%81Sorted-Set%E4%BB%96%E4%BB%AC%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="nav-number">44.</span> <span class="nav-text">一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set他们最多能存放多少元素？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-%E9%87%8C%E6%9C%89-2000w-%E6%95%B0%E6%8D%AE%EF%BC%8CRedis-%E4%B8%AD%E5%8F%AA%E5%AD%98-20w-%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Redis-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="nav-number">45.</span> <span class="nav-text">MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证Redis 中的数据都是热点数据？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E6%9C%80%E9%80%82%E5%90%88%E7%9A%84%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">46.</span> <span class="nav-text">Redis 最适合的场景是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%81%87%E5%A6%82-Redis-%E9%87%8C%E9%9D%A2%E6%9C%89-1-%E4%BA%BF%E4%B8%AA-key%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%9C%89-10w-%E4%B8%AA-key-%E6%98%AF%E4%BB%A5%E6%9F%90%E4%B8%AA%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%B7%B2%E7%9F%A5%E7%9A%84%E5%89%8D%E7%BC%80%E5%BC%80%E5%A4%B4%E7%9A%84%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%B0%86%E5%AE%83%E4%BB%AC%E5%85%A8%E9%83%A8%E6%89%BE%E5%87%BA%E6%9D%A5%EF%BC%9F"><span class="nav-number">47.</span> <span class="nav-text">假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E8%BF%99%E4%B8%AA-redis-%E6%AD%A3%E5%9C%A8%E7%BB%99%E7%BA%BF%E4%B8%8A%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1%EF%BC%8C%E9%82%A3%E4%BD%BF%E7%94%A8-keys-%E6%8C%87%E4%BB%A4%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">47.1.</span> <span class="nav-text">如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问题？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%9C%89%E5%A4%A7%E9%87%8F%E7%9A%84-key-%E9%9C%80%E8%A6%81%E8%AE%BE%E7%BD%AE%E5%90%8C%E4%B8%80%E6%97%B6%E9%97%B4%E8%BF%87%E6%9C%9F%EF%BC%8C%E4%B8%80%E8%88%AC%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">48.</span> <span class="nav-text">如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%87-Redis-%E5%81%9A%E5%BC%82%E6%AD%A5%E9%98%9F%E5%88%97%E4%B9%88%EF%BC%8C%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="nav-number">49.</span> <span class="nav-text">使用过 Redis 做异步队列么，你是怎么用的？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%AF%B9%E6%96%B9%E8%BF%BD%E9%97%AE%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%B8%8D%E7%94%A8-sleep-%E5%91%A2%EF%BC%9F"><span class="nav-number">49.1.</span> <span class="nav-text">如果对方追问可不可以不用 sleep 呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%AF%B9%E6%96%B9%E8%BF%BD%E9%97%AE%E8%83%BD%E4%B8%8D%E8%83%BD%E7%94%9F%E4%BA%A7%E4%B8%80%E6%AC%A1%E6%B6%88%E8%B4%B9%E5%A4%9A%E6%AC%A1%E5%91%A2%EF%BC%9F"><span class="nav-number">49.2.</span> <span class="nav-text">如果对方追问能不能生产一次消费多次呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%AF%B9%E6%96%B9%E8%BF%BD%E9%97%AE-pub-sub-%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">49.3.</span> <span class="nav-text">如果对方追问 pub&#x2F;sub 有什么缺点？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%AF%B9%E6%96%B9%E8%BF%BD%E9%97%AE-redis-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%EF%BC%9F"><span class="nav-number">49.4.</span> <span class="nav-text">如果对方追问 redis 如何实现延时队列？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis%E7%BC%93%E5%AD%98%E6%A8%A1%E5%BC%8F"><span class="nav-number">50.</span> <span class="nav-text">redis缓存模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%8D%E4%B8%80%E8%87%B4%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">51.</span> <span class="nav-text">缓存与数据库双写不一致解决方案（了解）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9A%E5%85%88%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">51.1.</span> <span class="nav-text">方案一：先更新缓存，再更新数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9A%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98"><span class="nav-number">51.2.</span> <span class="nav-text">方案二：先更新数据库，再更新缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%E4%B8%89%EF%BC%9A%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">51.3.</span> <span class="nav-text">方案三：先删除缓存，再更新数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0%E7%AD%96%E7%95%A5"><span class="nav-number">51.3.1.</span> <span class="nav-text">解决方案：延时双删策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%E5%9B%9B%EF%BC%9A%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%86%8D%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98"><span class="nav-number">51.4.</span> <span class="nav-text">方案四：先更新数据库，再删除缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0%E7%AD%96%E7%95%A5-1"><span class="nav-number">51.4.1.</span> <span class="nav-text">解决方案：延时双删策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%E4%B8%89%E4%B8%8E%E6%96%B9%E6%A1%88%E5%9B%9B%E8%BF%98%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98"><span class="nav-number">51.5.</span> <span class="nav-text">方案三与方案四还存在问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E4%B8%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">51.5.1.</span> <span class="nav-text">问题一解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E4%BA%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">51.5.2.</span> <span class="nav-text">问题二解决方案</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F-%E9%87%8D%E8%A6%81"><span class="nav-number">52.</span> <span class="nav-text">如何保证缓存和数据库数据的一致性？(重要)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">53.</span> <span class="nav-text">Redis分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%9C%A8setnx%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8Cexpire%E4%B9%8B%E5%89%8D%E8%BF%9B%E7%A8%8B%E6%84%8F%E5%A4%96crash%E6%88%96%E8%80%85%E9%87%8D%E5%90%AF%E7%BB%B4%E6%8A%A4%E4%BA%86%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">53.1.</span> <span class="nav-text">如果在setnx之后执行expire之前进程意外crash或者重启维护了，怎么办？</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LiYuan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
