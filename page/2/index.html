<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="工作中技术总结">
<meta property="og:type" content="website">
<meta property="og:title" content="Hikari的Java之路">
<meta property="og:url" content="https://yuanyayuan.github.io/page/2/index.html">
<meta property="og:site_name" content="Hikari的Java之路">
<meta property="og:description" content="工作中技术总结">
<meta property="og:locale">
<meta property="article:author" content="LiYuan">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yuanyayuan.github.io/page/2/"/>





  <title>Hikari的Java之路</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hikari的Java之路</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Hello,world</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%8C%E7%A9%BF%E9%80%8F%EF%BC%8C%E5%87%BB%E7%A9%BF%EF%BC%8C%E9%A2%84%E7%83%AD%EF%BC%8C%E6%9B%B4%E6%96%B0%EF%BC%8C%E9%99%8D%E7%BA%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%8C%E7%A9%BF%E9%80%8F%EF%BC%8C%E5%87%BB%E7%A9%BF%EF%BC%8C%E9%A2%84%E7%83%AD%EF%BC%8C%E6%9B%B4%E6%96%B0%EF%BC%8C%E9%99%8D%E7%BA%A7/" itemprop="url">redis缓存雪崩，穿透，击穿，预热，更新，降级</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T19:29:30+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="redis-雪崩："><a href="#redis-雪崩：" class="headerlink" title="redis 雪崩："></a>redis 雪崩：</h1><p>雪崩就是指缓存中<strong>大批量热点数据过期</strong>后系统涌入大量查询请求，因为<strong>大部分数据在Redis层已经失</strong>效，请求渗透到<strong>数据库层</strong>，大批量请求犹如洪水一般涌入，引起数据库压力造成查询堵塞甚至宕机。</p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.png" alt="image"></p>
<h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><ol>
<li>将缓存失效时间分散开，比如每个key的过期时间是随机，防止同一时间大量数据过期现象发生，这样不会出现同一时间全部请求都落在数据库层，如果缓存数据库是分布式部署，将热点数据均匀分布在不同Redis和数据库中，有效分担压力，别一个人扛。</li>
<li>简单粗暴，让Redis数据永不过期（如果业务准许，比如不用更新的名单类）。当然，如果业务数据准许的情况下可以，比如中奖名单用户，每期用户开奖后，名单不可能会变了，无需更新。</li>
<li>采用限流算法，限制请求流量，业务有损；</li>
<li>加锁访问，但是吞吐量会明显下降。</li>
<li>采购第三方Redis</li>
</ol>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A92.png" alt="image"></p>
<ol start="6">
<li>多缓存结合</li>
</ol>
<img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A93.png" style="zoom:33%;" />

<h1 id="击穿和穿透"><a href="#击穿和穿透" class="headerlink" title="击穿和穿透"></a>击穿和穿透</h1><h2 id="redis-穿透"><a href="#redis-穿透" class="headerlink" title="redis 穿透"></a>redis 穿透</h2><p>穿透是指绕过Reids，调用者发起的请求参数（key）在缓存和数据库中都不存在，通过不存在的key，成功穿透到系统底层，大规模不断发起不存在的key检索请求导致系统压力过大最后故障。</p>
<p>造成穿透的伪代码多为这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(redis.get(key) == <span class="keyword">null</span>)&#123;</span><br><span class="line">  <span class="comment">// redis数据不存在或已经过期 查询数据库</span></span><br><span class="line"> Object value = dao.query(key);</span><br><span class="line">  <span class="comment">// 重新将value刷入缓存。</span></span><br><span class="line">  redis.set(key);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> reids.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="以mall项目为例子"><a href="#以mall项目为例子" class="headerlink" title="以mall项目为例子"></a>以mall项目为例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;CategoryVO&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">String catsStr = redisOperator.get(<span class="string">&quot;subCat:&quot;</span> + rootCatId);</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isBlank(catsStr))&#123;</span><br><span class="line">    list = categoryService.getSubCatList(rootCatId);</span><br><span class="line">    redisOperator.set(<span class="string">&quot;subCat:&quot;</span> + rootCatId,JsonUtils.objectToJson(list));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    list = JsonUtils.jsonToList(catsStr,CategoryVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="攻击造成缓存穿透"><a href="#攻击造成缓存穿透" class="headerlink" title="攻击造成缓存穿透"></a>攻击造成缓存穿透</h3><p>不停地调用查询接口 查询 <strong>rootCatId == 99999</strong> 的子类造成不停查询数据库</p>
<h3 id="解决办法：-1"><a href="#解决办法：-1" class="headerlink" title="解决办法："></a>解决办法：</h3><ol>
<li><p>分布式布隆过滤器：布隆是BloomFilter音译过来的，Redis 自身支持BloomFilter。</p>
<p><strong>布隆过滤器缺点</strong>: 无法删除</p>
</li>
<li><p>返回空值：遇到数据库和Redis都查询不到的值，在Redis里set一个null value，过期时间很短，目的在于同一个key再次请求时直接返回null，避免穿透。</p>
</li>
<li><p>多级缓存。L1 为原始缓存（过期时间设置为短期），L2 为二级缓存（过期时间设置为长期）。L1 失效时可以继续访问 L2，避免同时失效。不过多了一级缓存，存储成本更高，而且多个缓存之间的数据一致性问题挑战也大。</p>
</li>
</ol>
<h2 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h2><p>BloomFilter：即布隆过滤器。可以用于检索一个元素是否在一个集合中。</p>
<h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><p>BloomFilter检索一个元素是否在一个集合中有一定的错误率（很低），但不会漏判。</p>
<ul>
<li><strong>如果判断一个key不在集合中，那一定不在</strong>。</li>
<li><strong>如果判断一个key存在，那不一定真的在</strong>。</li>
</ul>
<p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 <strong>“某样东西一定不存在或者可能存在”</strong>。</p>
<p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>基本思想是利用一个足够好的Hash函数将一个字符串映射到二进制位数组中的某一位，这样不管字符串如何长，都只有一位，因此存储空间就极大的提升了。但是不管hash函数如何高效，总是会存在Hash冲突，尤其是数据量变大的时候，而BloomFilter是利用多个不同的Hash函数来解决“冲突”，即一次采用多个Hash函数把数据映射到不同的位上，降低了冲突概率。如下图所示，</p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt="image">subCat:9999 会被误判为存在</p>
<p>如何根据输入元素个数n，确定位数组m的大小及Hash函数个数？已知文献证明，当Hash函数个数k=(ln2)*(m/n)时错误率最小。</p>
<p>BloomFilter有个缺点是不能删除数据，因为删除数据可能会影响到其它数据，有一些增强算法可以实现改功能，但代价比较大，不建议使用。</p>
<p>BloomFilter十分适合海量数据去重、过滤，尤其是当检测的字符串比较大时，极大地节省内存和存储空间，同时查询效率也十分高效。如果只是在内存使用，直接使用guava包的api即可；如果要做到分布式，结合Redis可以高效实现分布式的过滤效果。</p>
<h2 id="redis击穿"><a href="#redis击穿" class="headerlink" title="redis击穿"></a>redis击穿</h2><p>击穿和穿透概念类似，一般是指一个key被穿透，这个key是热点key，同一个key会被有成千上万次请求，比如微博热点排行榜，key是小时时间戳，value是个list的榜单。每个小时产生一个key，这个key会有百万QPS，如果这个key失效了，就像保险丝熔断，百万QPS直接压垮数据库。</p>
<h3 id="解决办法：-2"><a href="#解决办法：-2" class="headerlink" title="解决办法："></a>解决办法：</h3><p>业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。类似下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(key)</span> </span>&#123;</span><br><span class="line">    String value = redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">//代表缓存值过期</span></span><br><span class="line">        <span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line">        <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;  <span class="comment">//代表设置成功</span></span><br><span class="line">            value = db.get(key);</span><br><span class="line">            redis.set(key, value, expire_secs);</span><br><span class="line">            redis.del(key_mutex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">            sleep(<span class="number">50</span>);</span><br><span class="line">            get(key);  <span class="comment">//重试</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;      </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h1><p>缓存预热这个应该是一个比较常见的概念，相信都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p>解决思路：</p>
<p>1、直接写个缓存刷新页面，上线时手工操作下；</p>
<p>2、数据量不大，可以在项目启动的时候自动进行加载；</p>
<p>3、定时刷新缓存；</p>
<h1 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h1><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<p>（1）定时去清理过期的缓存；</p>
<p>（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</p>
<p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！</p>
<h1 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h1><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<p>（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p>
<p>（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</p>
<p>（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</p>
<p>（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/redis%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/redis%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5/" itemprop="url">redis缓存读写策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T16:43:29+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="如何保证缓存和数据库数据的一致性？-重要"><a href="#如何保证缓存和数据库数据的一致性？-重要" class="headerlink" title="如何保证缓存和数据库数据的一致性？(重要)"></a>如何保证缓存和数据库数据的一致性？(重要)</h1><p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p>
<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p>
<ol>
<li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li><strong>增加cache更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。</li>
</ol>
<h1 id="redis缓存读写策略"><a href="#redis缓存读写策略" class="headerlink" title="redis缓存读写策略"></a>redis缓存读写策略</h1><ul>
<li><p>Cache Aside （旁路缓存模式）</p>
<ul>
<li>先更新数据库，再更新缓存。这种做法最大的问题就是两个并发的写操作导致脏数据</li>
<li>先删除缓存，再更新数据库。这个逻辑是错误的，因为两个并发的读和写操作导致脏数据</li>
<li>先更新数据库，再删除缓存（在实际的系统中也推荐使用这种方式）</li>
</ul>
</li>
<li><p>Read/Write Through Pattern（读写穿透）</p>
</li>
<li><p>Write-behind caching（异步缓存写入）</p>
</li>
</ul>
<h2 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache Aside Pattern（旁路缓存模式）"></a>Cache Aside Pattern（旁路缓存模式）</h2><ul>
<li><p><strong>Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。</strong></p>
</li>
<li><p>Cache Aside Pattern 中服务端需要同时维系 DB 和 cache，并且是以 DB 的结果为准。</p>
</li>
<li><p>保证最终一致性的解决方案是缓存设置过期时间。</p>
</li>
</ul>
<h3 id="缓存读步骤"><a href="#缓存读步骤" class="headerlink" title="缓存读步骤"></a>缓存读步骤</h3><ul>
<li>从 cache 中读取数据，读取到就直接返回</li>
<li>cache中读取不到的话，就从 DB 中读取数据返回</li>
<li>再把数据放到 cache 中。</li>
</ul>
<img src="https://img-blog.csdnimg.cn/img_convert/a8c18b5f5b1aed03234bcbbd8c173a87.png" alt="img" style="zoom: 50%;" />

<h3 id="缓存写步骤"><a href="#缓存写步骤" class="headerlink" title="缓存写步骤"></a>缓存写步骤</h3><h4 id="方案一：先更新缓存，再更新数据库"><a href="#方案一：先更新缓存，再更新数据库" class="headerlink" title="方案一：先更新缓存，再更新数据库"></a>方案一：先更新缓存，再更新数据库</h4><p>不推荐。</p>
<ol>
<li>先更新缓存</li>
<li>若更新数据库失败，还需再更新缓存。</li>
</ol>
<h4 id="方案二：先更新数据库，再更新缓存"><a href="#方案二：先更新数据库，再更新缓存" class="headerlink" title="方案二：先更新数据库，再更新缓存"></a>方案二：先更新数据库，再更新缓存</h4><p>不推荐。</p>
<p>同时有请求A和请求B进行更新操作，请求A与B在不同线程，可能会出现：</p>
<ol>
<li>请求A更新了数据库</li>
<li>请求B更新了数据库</li>
<li>请求B更新了缓存</li>
<li>请求A更新了缓存</li>
</ol>
<p>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。</p>
<h4 id="方案三：先删除缓存，再更新数据库"><a href="#方案三：先删除缓存，再更新数据库" class="headerlink" title="方案三：先删除缓存，再更新数据库"></a>方案三：先删除缓存，再更新数据库</h4><p>有点问题。</p>
<p>有一个请求A进行更新操作，另一个请求B进行查询操作，可能会出现：</p>
<p>（1）、单个数据库</p>
<ol>
<li>请求A进行写操作，删除缓存</li>
<li>请求B查询发现缓存不存在</li>
<li>请求B去数据库查询得到旧值</li>
<li>请求B将旧值写入缓存</li>
<li>请求A将新值写入数据库</li>
</ol>
<p>（2）、读写分离架构</p>
<ol>
<li><p>请求A进行写操作，删除缓存</p>
</li>
<li><p>请求A将数据写入数据库了，</p>
</li>
<li><p>请求B查询缓存发现，缓存没有值</p>
</li>
<li><p>请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值</p>
</li>
<li><p>请求B将旧值写入缓存</p>
</li>
<li><p>数据库完成主从同步，从库变为新值</p>
</li>
</ol>
<p>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据</p>
<h5 id="解决方案：延时双删策略"><a href="#解决方案：延时双删策略" class="headerlink" title="解决方案：延时双删策略"></a>解决方案：延时双删策略</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void write(String key,Object data)&#123;</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">    db.updateData(data);</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先淘汰缓存</li>
<li>再写数据库（这两步和原来一样）</li>
<li>休眠1秒</li>
<li>再次淘汰缓存</li>
</ol>
<p>自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>
<p>对于MySQL读写分离架构，只是睡眠时间修改为在主从同步的延时时间基础上，加几百ms。</p>
<h4 id="方案四：先更新数据库，再删除缓存"><a href="#方案四：先更新数据库，再删除缓存" class="headerlink" title="方案四：先更新数据库，再删除缓存"></a>方案四：先更新数据库，再删除缓存</h4><img src="https://img-blog.csdnimg.cn/img_convert/5687fe759a1dac9ed9554d27e3a23b6d.png" alt="img" style="zoom:50%;" />

<p>极端情况有问题。</p>
<p>有一个请求A进行更新操作，另一个请求B进行查询操作，可能会出现：</p>
<ol>
<li>请求A查询数据库得到一个旧值</li>
<li>请求B将新值写入数据库</li>
<li>请求B删除缓存</li>
<li>请求A将查到的旧值写入缓存</li>
</ol>
<p>步骤2的<strong>写数据库操作比步骤1的读数据库操作耗时更短</strong>，才有可能使得步骤3先于步骤4。可是，数据库的<strong>读操作的速度远快于写操作</strong>的，因此步骤2耗时比步骤1更短，这一情形很难出现。</p>
<h5 id="解决方案：延时双删策略-1"><a href="#解决方案：延时双删策略-1" class="headerlink" title="解决方案：延时双删策略"></a>解决方案：延时双删策略</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void write(String key,Object data)&#123;</span><br><span class="line">    db.updateData(data);</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先写数据库</li>
<li>再淘汰缓存</li>
<li>休眠1秒</li>
<li>再次淘汰缓存</li>
</ol>
<h4 id="方案三与方案四还存在问题"><a href="#方案三与方案四还存在问题" class="headerlink" title="方案三与方案四还存在问题"></a>方案三与方案四还存在问题</h4><ul>
<li>问题一:同步双删导致并发降低</li>
<li>问题二:比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况。</li>
</ul>
<h5 id="问题一解决方案"><a href="#问题一解决方案" class="headerlink" title="问题一解决方案"></a>问题一解决方案</h5><p>异步。</p>
<h5 id="问题二解决方案"><a href="#问题二解决方案" class="headerlink" title="问题二解决方案"></a>问题二解决方案</h5><p>提供一个保障的重试机制。</p>
<h6 id="方案一：消息队列方式"><a href="#方案一：消息队列方式" class="headerlink" title="方案一：消息队列方式"></a>方案一：消息队列方式</h6><p>更新数据库数据<br>缓存因为种种问题删除失败<br>将需要删除的key发送至消息队列<br>自己消费消息，获得需要删除的key<br>继续重试删除操作，直到成功</p>
<p>业务线代码侵入较大。</p>
<h6 id="方案二：订阅binlong方式"><a href="#方案二：订阅binlong方式" class="headerlink" title="方案二：订阅binlong方式"></a>方案二：订阅binlong方式</h6><p>更新数据库数据<br>数据库会将操作信息写入binlog日志当中<br>订阅程序提取出所需要的数据以及key<br>另起一段非业务代码，获得该信息<br>尝试删除缓存操作，发现删除失败<br>将这些信息发送至消息队列<br>重新从消息队列中获得该数据，重试操作。</p>
<blockquote>
<p>订阅binlog程序在MySQL中有阿里开源的中间件叫canal。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试也可。</p>
</blockquote>
<p><strong>总结</strong></p>
<p>根据数据实时性要求，以及系统并发量考虑。</p>
<p>实时性不强，则可以选择设定缓存过期时间，先删缓存再更新数据库或先更新数据库再删缓存方案都可行。</p>
<p>实时性较强的，又有大并发量可以考虑延迟双删策略。</p>
<p>至于其他如请求串行化，放入同一个队列中依次执行的，复杂没必要。</p>
<h3 id="Cache-Aside-Pattern的缺陷"><a href="#Cache-Aside-Pattern的缺陷" class="headerlink" title="Cache Aside Pattern的缺陷"></a>Cache Aside Pattern的缺陷</h3><ul>
<li><p>缺陷1：首次请求数据一定不在 cache 的问题</p>
<p>解决办法：可以将热点数据可以提前放入cache 中。</p>
</li>
<li><p>写操作比较频繁的话导致cache中的数据会被频繁被删除，这样会影响缓存命中率 。</p>
<p>解决办法：</p>
<ul>
<li>数据库和缓存数据强一致场景 ：更新DB的时候同样更新cache，不过我们需要加一个锁/分布式锁来保证更新cache的时候不存在线程安全问题。</li>
<li>可以短暂地允许数据库和缓存数据不一致的场景 ：更新DB的时候同样更新cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li>
</ul>
</li>
</ul>
<h2 id="Read-Write-Through-Pattern（读写穿透）"><a href="#Read-Write-Through-Pattern（读写穿透）" class="headerlink" title="Read/Write Through Pattern（读写穿透）"></a>Read/Write Through Pattern（读写穿透）</h2><p>Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。</p>
<p>这种缓存读写策略在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为使用的分布式缓存 Redis 并没有提供 cache 将数据写入DB的功能。</p>
<p><strong>写（Write Through）：</strong></p>
<ul>
<li>先查 cache，cache 中不存在，直接更新 DB。</li>
<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（<strong>同步更新 cache 和 DB</strong>）。</li>
</ul>
<p>简单画了一张图帮助大家理解写的步骤。</p>
<p><img src="https://img-blog.csdnimg.cn/20210201100340808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70&ynotemdtimestamp=1617437153078" alt="img"></p>
<p><strong>读(Read Through)：</strong></p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回 。</li>
<li>读取不到的话，先从 DB 加载，写入到 cache 后返回响应。</li>
</ul>
<p>简单画了一张图帮助大家理解读的步骤。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9ada757c78614934aca11306f334638d.png?ynotemdtimestamp=1617437153078" alt="img"></p>
<p>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。</p>
<p>和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。</p>
<h1 id="Write-Behind-Pattern（异步缓存写入）"><a href="#Write-Behind-Pattern（异步缓存写入）" class="headerlink" title="Write Behind Pattern（异步缓存写入）"></a>Write Behind Pattern（异步缓存写入）</h1><p>Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 DB 的读写。</p>
<p>但是，两个又有很大的不同：<strong>Read/Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。</strong></p>
<p>很明显，这种方式对数据一致性带来了更大的挑战，比如cache数据可能还没异步更新DB的话，cache服务可能就就挂掉了。</p>
<p>这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 InnoDB Buffer Pool 机制都用到了这种策略。</p>
<p>Write Behind Pattern 下 DB 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/redis%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/redis%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/" itemprop="url">redis实际应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T16:32:57+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis知识点</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/redis-redis%E5%BA%94%E7%94%A8/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis应用</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis-最适合的场景是什么？"><a href="#Redis-最适合的场景是什么？" class="headerlink" title="Redis 最适合的场景是什么？"></a>Redis 最适合的场景是什么？</h1><p>1、会话缓存（Session Cache）</p>
<p>最常用的一种使用 Redis 的情景是会话缓存（session cache）。用 Redis 缓存会话比其他存储（如 Memcached）的优势在于：Redis 提供持久化。</p>
<p>2、全页缓存（FPC）</p>
<p>除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。能帮助你以最快速度加载你曾浏览过的页面。</p>
<p>3、队列</p>
<p>Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push/pop 操作。</p>
<p>4，排行榜/计数器</p>
<p>Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的 10个用户，我们只需要像下面一样执行即可： 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES。</p>
<p>5、发布/订阅</p>
<p>最后（但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。在社交网络中甚至可以用 Redis 的发布/订阅功能来建立聊天系统！</p>
<h1 id="Redis-做异步队列（发布-订阅）"><a href="#Redis-做异步队列（发布-订阅）" class="headerlink" title="Redis 做异步队列（发布/订阅）"></a>Redis 做异步队列（发布/订阅）</h1><p>一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。</p>
<h2 id="可不可以不用-sleep-呢？"><a href="#可不可以不用-sleep-呢？" class="headerlink" title="可不可以不用 sleep 呢？"></a>可不可以不用 sleep 呢？</h2><p>list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。</p>
<h2 id="能不能生产一次消费多次呢？"><a href="#能不能生产一次消费多次呢？" class="headerlink" title="能不能生产一次消费多次呢？"></a>能不能生产一次消费多次呢？</h2><p>使用 pub/sub 主题订阅者模式，可以实现1:N 的消息队列。</p>
<h2 id="pub-sub-有什么缺点？"><a href="#pub-sub-有什么缺点？" class="headerlink" title="pub/sub 有什么缺点？"></a>pub/sub 有什么缺点？</h2><p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 RabbitMQ等。</p>
<h2 id="redis-如何实现延时队列？"><a href="#redis-如何实现延时队列？" class="headerlink" title="redis 如何实现延时队列？"></a>redis 如何实现延时队列？</h2><p>使用 sortedset，拿时间戳作为score，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。<br>40.使用过 Redis 分布式锁么，它是什么回事？</p>
<h1 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h1><p>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止忘记释放</p>
<h1 id="Redis-Cookie分布式会话"><a href="#Redis-Cookie分布式会话" class="headerlink" title="Redis+Cookie分布式会话"></a>Redis+Cookie分布式会话</h1><h2 id="如果在setnx之后执行expire之前进程意外crash或者重启维护了，怎么办？"><a href="#如果在setnx之后执行expire之前进程意外crash或者重启维护了，怎么办？" class="headerlink" title="如果在setnx之后执行expire之前进程意外crash或者重启维护了，怎么办？"></a>如果在setnx之后执行expire之前进程意外crash或者重启维护了，怎么办？</h2><p>setnx和expire合成一条指令</p>
<h1 id="redis批量查询优化"><a href="#redis批量查询优化" class="headerlink" title="redis批量查询优化"></a>redis批量查询优化</h1><h2 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 大量key查询</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/getALot&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getALot</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; resutl = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String k:keys) &#123;</span><br><span class="line">        resutl.add(redisOperator.get(k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resutl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h2><h3 id="mget进行批量查询"><a href="#mget进行批量查询" class="headerlink" title="mget进行批量查询"></a>mget进行批量查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量查询 mget</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/mget&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">mget</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; keysList = Arrays.asList(keys);</span><br><span class="line">    <span class="keyword">return</span> redisOperator.mget(keysList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pipeline-进行批量查询"><a href="#pipeline-进行批量查询" class="headerlink" title="pipeline 进行批量查询"></a>pipeline 进行批量查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量查询 pipeline</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/batchGet&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">batchGet</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; keysList = Arrays.asList(keys);</span><br><span class="line">    <span class="keyword">return</span> redisOperator.batchGet(keysList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="redis热点数据问题"><a href="#redis热点数据问题" class="headerlink" title="redis热点数据问题"></a>redis热点数据问题</h1><h2 id="MySQL-里有-2000w-数据，Redis-中只存-20w-的数据，如何保证Redis-中的数据都是热点数据？"><a href="#MySQL-里有-2000w-数据，Redis-中只存-20w-的数据，如何保证Redis-中的数据都是热点数据？" class="headerlink" title="MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证Redis 中的数据都是热点数据？"></a>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证Redis 中的数据都是热点数据？</h2><p>限定 Redis 占用的内存，Redis 会根据自身数据淘汰策略，加载热数据到内存。 所以，计算一下 20W 数据大约占用的内存，然后设置一下 Redis 内存限制即可。</p>
<p>Redis存储数据会限制它内存大小，如果超过了最大内存容量，会触发数据淘汰策略</p>
<h2 id="由于内存限制，导致了Redis中只能存储最多1W条的数据信息，如何确保这1w条数据是最热门的数据？"><a href="#由于内存限制，导致了Redis中只能存储最多1W条的数据信息，如何确保这1w条数据是最热门的数据？" class="headerlink" title="由于内存限制，导致了Redis中只能存储最多1W条的数据信息，如何确保这1w条数据是最热门的数据？"></a>由于内存限制，导致了Redis中只能存储最多1W条的数据信息，如何确保这1w条数据是最热门的数据？</h2><h3 id="热点数据排序（点击次数）"><a href="#热点数据排序（点击次数）" class="headerlink" title="热点数据排序（点击次数）"></a>热点数据排序（点击次数）</h3><p>既然热门数据，那么就需要有排序，使用redis中的zset数据类型是很自然的想法。数据中的某个唯一字段作为zset中的value，而点击次数作为score，记为click_zset。这样就可选出最热门的数据。而数据，则直接用HashMap存储。</p>
<h3 id="热点数据时间（近期访问）"><a href="#热点数据时间（近期访问）" class="headerlink" title="热点数据时间（近期访问）"></a>热点数据时间（近期访问）</h3><p>既然只能存1w条数据且需要是热门数据，那么，点击次数是一方面，时效性也是一方面，如何保证？可以另起一个zset，数据的字段为value，而每次点击时更新当前时间戳为其score，记为time_zset这样，就可以记录时间。在后台跑一个任务，间隔一定时间段删除两个zset中长时间没有发生点击事件的键，并删除hash数据，为产生的新数据腾出数据空间。</p>
<h3 id="处理新热点数据"><a href="#处理新热点数据" class="headerlink" title="处理新热点数据"></a>处理新热点数据</h3><p>如果有空间，则保存到自己的hashmap，并将key存到两个zset中。 而没有空间时，就应该在click_zset中取出点击次数排在最前第1w位后面的键，删除对应的hash数据。然后看这1w个score的值，然后把key放入两个zset中即可。</p>
<h1 id="redis在自己工作中的使用"><a href="#redis在自己工作中的使用" class="headerlink" title="redis在自己工作中的使用"></a>redis在自己工作中的使用</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37334135/article/details/77751562?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.channel_param">参考</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/yuanyayuan/yymall/blob/master/mall_api/src/main/java/com/nexus/mall/api/controller/ShopcatController.java">源代码(登录状态购物车修改)</a>，<a target="_blank" rel="noopener" href="https://github.com/yuanyayuan/yymall/blob/master/mall_api/src/main/java/com/nexus/mall/api/controller/PassportController.java">源代码(用户登录后购物车同步)</a></p>
<p>未实现购物车数量修改，未登录时由前端修改cookie</p>
<h2 id="redis结合cookie实现购物车"><a href="#redis结合cookie实现购物车" class="headerlink" title="redis结合cookie实现购物车"></a>redis结合cookie实现购物车</h2><h3 id="未登录状态下购物车功能实现"><a href="#未登录状态下购物车功能实现" class="headerlink" title="未登录状态下购物车功能实现"></a>未登录状态下购物车功能实现</h3><blockquote>
<p> 把购物车信息写入cookie。</p>
</blockquote>
<ul>
<li>优点：<br>1、不占用服务端存储空间<br>2、用户体验好。<br>3、代码实现简单。</li>
<li>缺点：<br>1、cookie中保存的容量有限。最大4k<br>2、把购物车信息保存在cookie中，更换设备购物车信息不能同步。</li>
</ul>
<h4 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h4><ol>
<li><p>完全由前端实现，操作cookie存储购物车信息修改</p>
</li>
<li><p>后端提供接口，实现cookie的信息修改</p>
<ul>
<li>购物车新增商品分析：</li>
</ul>
<ol>
<li>从cookie中获取购物车列表</li>
<li>遍历购物车列表，判断需要添加的商品在购物车列表是否存在</li>
<li>商品存在的话，那么取出该商品原来的数量+添加的数量作为该商品现在的数量</li>
<li>如果商品不存在，那么调用服务，根据传来的商品id查询商品数量，设置商品的数量为页面传来的数量，取商品的第一张图片(购物车列表只展示一张图片)。</li>
<li>把修改后的购物车列表重新存入到cookie中</li>
</ol>
<ul>
<li>购物车删除商品分析</li>
</ul>
<ol>
<li>从cookie中获取购物车列表</li>
<li>遍历，查找到要删除的商品</li>
<li>将该商品从购物车列表移除</li>
<li>更新后的购物车列表重新写入cookie</li>
</ol>
<ul>
<li>购物车列表页面修改商品数量(点击“+”或者“-”)</li>
</ul>
<ol>
<li>从cookie中获取购物车列表</li>
<li>取所选择的需要更新的商品</li>
<li>更新商品数量</li>
<li>物车信息写入cookie</li>
</ol>
</li>
</ol>
<h3 id="登录状态下购物车功能的实现"><a href="#登录状态下购物车功能的实现" class="headerlink" title="登录状态下购物车功能的实现"></a>登录状态下购物车功能的实现</h3><blockquote>
<p>未登录状态下，把购物车数据保存到cookie中。登录状态下，需要把购物车数据保存到服务端。需要永久保存，可以保存到数据库中也可以把购物车数据保存到redis中，但数据库和redis同时保存购物车信息时需考虑数据一致性问题</p>
</blockquote>
<h4 id="redis使用的数据类型"><a href="#redis使用的数据类型" class="headerlink" title="redis使用的数据类型"></a>redis使用的数据类型</h4><ol>
<li> 使用hash数据类型</li>
<li>Hash的key应该是用户id。Hash中的field是商品id，value可以是把商品信息转换成json</li>
</ol>
<h4 id="实现方式：-1"><a href="#实现方式：-1" class="headerlink" title="实现方式："></a>实现方式：</h4><p>把购物车数据保存到redis(<em>数据类型是hash  key:用户id   field:商品id  value:商品信息</em>)</p>
<ul>
<li>购物车新增商品分析</li>
</ul>
<ol>
<li>判断商品是否存在</li>
<li>如果存在,把 value中的json转换成购物车对象，增加数量，写回redis</li>
<li>如果存在，根据商品id取商品信息，设置购物车数量，添加到购物车列表</li>
</ol>
<ul>
<li><p>修改购物车商品数量</p>
<ol>
<li>根据用户id，商品id从redis中取出对应的商品</li>
<li> 设置商品的数量</li>
<li> 该商品更新到redis中</li>
</ol>
</li>
<li><p>删除购物车商品</p>
<ol>
<li>获取redis中购物车</li>
<li>如果redis中已经有购物车了，判断购物车中是否存在已有商品，如果有的话则删除</li>
</ol>
</li>
<li><p>用户登录，购物车同步</p>
<ol>
<li>redis中无数据，<pre><code>     - 如果cookie中的购物车为空，那么这个时候不做任何处理
     - 如果cookie中的购物车不为空，此时直接放入redis中
</code></pre>
</li>
<li>redis中有数据，<ul>
<li>如果cookie中的购物车为空，那么直接把redis的购物车覆盖本地cookie</li>
<li>如果cookie中的购物车不为空，如果cookie中的某个商品在redis中存在，则以cookie为主，删除redis中的，把cookie中的商品直接覆盖redis中（参考京东）</li>
</ul>
</li>
<li>同步到redis中去了以后，覆盖本地cookie购物车的数据，保证本地购物车的数据是同步最新的</li>
</ol>
</li>
</ul>
<h2 id="缓存用户权限，不用每次登陆都去数据库查询"><a href="#缓存用户权限，不用每次登陆都去数据库查询" class="headerlink" title="缓存用户权限，不用每次登陆都去数据库查询"></a>缓存用户权限，不用每次登陆都去数据库查询</h2><p><a target="_blank" rel="noopener" href="http://www.macrozheng.com/#/technology/redis_permission">参考</a></p>
<h3 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h3><p>用户登录请求会经过<code>JwtAuthenticationTokenFilter </code>验证token，其中有一步会从数据库中查询登录用户信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String authHeader = request.getHeader(<span class="keyword">this</span>.tokenHeader);</span><br><span class="line">    <span class="keyword">if</span> (authHeader != <span class="keyword">null</span> &amp;&amp; authHeader.startsWith(<span class="keyword">this</span>.tokenHead)) &#123;</span><br><span class="line">        <span class="comment">// The part after &quot;Bearer &quot;</span></span><br><span class="line">        String authToken = authHeader.substring(<span class="keyword">this</span>.tokenHead.length());</span><br><span class="line">        String username = jwtTokenUtil.getUserNameFromToken(authToken);</span><br><span class="line">        log.info(<span class="string">&quot;checking username:&#123;&#125;&quot;</span>, username);</span><br><span class="line">        <span class="keyword">if</span> (username != <span class="keyword">null</span> &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//此处会从数据库中获取登录用户信息</span></span><br><span class="line">            UserDetails userDetails = <span class="keyword">this</span>.userDetailsService.loadUserByUsername(username);</span><br><span class="line">            <span class="keyword">if</span> (jwtTokenUtil.validateToken(authToken, userDetails)) &#123;</span><br><span class="line">                UsernamePasswordAuthenticationToken authentication = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(userDetails, <span class="keyword">null</span>, userDetails.getAuthorities());</span><br><span class="line">                authentication.setDetails(<span class="keyword">new</span> WebAuthenticationDetailsSource().buildDetails(request));</span><br><span class="line">                log.info(<span class="string">&quot;authenticated user:&#123;&#125;&quot;</span>, username);</span><br><span class="line">                SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问任何接口，都会从数据库中查询用户信息和用户所拥有的资源信息，每次访问接口都触发这种操作，有的时候会带来一定的性能问题。</p>
<h3 id="使用redis作为缓存"><a href="#使用redis作为缓存" class="headerlink" title="使用redis作为缓存"></a>使用redis作为缓存</h3><blockquote>
<p>主要是获取用户信息和获取用户的资源信息这两个操作。当查询数据时，先去Redis缓存中查询，如果Redis中没有，再从数据库查询，查询到以后在把数据存储到Redis中去。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UmsAdminService实现类</span></span><br><span class="line"><span class="comment"> * Created by macro on 2018/4/26.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UmsAdminServiceImpl</span> <span class="keyword">implements</span> <span class="title">UmsAdminService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//专门用来操作Redis缓存的业务类</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UmsAdminCacheService adminCacheService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UmsAdmin <span class="title">getAdminByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先从缓存中获取数据</span></span><br><span class="line">        BackendAdmin admin = adminCacheService.getAdmin(username);</span><br><span class="line">        <span class="keyword">if</span>(admin!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>  admin;</span><br><span class="line">        &#125;</span><br><span class="line">        Example example = <span class="keyword">new</span> Example(BackendAdmin.class);</span><br><span class="line">        Example.Criteria criteria = example.createCriteria();</span><br><span class="line">        criteria.andEqualTo(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line">        List&lt;BackendAdmin&gt; adminList = adminMapper.selectByExample(example);</span><br><span class="line">        <span class="keyword">if</span> (adminList != <span class="keyword">null</span> &amp;&amp; adminList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            admin = adminList.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//将数据库中的数据存入缓存中</span></span><br><span class="line">            adminCacheService.setAdmin(admin);</span><br><span class="line">            <span class="keyword">return</span> admin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;UmsResource&gt; <span class="title">getResourceList</span><span class="params">(Long adminId)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先从缓存中获取数据</span></span><br><span class="line">        List&lt;BackendResource&gt; resourceList = adminCacheService.getResourceList(adminId);</span><br><span class="line">        <span class="keyword">if</span>(CollUtil.isNotEmpty(resourceList))&#123;</span><br><span class="line">            <span class="keyword">return</span>  resourceList;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//缓存中没有从数据库中获取</span></span><br><span class="line">        resourceList = adminRoleRelationMapperCustom.getResourceList(adminId);</span><br><span class="line">        <span class="keyword">if</span>(CollUtil.isNotEmpty(resourceList))&#123;</span><br><span class="line">            <span class="comment">//将数据库中的数据存入缓存中</span></span><br><span class="line">            adminCacheService.setResourceList(adminId,resourceList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resourceList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/yuanyayuan/yymall/blob/master/mall_backend_service/src/main/java/com/nexus/mall/service/backend/BackendAdminCacheService.java">后台用户缓存操作类</a></p>
<h3 id="使用AOP处理缓存操作异常"><a href="#使用AOP处理缓存操作异常" class="headerlink" title="使用AOP处理缓存操作异常"></a>使用AOP处理缓存操作异常</h3><blockquote>
<p>为什么要用AOP来解决这个问题呢？因为我们的缓存业务类<code>UmsAdminCacheService</code>已经写好了，要保证缓存业务类中的方法执行不影响正常的业务逻辑，就需要在所有方法中添加<code>try catch</code>逻辑。使用AOP，我们可以在一个地方写上<code>try catch</code>逻辑，然后应用到所有方法上去</p>
</blockquote>
<ol>
<li><p>定义切面，在相关缓存业务类上面应用，在它的环绕通知中直接处理掉异常，保障后续操作能执行</p>
<blockquote>
<p>不过并不是所有的方法都需要处理异常的，比如我们的验证码存储，如果我们的Redis宕机了，我们的验证码存储接口需要的是报错，而不是返回执行成功。</p>
<p>对于上面这种需求我们可以通过自定义注解来完成，首先我们自定义一个<code>CacheException</code>注解，如果方法上面有这个注解，发生异常则直接抛出。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义注解，有该注解的缓存方法会抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CacheException &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(2)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * com.nexus.mall.service.backend.*CacheService.*(..)) || execution(public * com.nexus.mall.service.*CacheService.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Around(&quot;cacheAspect()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) signature;</span><br><span class="line">        Method method = methodSignature.getMethod();</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="comment">//有CacheException注解的方法需要抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(CacheException.class)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> throwable;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.error(throwable.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>接下来我们需要把<code>@CacheException</code>注解应用到存储和获取验证码的方法上去，这里需要注意的是要<strong>应用在实现类上而不是接口上，因为<code>isAnnotationPresent</code>方法只能获取到当前方法上的注解，而不能获取到它实现接口方法上的注解。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UmsMemberCacheService实现类</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/3/14.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UmsMemberCacheServiceImpl</span> <span class="keyword">implements</span> <span class="title">UmsMemberCacheService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheException</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthCode</span><span class="params">(String telephone, String authCode)</span> </span>&#123;</span><br><span class="line">        String key = REDIS_DATABASE + <span class="string">&quot;:&quot;</span> + REDIS_KEY_AUTH_CODE + <span class="string">&quot;:&quot;</span> + telephone;</span><br><span class="line">        redisService.set(key,authCode,REDIS_EXPIRE_AUTH_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheException</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAuthCode</span><span class="params">(String telephone)</span> </span>&#123;</span><br><span class="line">        String key = REDIS_DATABASE + <span class="string">&quot;:&quot;</span> + REDIS_KEY_AUTH_CODE + <span class="string">&quot;:&quot;</span> + telephone;</span><br><span class="line">        <span class="keyword">return</span> (String) redisService.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="缓存一些热点数据"><a href="#缓存一些热点数据" class="headerlink" title="缓存一些热点数据"></a>缓存一些热点数据</h2><blockquote>
<p>缓存一些不常修改但是经常被访问的数据</p>
</blockquote>
<p>缓存商品分类，并防止缓存穿透</p>
<ul>
<li>显示一级分类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 首页分类展示需求：</span></span><br><span class="line"><span class="comment">     * 1. 第一次刷新主页查询大分类，渲染展示到首页</span></span><br><span class="line"><span class="comment">     * 2. 如果鼠标上移到大分类，则加载其子分类的内容，如果已经存在子分类，则不需要加载（懒加载）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;获取商品分类(一级分类)&quot;, notes = &quot;获取商品分类(一级分类)&quot;, httpMethod = &quot;GET&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/cats&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerResponse <span class="title">cats</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//引入redis缓存</span></span><br><span class="line">    List&lt;Category&gt; list;</span><br><span class="line">    String catStr = redisOperator.get(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(catStr))&#123;</span><br><span class="line">        list = categoryService.queryAllRootLevelCat();</span><br><span class="line">        redisOperator.set(<span class="string">&quot;cat&quot;</span>, JsonUtils.objectToJson(list));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        list = JsonUtils.jsonToList(catStr, Category.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ServerResponse.success(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据一级分类id查询下一层子分类信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;根据一级分类id查询下一层子分类信息&quot;, notes = &quot;根据一级分类id查询下一层子分类信息&quot;, httpMethod = &quot;GET&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/subCat/&#123;rootCatId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerResponse <span class="title">subCat</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@ApiParam(name = &quot;rootCatId&quot;, value = &quot;一级分类id&quot;, required = true)</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@PathVariable</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NotNull(message = &quot;分类不存在&quot;)</span></span></span></span><br><span class="line"><span class="function"><span class="params">    Integer rootCatId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;CategoryVO&gt; list;</span><br><span class="line">    String subCatStr = redisOperator.get(<span class="string">&quot;subCat:&quot;</span> + rootCatId);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(subCatStr))&#123;</span><br><span class="line">        list = categoryService.getSubCatList(rootCatId);</span><br><span class="line">        <span class="comment">/* Redis 防止缓存穿透</span></span><br><span class="line"><span class="comment">              查询的key在redis中不存在，</span></span><br><span class="line"><span class="comment">              对应的id在数据库也不存在，</span></span><br><span class="line"><span class="comment">              此时被非法用户进行攻击，大量的请求会直接打在db上，</span></span><br><span class="line"><span class="comment">              造成宕机，从而影响整个系统，</span></span><br><span class="line"><span class="comment">              这种现象称之为缓存穿透。</span></span><br><span class="line"><span class="comment">              解决方案：把空的数据也缓存起来，比如空字符串，空对象，空数组或list</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            redisOperator.set(<span class="string">&quot;subCat:&quot;</span> + rootCatId, JsonUtils.objectToJson(list));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redisOperator.set(<span class="string">&quot;subCat:&quot;</span> + rootCatId, JsonUtils.objectToJson(list), <span class="number">5</span>*<span class="number">60</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        list = JsonUtils.jsonToList(subCatStr, CategoryVO.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ServerResponse.success(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/redis%E6%8C%87%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/redis%E6%8C%87%E4%BB%A4/" itemprop="url">redis指令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T16:32:25+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis知识点</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/redis-redis%E5%BA%94%E7%94%A8/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis应用</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="redis指令"><a href="#redis指令" class="headerlink" title="redis指令"></a>redis指令</h1><ul>
<li>keys *：查看所有的key (不建议在生产上使用，有性能影响)</li>
<li>type key：key的类型</li>
<li>select index：切换数据库，总共默认16个</li>
<li>flushdb：删除当前下边db中的数据</li>
<li>flushall：删除所有db中的数据</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>string: 最简单的字符串类型键值对缓存，也是最基本的</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>get/set/del：查询/设置/删除</p>
</li>
<li><p>set rekey data：设置已经存在的key，会覆盖</p>
</li>
<li><p>setnx rekey data：设置已经存在的key，不会覆盖</p>
</li>
<li><p>set key value ex time：设置带过期时间的数据</p>
</li>
<li><p>expire key：设置过期时间</p>
</li>
<li><p>ttl：查看剩余时间，-1永不过期，-2过期</p>
</li>
<li><p>append key：合并字符串</p>
</li>
<li><p>strlen key：字符串长度</p>
</li>
<li><p>incr key：累加1</p>
</li>
<li><p>decr key：类减1</p>
</li>
<li><p>incrby key num：累加给定数值</p>
</li>
<li><p>decrby key num：累减给定数值</p>
</li>
<li><p>getrange key start end：截取数据，end=-1 代表到最后</p>
</li>
<li><p>setrange key start newdata：从start位置开始替换数据</p>
</li>
<li><p>mset：连续设值</p>
</li>
<li><p>mget：连续取值</p>
</li>
<li><p>msetnx：连续设置，如果存在则不设置</p>
</li>
</ul>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><h3 id="hash-1"><a href="#hash-1" class="headerlink" title="hash"></a>hash</h3><p>hash：类似map，存储结构化数据结构，比如存储一个对象（不能有嵌套对象）</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><ul>
<li>hset key property value：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt; hset user name imooc</span><br><span class="line">-&gt; 创建一个user对象，这个对象中包含name属性，name值为imooc</span><br></pre></td></tr></table></figure></li>
<li>hget user name：获得用户对象中name的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hmset：设置对象中的多个键值对</span><br><span class="line"> -&gt; hset user age 18 phone 139123123</span><br><span class="line"> hmsetnx：设置对象中的多个键值对，存在则不添加</span><br><span class="line"> -&gt; hset user age 18 phone 139123123</span><br></pre></td></tr></table></figure></li>
<li>hmget：获得对象中的多个属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt; hmget user age phone</span><br></pre></td></tr></table></figure></li>
<li>hgetall user：获得整个对象的内容</li>
<li>hincrby user age 2：累加属性</li>
<li>hincrbyfloat user age 2.2：累加属性</li>
<li>hlen user：有多少个属性</li>
<li>hexists user age：判断属性是否存在</li>
<li>hkeys user：获得所有属性</li>
<li>hvals user：获得所有值</li>
<li>hdel user：删除对象</li>
</ul>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h3 id="list-1"><a href="#list-1" class="headerlink" title="list"></a>list</h3><p>list：列表，[a, b, c, d, …]</p>
<h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><ul>
<li>lpush userList 1 2 3 4 5：构建一个list，从左边开始存入数据</li>
<li>rpush userList 1 2 3 4 5：构建一个list，从右边开始存入数据</li>
<li>lrange list start end：获得数据</li>
<li>lpop：从左侧开始拿出一个数据</li>
<li>rpop：从右侧开始拿出一个数据</li>
<li>llen list：list长度</li>
<li>lindex list index：获取list下标的值</li>
<li>lset list index value：把某个下标的值替换</li>
<li>linsert list before/after value：插入一个新的值</li>
<li>lrem list num value：删除几个相同数据</li>
<li>ltrim list start end：截取值，替换原来的list</li>
</ul>
<h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><h3 id="sorted-set："><a href="#sorted-set：" class="headerlink" title="sorted set："></a>sorted set：</h3><p>sorted set：排序的set，可以去重可以排序，比如可以根据用户积分做排名，积分作为set的一个数值，根据数值可以做排序。set中的每一个memeber都带有一个分数</p>
<h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>zadd zset 10 value1 20 value2 30 value3：设置member和对应的分数</p>
</li>
<li><p>zrange zset 0 -1：查看所有zset中的内容</p>
</li>
<li><p>zrange zset 0 -1 withscores：带有分数</p>
</li>
<li><p>zrank zset value：获得对应的下标</p>
</li>
<li><p>zscore zset value：获得对应的分数</p>
</li>
<li><p>zcard zset：统计个数</p>
</li>
<li><p>zcount zset 分数1 分数2：统计个数</p>
</li>
<li><p>zrangebyscore zset 分数1 分数2：查询分数之间的member(包含分数1 分数2)</p>
</li>
<li><p>zrangebyscore zset (分数1 (分数2：查询分数之间的member（不包含分数1 和 分数2）</p>
</li>
<li><p>zrangebyscore zset 分数1 分数2 limit start end：查询分数之间的member(包含分数1 分数2)，获得的结果集再次根据下标区间做查询</p>
</li>
<li><p>zrem zset value：删除member</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/" itemprop="url">redis内存淘汰机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T12:46:31+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis设置过期时间"><a href="#Redis设置过期时间" class="headerlink" title="Redis设置过期时间"></a>Redis设置过期时间</h1><ul>
<li>expire key time(以秒为单位)–这是最常用的方式</li>
<li>setex(String key, int seconds, String value)–字符串独有的方式</li>
</ul>
<p>注意：</p>
<ul>
<li>除了字符串自己独有设置过期时间的方法外，其他方法都需要依靠expire方法来设置时间</li>
<li>如果没有设置时间，那缓存就是永不过期</li>
<li>如果设置了过期时间，之后又想让缓存永不过期，使用persist key</li>
</ul>
<h1 id="Redis-给缓存数据设置过期时间有啥用？"><a href="#Redis-给缓存数据设置过期时间有啥用？" class="headerlink" title="Redis 给缓存数据设置过期时间有啥用？"></a>Redis 给缓存数据设置过期时间有啥用？</h1><p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？</p>
<p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接Out of memory。</p>
<p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong></p>
<p>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在1分钟内有效，用户登录的 token 可能只在 1 天内有效。</p>
<p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p>
<h1 id="Redis是如何判断数据是否过期的呢？"><a href="#Redis是如何判断数据是否过期的呢？" class="headerlink" title="Redis是如何判断数据是否过期的呢？"></a>Redis是如何判断数据是否过期的呢？</h1><p>Redis  通过一个叫做过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个key(键)，过期字典的值是一个long long类型的整数，这个整数保存了key所指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。 </p>
<h1 id="Redis-过期键的删除策略"><a href="#Redis-过期键的删除策略" class="headerlink" title="Redis 过期键的删除策略"></a>Redis 过期键的删除策略</h1><p>A、<strong>定期删除策略</strong>。用一个<strong>定时器</strong>来负责检查 key，过期则删除 key，注意这里并不是检查所有的 key 而是<strong>随机抽取进行检查</strong>。定期策略虽然让内存及时释放，但也会<strong>额外消耗 CPU 资源</strong>，通常 CPU 应该将时间尽量用于处理业务请求，而不是删除 key。</p>
<p>B、<strong>惰性删除策略</strong>。在你<strong>获取</strong>某个 key 的时候，redis 会检查一下，这个 key <strong>如果设置了过期时间那么是否过期了</strong>，如果<strong>过期</strong>则删除该 key。</p>
<hr>
<h1 id="Redis-的回收策略（淘汰策略）"><a href="#Redis-的回收策略（淘汰策略）" class="headerlink" title="Redis 的回收策略（淘汰策略）"></a>Redis 的回收策略（淘汰策略）</h1><h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2><p>如果<strong>定期删除没删除 key</strong>，然后也<strong>没及时去请求 key</strong>，即<strong>惰性删除也没生效</strong>，持续下去 redis 的内存会越来越高，当超过 redis 设置的内存最大使用量时，就会进行内存数据淘汰。redis 有 6 种淘汰策略：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>volatile-lru</td>
<td>从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td>volatile-ttl</td>
<td>从已设置过期时间的数据集中挑选将要过期的数据淘汰</td>
</tr>
<tr>
<td>volatile-random</td>
<td>从已设置过期时间的数据集中任意选择数据淘汰</td>
</tr>
<tr>
<td>allkeys-lru</td>
<td>从所有数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td>allkeys-random</td>
<td>从所有数据集中任意选择数据进行淘汰</td>
</tr>
<tr>
<td>noeviction</td>
<td>当内存不足以容纳新写入数据时，新写入操作会报错。很少使用</td>
</tr>
</tbody></table>
<blockquote>
<p>注意这里的 6 种机制，前缀 volatile 和 allkeys 用于区分淘汰数据的数据集是从已设置过期时间的数据集还是从全部数据集中选取，后面的 lru、ttl 以及 random 是三种不同的淘汰策略，再加上一种 no-enviction 永不回收的策略。其中最常使用的是 volatile-lru/allkeys-lru。</p>
</blockquote>
<ul>
<li>allkeys-lru：如果期望用户请求呈现幂律分布(power-law distribution)，也就是，期望一部分子集元素被访问得远比其他元素多时，可以使用allkeys-lru策略。在你不确定时这是一个好的选择</li>
<li>allkeys-random：如果期望是循环周期的访问，所有的键被连续扫描，或者期望请求符合平均分布(每个元素以相同的概率被访问)，可以使用allkeys-random策略。</li>
<li>volatile-ttl：如果你期望能让 Redis 通过使用你创建缓存对象的时候设置的TTL值，确定哪些对象应该是较好的清除候选项，可以使用volatile-ttl策略。</li>
</ul>
<p>另外值得注意的是，为键设置过期时间需要消耗内存，所以使用像allkeys-lru这样的策略会更高效，因为在内存压力下没有必要为键的回收设置过期时间。</p>
<h2 id="常用缓存数据淘汰策略"><a href="#常用缓存数据淘汰策略" class="headerlink" title="常用缓存数据淘汰策略"></a>常用缓存数据淘汰策略</h2><ul>
<li>FIFO（First In First Out）： 先进先出算法，即先放入缓存的先被移除。</li>
<li>LRU（Least Recently Used）： 最近最少使用算法，使用时间距离现在最久的那个被移除。</li>
<li>LFU（Least Frequently Used）： 最不常用算法，一定时间段内使用次数（频率）最少的那个被移除。</li>
</ul>
<h2 id="缓存数据更新策略"><a href="#缓存数据更新策略" class="headerlink" title="缓存数据更新策略"></a>缓存数据更新策略</h2><ul>
<li>定时任务从数据库直接更新缓存：适用于对时间不敏感的数据。</li>
<li>查询时写缓存，即查询优先查询缓存，若缓存未命中，查询数据库，将返回结果写入缓存，数据更新时先 delete缓存，再更新缓存。</li>
<li>MQ 消息异步更新缓存。</li>
</ul>
<h1 id="Redis采用的过期策略"><a href="#Redis采用的过期策略" class="headerlink" title="Redis采用的过期策略"></a>Redis采用的过期策略</h1><p>惰性删除+定期删除</p>
<ul>
<li>惰性删除流程<ul>
<li>在进行get或setnx等操作时，先检查key是否过期，</li>
<li>若过期，删除key，然后执行相应操作；</li>
<li>若没过期，直接执行相应操作</li>
</ul>
</li>
<li>定期删除流程（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）<ul>
<li>遍历每个数据库（就是redis.conf中配置的”database”数量，默认为16）<ul>
<li>检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）<ul>
<li>如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历</li>
<li>随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key</li>
<li>判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" itemprop="url">redis线程模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T01:19:02+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis单线程原理"><a href="#Redis单线程原理" class="headerlink" title="Redis单线程原理"></a>Redis单线程原理</h1><p>Redis是单进程，Redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。</p>
<h1 id="Redis的线程模型"><a href="#Redis的线程模型" class="headerlink" title="Redis的线程模型"></a>Redis的线程模型</h1><p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="image"></p>
<p><strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型</strong>，Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接， <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">多个 socket（客户端连接）</span><br><span class="line">IO 多路复用程序（支持多个客户端连接的关键）</span><br><span class="line">文件事件分派器（将 socket 关联到相应的事件处理器）</span><br><span class="line">事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</span><br></pre></td></tr></table></figure>

<h2 id="Redis-单线程模型详解"><a href="#Redis-单线程模型详解" class="headerlink" title="Redis 单线程模型详解"></a>Redis 单线程模型详解</h2><p><strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型</strong>，Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接， <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong></p>
<p>主要是包含 4 个部分：</p>
<ul>
<li>多个 socket（客户端连接）</li>
<li>IO 多路复用程序（支持多个客户端连接的关键）</li>
<li>文件事件分派器（将 socket 关联到相应的事件处理器）</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<h1 id="Redis-是单进程单线程的吗？为何它那么快那么高效？"><a href="#Redis-是单进程单线程的吗？为何它那么快那么高效？" class="headerlink" title="Redis 是单进程单线程的吗？为何它那么快那么高效？"></a>Redis 是单进程单线程的吗？为何它那么快那么高效？</h1><h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>Redis是单线程的，redis 利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。</p>
<h2 id="速度快"><a href="#速度快" class="headerlink" title="速度快"></a>速度快</h2><p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p>
<p>2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p>
<p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p>
<p>4、使用多路I/O复用模型，非阻塞IO；</p>
<p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p>
<hr>
<h1 id="redis为什么不采用多线程处理"><a href="#redis为什么不采用多线程处理" class="headerlink" title="redis为什么不采用多线程处理"></a>redis为什么不采用多线程处理</h1><ol>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的性能瓶颈不再 CPU ，主要在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ol>
<h2 id="Redis6-0-之后为何引入了多线程"><a href="#Redis6-0-之后为何引入了多线程" class="headerlink" title="Redis6.0 之后为何引入了多线程"></a>Redis6.0 之后为何引入了多线程</h2><p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了， 执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</p>
<h1 id="单线程处理的缺点？"><a href="#单线程处理的缺点？" class="headerlink" title="单线程处理的缺点？"></a>单线程处理的缺点？</h1><p>1.耗时的命令会导致并发的下降，不只是读并发，写并发也会下降</p>
<p>2.无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/03/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/03/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url">redis数据结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-03T01:18:46+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis知识点</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/redis-redis%E5%BA%94%E7%94%A8/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis应用</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis-的数据类型？"><a href="#Redis-的数据类型？" class="headerlink" title="Redis 的数据类型？"></a>Redis 的数据类型？</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>键(key)——值(value) (字符串格式)</p>
<h4 id="动态字符串（Redis字符串的实现方式）"><a href="#动态字符串（Redis字符串的实现方式）" class="headerlink" title="动态字符串（Redis字符串的实现方式）"></a>动态字符串（Redis字符串的实现方式）</h4><p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * 保存字符串对象的结构  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span>  </span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度  </span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// buf 中剩余可用空间的长度  </span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;  </span><br><span class="line">    <span class="comment">// 数据空间  </span></span><br><span class="line">    <span class="keyword">char</span> buf[];  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>len 变量，用于记录buf 中已经使用的空间长度。</li>
<li>free 变量，用于记录buf 中还空余的空间，初次分配空间，一般没有空余，在对字符串修改的时候，会有剩余空间出现，这样做是为了杜绝C语言中缓冲区溢出的可能性，当我们需要对一个SDS进行修改的时候，Redis 会在执行拼接操作之前，预先检查给定SDS空间是否足够，如果不够，会先拓展SDS的空间，然后再执行拼接操作。</li>
<li>buf 字符数组，用于记录我们的字符串（记录Redis）。</li>
</ol>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>字符串拥有一些操作命令，如：</p>
<ul>
<li>get 获取值</li>
<li>set key value设置值</li>
<li>del 删除</li>
<li>incr key 加一</li>
<li>decr key 减一</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><p>计数器 string类型的<code>incr</code>和<code>decr</code>命令的作用是将key中储存的数字值<strong>加一/减一</strong>，这两个操作具有原子性，总能安全地进行加减操作</p>
<p> 因此可以用string类型进行计数，如微博的评论数、点赞数、分享数，抖音作品的收藏数，京东商品的销售量、评价数等。</p>
</li>
<li><p>分布式锁 String类型的<code>setnx</code>的作用是<strong>当key不存在时，设值并返回1，当key已经存在时，不设值并返回0</strong>，<strong>判断key是否存在</strong>和<strong>设值</strong>两个操作是原子性地执行的，因此可以用string类型作为分布式锁，返回1表示获得锁，返回0表示没有获得锁。</p>
<p> 例如，为了保证定时任务的高可用，往往会同时部署多个具备相同定时任务的服务，但是业务上只希望其中的某一台服务执行定时任务，当定时任务的时间点触发时，多个服务同时竞争一个分布式锁，获取到锁的执行定时任务，没获取到的放弃执行定时任务。</p>
<p> 定时任务执行完时通过del命令删除key即释放锁，如果担心del命令操作失败而导致锁一直未释放，可以通过expire命令给锁设置一个合理的自动过期时间，确保即使del命令失败，锁也能被释放。不过expire命令同样存在失败的可能性，如果你用的是Java语言，建议使用JedisCommands接口提供的<code>String set(String key, String value, String nxxx, String expx, long time)</code>方法，这个方法可以将setnx和expire原子性地执行，具体使用方式如下（相信其它语言的Redis客户端也应当提供了类似的方法）。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jedisCommands.set(<span class="string">&quot;IAmAKey&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, <span class="number">60</span>);<span class="comment">//如果&quot;IAmAKey&quot;不存	 在，则将其设值为1，同时设置60秒的自动过期时间</span></span><br></pre></td></tr></table></figure></li>
<li><p>限流</p>
</li>
<li><p>分布式Session</p>
</li>
<li><p>存储对象 利用JSON强大的兼容性、可读性和易用性，将对象转换为JSON字符串，再存储在string类型中，是个不错的选择，如用户信息、商品信息等。</p>
</li>
</ol>
<h2 id="列表-List"><a href="#列表-List" class="headerlink" title="列表(List)"></a>列表(List)</h2><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p>一个列表结构可以有序地存储多个字符串</p>
<h4 id="链表数据结构，List-底层结构"><a href="#链表数据结构，List-底层结构" class="headerlink" title="链表数据结构，List 底层结构"></a>链表数据结构，List 底层结构</h4><p>链表还是常规的普通双端链表，可以支持反向查找和遍历，更方便操作，通过增删节点来灵活地调整链表的长度，双端链表在Redis内部也是被多次使用：</p>
<ol>
<li>事务模块使用双端链表依序保存输入的命令。</li>
<li>服务器模块使用双端链表来保存多个客户端。</li>
<li>订阅/发送模块使用双端链表来保存订阅模式的多个客户端。</li>
<li>事件模块使用双端链表来保存时间事件（time event）。</li>
</ol>
<h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><ul>
<li>lpush list a b c d (从左添加元素)</li>
<li>rpush list 1 2 3 4 (从右边添加元素)</li>
<li>lrange list 0 -1 (从0 到 -1 元素查看：也就表示查看所有)</li>
<li>lpop list （从左边取，删除）</li>
<li>rpop list (从右边取，删除)</li>
</ul>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><p>消息队列 list类型的lpop和rpush（或者反过来，lpush和rpop）能实现队列的功能，故而可以用Redis的list类型实现简单的点对点的消息队列，但有更好的rabbitmq和kafka</p>
</li>
<li><p>排行榜 list类型的lrange命令可以分页查看队列中的数据。可将每隔一段时间计算一次的排行榜存储在list类型中，如京东每日的手机销量排行、学校每次月考学生的成绩排名、斗鱼年终盛典主播排名等。</p>
</li>
</ol>
<blockquote>
<p>排行榜，每日计算一次，存储在list类型中，接口访问时，通过page和size分页获取 </p>
</blockquote>
<img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/QQ%E9%9F%B3%E4%B9%90%E6%8E%92%E8%A1%8C%E6%A6%9C.png" style="zoom:50%;" />

<blockquote>
<p>但是，并不是所有的排行榜都能用list类型实现，只有定时计算的排行榜才适合使用list类型存储，与定时计算的排行榜相对应的是实时计算的排行榜，list类型不能支持实时计算的排行榜，实时计算的排行榜使用有序集合sorted set实现。</p>
</blockquote>
<ol start="3">
<li>最新列表 list类型的lpush命令和lrange命令能实现最新列表的功能，每次通过lpush命令往列表里插入新的元素，然后通过lrange命令读取最新的元素列表，如朋友圈的点赞列表、评论列表。</li>
</ol>
<blockquote>
<p>但是，并不是所有的最新列表都能用list类型实现， 因为对于频繁更新的列表，list类型的分页可能导致列表元素重复或漏掉 ，举个例子，当前列表里由表头到表尾依次有（E，D，C，B，A）五个元素， 每页获取3个元素，用户第一次获取到（E，D，C）三个元素，然后表头新增了一个元素F， 列表变成了（F，E，D，C，B，A），此时用户取第二页拿到（C，B，A）， 元素C重复了。</p>
</blockquote>
<h4 id="list和sorted-set"><a href="#list和sorted-set" class="headerlink" title="list和sorted set"></a>list和sorted set</h4><ul>
<li><p>只有不需要分页（比如每次都只取列表的前5个元素）或者更新频率低（比如每天凌晨更新一次）的列表才适合用list类型实现。</p>
</li>
<li><p>对于需要分页并且会频繁更新的列表，需用使用有序集合sorted set类型实现。</p>
</li>
<li><p>需要通过时间范围查找的最新列表，list类型也实现不了，也需要通过有序集合sorted set类型实现，如以成交时间范围作为条件来查询的订单列表。</p>
</li>
</ul>
<h5 id="如何选用"><a href="#如何选用" class="headerlink" title="如何选用"></a>如何选用</h5><blockquote>
<p>对于排行榜和最新列表两种应用场景，那为什么还要使用list类型去实现排行榜或最新列表呢，直接用sorted set类型不是更好吗？</p>
</blockquote>
<p>原因是sorted <strong>set类型占用的内存容量是list类型的数倍之多</strong>，对于<strong>列表数量不多</strong>的情况，可以用sorted set类型来实现，比如上文中举例的打擂金曲排行榜，每天全国只有一份，两种数据类型的内存容量差距可以忽略不计，但是如果要实现某首歌曲的翻唱作品地区排行榜，数百万的歌曲，300多个地区，会产生数量庞大的榜单，或者数量更加庞大的朋友圈点赞列表，就需要慎重地考虑容量的问题了</p>
<h2 id="hash类型"><a href="#hash类型" class="headerlink" title="hash类型"></a>hash类型</h2><h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p>hash类型是一个string类型的field和value的映射表</p>
<h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><ul>
<li>hdel (HDEL key field1 [field2]) 删除一个或多个哈希表字段</li>
<li>hlen</li>
<li>hgetall</li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-hashes.html">更多方法</a></li>
</ul>
<h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h4><p>以用户id为key，商品id为field，商品数量为value，恰好构成了购物车的3个要素，如下图所示。</p>
<img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/%E8%B4%AD%E7%89%A9%E8%BD%A6.png" style="zoom:50%;" />

<h4 id="存储对象"><a href="#存储对象" class="headerlink" title="存储对象"></a>存储对象</h4><p>存储对象 hash类型的(key, field, value)的结构与对象的(对象id, 属性, 值)的结构相似，也可以用来存储对象。</p>
<h5 id="存储对象时，到底用string-json还是用hash"><a href="#存储对象时，到底用string-json还是用hash" class="headerlink" title="存储对象时，到底用string + json还是用hash"></a>存储对象时，到底用string + json还是用hash</h5><p>两种存储方式的对比如下表所示。</p>
<table>
<thead>
<tr>
<th></th>
<th>string + json</th>
<th>hash</th>
</tr>
</thead>
<tbody><tr>
<td>效率</td>
<td>很高</td>
<td>高</td>
</tr>
<tr>
<td>容量</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td>灵活性</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>序列化</td>
<td>简单</td>
<td>复杂</td>
</tr>
</tbody></table>
<ul>
<li>当对象的某个属性需要频繁修改时，不适合用string+json，因为它不够灵活，每次修改都需要重新将整个对象序列化并赋值</li>
<li>如果使用hash类型，则可以针对某个属性单独修改，没有序列化，也不需要修改整个对象。比如，商品的价格、销量、关注数、评价数等可能经常发生变化的属性，就适合存储在hash类型里。</li>
</ul>
<p>当然，不常变化的属性存储在hash类型里也没有问题，比如商品名称、商品描述、上市日期等。但是，当对象的某个属性<strong>不是基本类型或字符串时</strong>，使用hash类型就必须手动进行复杂序列化</p>
<p>比如，商品的标签是一个标签对象的列表，商品可领取的优惠券是一个优惠券对象的列表（如下图所示）等，即使以coupons（优惠券）作为field，value想存储优惠券对象列表也还是要使用json来序列化，这样的话序列化工作就太繁琐了，不如直接用string + json的方式存储商品信息来的简单。 </p>
<img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/%E4%BC%98%E6%83%A0%E5%8D%B7.png" style="zoom:33%;" />

<p><strong>综上，一般对象用string+json存储，对象中某些频繁变化的基本类型或字符串的属性抽出来用hash存储。</strong></p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p>set类型是string类型的集合，其特点是集合元素无序且不重复</p>
<h3 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h3><ul>
<li>SINTER KEY KEY1..KEYN 回给定所有给定集合的交集</li>
<li>SISMEMBER KEY VALUE 判断成员元素是否是集合的成员</li>
<li>SCARD KEY_NAME 返回集合中元素的数量</li>
<li>SMOVE SOURCE DESTINATION MEMBER 命令将指定成员 member 元素从 source 集合移动到 destination 集合。</li>
<li>SRANDMEMBER KEY [count] 用于返回集合中的一个随机元素。</li>
</ul>
<h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><p>好友/关注/粉丝/感兴趣的人集合</p>
<p>set类型唯一的特点使得其适合用于存储好友/关注/粉丝/感兴趣的人集合，集合中的元素数量可能很多，每次全部取出来成本不小，set类型提供了一些很实用的命令用于直接操作这些集合</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. sinter命令可以获得A和B两个用户的共同好友</span><br><span class="line">2. sismember命令可以判断A是否是B的好友</span><br><span class="line">3. scard命令可以获取好友数量</span><br><span class="line">4. 关注时，smove命令可以将B从A的粉丝集合转移到A的好友集合</span><br></pre></td></tr></table></figure>
<p><strong>需要注意</strong>:</p>
<p>如果你用的是<strong>Redis Cluster集群</strong>，对于<strong>sinter、smove这种操作     多个key的命令</strong>，要求这两个key必须存储在<strong>同一个slot（槽位）中</strong>，否则会报出<code>(error) CROSSSLOT Keys in request don&#39;t hash to the same slot </code>错误。</p>
<p>Redis Cluster一共有<strong>16384</strong>个slot，每个key都是通过哈希算法CRC16(key)获取数值哈希，再模16384来定位slot的。要使得两个key处于同一slot，除了两个key一模一样，还有没有别的方法呢？</p>
<p>Redis提供了一种<strong>Hash Tag</strong>的功能，在key中使用<code>&#123;&#125;</code>括起key中的一部分，在进行<code>CRC16(key) mod 16384</code>的过程中，只会对<code>&#123;&#125;</code>内的字符串计算，例如<strong>friend_set:{123456}<strong>和</strong>fans_set:{123456}<strong>，分别表示</strong>用户123456</strong>的<strong>好友集合</strong>和<strong>粉丝集合</strong>，在定位slot时，只对<code>&#123;&#125;</code>内的<code>123456</code>进行计算，所以这两个集合肯定是在同一个slot内的，当用户123456关注某个粉丝时，就可以通过smove命令将这个粉丝从用户123456的粉丝集合移动到好友集合。</p>
<p>相比于通过srem命令先将这个粉丝从粉丝集合中删除，再通过sadd命令将这个粉丝加到好友集合，smove命令的优势是它是<strong>原子性</strong>的，不会出现这个粉丝从粉丝集合中被删除，却没有加到好友集合的情况。</p>
<p>然而，对于通过sinter获取共同好友而言，Hash Tag则无能为力，例如，要用sinter去获取<strong>用户123456</strong>和<strong>用户456789</strong>两个用户的共同好友，除非我们将key定义为**{friend_set}:123456<strong>和</strong>{friend_set}:456789**，否则不能保证两个key会处于同一个slot，但是如果真这样做的话，所有用户的好友集合都会堆积在同一个slot中，数据分布会严重不均匀，不可取，</p>
<p><strong>所以，在实战中使用Redis Cluster时，sinter这个命令其实是不适合作用于两个不同用户对应的集合的（同理其它操作多个key的命令）。</strong></p>
</li>
<li><p>随机展示 通常，app首页的展示区域有限，但是又不能总是展示固定的内容，一种做法是先确定一批需要展示的内容，再从中随机获取。如下图所示，酷狗音乐K歌擂台赛当日的打擂歌曲共29首，首页随机展示5首；昨日打擂金曲共200首，首页随机展示30首。</p>
</li>
</ol>
<img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/%E6%89%93%E6%93%82.png" style="zoom:33%;" />

<p>set类型适合存放所有需要展示的内容，而<code>srandmember</code>命令则可以从中随机获取几个。</p>
<h2 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted set"></a>sorted set</h2><h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员</p>
<p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p><strong>有序集合的成员是唯一的</strong>,但分数(score)却可以重复。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。</p>
<h4 id="跳跃表，sorted-set底层结构"><a href="#跳跃表，sorted-set底层结构" class="headerlink" title="跳跃表，sorted set底层结构"></a>跳跃表，sorted set底层结构</h4><p>Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，（如果你还不了解红黑树，需要先额外补补功课），HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score，使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。</p>
<p>那为什么Redis的作者使用 SkipList 结构而不是红黑树？</p>
<ul>
<li>红黑树：红黑树的查找效率很高，但是在进行重新平衡时，会涉及到大量节点的变化，因此实现和操作起来都比较复杂。</li>
<li>跳跃表：通过简单的多层索引结构，实现简单，且能达到近似于红黑树的查找效率，插入节点（多层插入）不需要像红黑树那样有额外操作。而且跳跃表还能实现范围查找及输出，而红黑树只支持单个元素查找，对于范围查找效率低。</li>
</ul>
<h3 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h3><ol>
<li>Zadd</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD KEY_NAME SCORE1 VALUE1.. SCOREN VALUEN</span><br></pre></td></tr></table></figure>

<ol>
<li>Zincrby 对有序集合中指定成员的分数加上增量 increment</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY key increment member</span><br></pre></td></tr></table></figure>

<ol>
<li>Zrange 返回有序集中，指定区间内的成员</li>
</ol>
<p>其中成员的位置按分数值递增(从小到大)来排序。 具有相同分数值的成员按字典序(lexicographical order )来排列。</p>
<p><strong>下标参数</strong> start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。</p>
<p>你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure>

<ol>
<li>Zrevrange 命令返回有序集中，指定区间内的成员。</li>
</ol>
<p><strong>下标参数</strong> start 和 stop 其中成员的位置按分数值递减(从大到小)来排列。 具有相同分数值的成员按字典序的逆序(reverse lexicographical order)排列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure>

<ol>
<li>Zrem 命令用于移除有序集中的一个或多个成员，不存在的成员将被忽略。 当 key 存在但不是有序集类型时，返回一个错误。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREM key member [member ...]</span><br></pre></td></tr></table></figure>

<ol>
<li>Zcard 命令用于计算集合中元素的数量。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCARD KEY_NAME</span><br></pre></td></tr></table></figure>

<ol>
<li></li>
</ol>
<p>Zrangebyscore 返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)次序排列。</p>
<p>具有相同分数值的成员按字典序来排列(该属性是有序集提供的，不需要额外的计算)。</p>
<p>默认情况下，<strong>区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br></pre></td></tr></table></figure>

<ul>
<li>ZRANGEBYSCORE zset (1 5 == 1 &lt; score &lt;= 5</li>
<li>ZRANGEBYSCORE zset (5 (10 == 5 &lt; score &lt; 10</li>
<li>ZRANGEBYSCORE salary -inf +inf # 显示整个有序集</li>
<li>ZRANGEBYSCORE salary -inf +inf WITHSCORES #显示整个有序集及成员的 score 值</li>
<li>ZRANGEBYSCORE salary -inf 5000 WITHSCORES # 显示工资 &lt;=5000 的所有成员</li>
<li>ZRANGEBYSCORE salary (5000 400000 # 显示工资大于 5000 小于等于 400000 的成员</li>
</ul>
<ol>
<li>Zrevrangebyscore 返回有序集中指定分数区间内的所有的成员。有序集成员按分数值递减(从大到小)的次序排列。 具有相同分数值的成员按字典序的逆序(reverse lexicographical order )排列。</li>
<li>Zcount 命令用于计算有序集合中指定分数区间的成员数量。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCOUNT key min max</span><br></pre></td></tr></table></figure>

<h3 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>游戏排名</li>
<li>微博热点话题</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/03/31/Java-CopyOnWriteArrayList%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/31/Java-CopyOnWriteArrayList%E5%AD%A6%E4%B9%A0/" itemprop="url">Java-CopyOnWriteArrayList学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-31T22:36:51+08:00">
                2021-03-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80-Java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础 - Java并发容器</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80-Java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/Java%E5%9F%BA%E7%A1%80-Java%E6%BA%90%E7%A0%81/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础 - Java源码</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80-Java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/Java%E5%9F%BA%E7%A1%80-Java%E6%BA%90%E7%A0%81/Java%E5%9F%BA%E7%A1%80-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础 - Java知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h1><h2 id="特征："><a href="#特征：" class="headerlink" title="特征："></a>特征：</h2><ol>
<li>线程安全的，多线程环境下可以直接使用，无需加锁；</li>
<li>通过锁 + 数组拷贝 + volatile 关键字保证了线程安全；<ul>
<li>加锁：保证同一时刻数组只能被一个线程操作；</li>
<li>数组拷贝：保证数组的内存地址被修改，修改后触发 volatile 的可见性，其它线程可以立马知道数组已经被修改；</li>
<li>volatile：值被修改后，其它线程能够立马感知最新值。</li>
</ul>
</li>
<li>每次数组操作，都会把数组拷贝一份出来，在新数组上进行操作，操作成功之后再赋值回去。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.imooc.com/read/47/article/857">源码学习</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/03/31/Java-hashmap%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/31/Java-hashmap%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url">Java-hashmap源码学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-31T22:36:51+08:00">
                2021-03-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80-Java%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础 - Java容器</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80-Java%E5%AE%B9%E5%99%A8/Java%E5%9F%BA%E7%A1%80-Java%E6%BA%90%E7%A0%81/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础 - Java源码</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80-Java%E5%AE%B9%E5%99%A8/Java%E5%9F%BA%E7%A1%80-Java%E6%BA%90%E7%A0%81/Java%E5%9F%BA%E7%A1%80-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础 - Java知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HashMap-简介"><a href="#HashMap-简介" class="headerlink" title="HashMap 简介"></a>HashMap 简介</h1><p>HashMap 主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。 </p>
<p>JDK1.8 之前  HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.</p>
<p>JDK1.8 当链表长度大于阈值（默认为8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间，具体可以参考 <code>treeifyBin</code>方法。</p>
<h2 id="底层数据结构分析"><a href="#底层数据结构分析" class="headerlink" title="底层数据结构分析"></a>底层数据结构分析</h2><h3 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h3><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。</p>
<p><strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash  值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度）。</strong></p>
<p><strong>如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p>
<blockquote>
<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
</blockquote>
<blockquote>
<p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p>
</blockquote>
<h4 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h4><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/collection/images/jdk1.8%E4%B9%8B%E5%89%8D%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84-HashMap.png" alt="jdk1.8之前的内部结构-HashMap"></p>
<h3 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h3><h4 id="整体架构-1"><a href="#整体架构-1" class="headerlink" title="整体架构"></a>整体架构</h4><p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/collection/images/jdk1.8%E4%B9%8B%E5%90%8E%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84-HashMap.png" alt="jdk1.8之后的内部结构-HashMap"></p>
<blockquote>
<p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p>
</blockquote>
<h3 id="HashMap-的-hash-方法源码"><a href="#HashMap-的-hash-方法源码" class="headerlink" title="HashMap 的 hash 方法源码:"></a>HashMap 的 hash 方法源码:</h3><p>JDK1.7的 HashMap 的 hash 方法源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>JDK 1.8 的 HashMap 的hash 方法源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="你知道hash的实现吗-为什么要这样实现"><a href="#你知道hash的实现吗-为什么要这样实现" class="headerlink" title="你知道hash的实现吗?为什么要这样实现?"></a>你知道hash的实现吗?为什么要这样实现?</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>key.hashCode()；返回散列值也就是hashcode，假设随便生成的一个值。</p>
<p>n表示数组初始化的长度是16。</p>
<p>&amp;（按位与运算）：运算规则：相同的二进制数位上，都是1的时候，结果为1，否则为零。</p>
<p>^（按位异或运算）：运算规则：相同的二进制数位上，数字相同，结果为0，不同为1。</p>
</blockquote>
<ol>
<li>首先计算出<strong>key 的 hashcode</strong>，<ol>
<li>因为 key 是 Object，所以<strong>会根据 key 的不同类型进行 hashcode 的计算</strong>，</li>
<li>接着<strong>计算 h ^ (h &gt;&gt;&gt; 16)</strong> ，这么做的好处是使大多数场景下，<strong>算出来的 hash 值比较分散</strong>。</li>
</ol>
</li>
</ol>
<h4 id="为什么不用-key-数组大小，而是需要用-key-的-hash-值-数组大小"><a href="#为什么不用-key-数组大小，而是需要用-key-的-hash-值-数组大小" class="headerlink" title="为什么不用 key % 数组大小，而是需要用 key 的 hash 值 % 数组大小"></a>为什么不用 key % 数组大小，而是需要用 key 的 hash 值 % 数组大小</h4><p><strong>如果 key 是数字，直接用 key % 数组大小是完全没有问题的</strong>，</p>
<p><strong>但我们的 key 还有可能是字符串，是复杂对象，% 数组大小是不行的</strong>，所以需要先计算出 key 的 hash 值。</p>
<h4 id="计算-hash-值时，为什么需要右移-16-位"><a href="#计算-hash-值时，为什么需要右移-16-位" class="headerlink" title="计算 hash 值时，为什么需要右移 16 位"></a>计算 hash 值时，为什么需要右移 16 位</h4><p><strong>hash 算法是 h ^ (h &gt;&gt;&gt; 16)，为了使计算出的 hash 值更分散</strong>，所以选择先将 h 无符号右移 16 位，然后再于 h 异或时，就能达到 h 的高 16 位和低 16 位都能参与计算，减少了碰撞的可能性。</p>
<h4 id="为什么把取模操作换成了-amp-操作"><a href="#为什么把取模操作换成了-amp-操作" class="headerlink" title="为什么把取模操作换成了 &amp; 操作"></a>为什么把取模操作换成了 &amp; 操作</h4><p><strong>key.hashCode() 算出来的 hash 值还不是数组的索引下标</strong>，为了随机的计算出索引的下表位置，我们还会用<strong>hash 值和数组大小进行取模，这样子计算出来的索引下标比较均匀分布</strong>。</p>
<p><strong>取模操作处理器计算比较慢，处理器对 &amp; 操作就比较擅长，换成了 &amp; 操作</strong>，是有数学上证明的支撑，为了提高了处理器处理的速度。</p>
<h4 id="为什么要用异或运算符"><a href="#为什么要用异或运算符" class="headerlink" title="为什么要用异或运算符?"></a>为什么要用异或运算符?</h4><p>保证了对象的<code>hashCode</code>的32位值只要有一位发生改变,整个<code>hash()</code>返回值就会改变。尽可能的减少碰撞。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>允许 null 值，不同于 HashTable ，是线程不安全的；</li>
<li>如果有很多数据需要储存到 HashMap 中，建议 HashMap 的容量一开始就设置成足够的大小，这样可以防止在其过程中不断的扩容，影响性能</li>
<li>在迭代过程中，如果 HashMap 的结构被修改，会快速失败</li>
</ul>
<h2 id="HashMap的工作原理"><a href="#HashMap的工作原理" class="headerlink" title="HashMap的工作原理"></a>HashMap的工作原理</h2><h3 id="HashMap-的存储数据的过程是什么样的（put（）过程）"><a href="#HashMap-的存储数据的过程是什么样的（put（）过程）" class="headerlink" title="HashMap 的存储数据的过程是什么样的（put（）过程）"></a>HashMap 的存储数据的过程是什么样的（put（）过程）</h3><p>不同的 JDK 版本版本的存储过程略有差异。在 JDK1.8 中，HashMap 存储数据的过程可以分为以下几步：</p>
<ul>
<li><p>1.对 key 的 hashCode () 进行 hash 后计算数组获得下标 index;</p>
</li>
<li><p>2.如果当前数组为 null，进行容量的初始化，初始容量为 16；</p>
</li>
<li><p>3.如果 hash 计算后没有碰撞，直接放到对应数组下标里；</p>
</li>
<li><p>4.如果 hash 计算后发生碰撞且节点已存在，则替换掉原来的对象；</p>
</li>
<li><p>5.如果 hash 计算后发生碰撞且节点已经是树结构，则挂载到树上。</p>
</li>
<li><p>6.如果 hash 计算后发生碰撞且节点是链表结构，则添加到链表尾，并判断链表是否需要转换成树结构（默认大于 8 的情况会转换成树结构）；</p>
</li>
<li><p>7.完成 put 后，是否需要 resize () 操作（数据量超过 threshold，threshold 为初始容量和负载因子之积，默认为 12）。</p>
<p>而在 1.7 的版本中，5/6 是合在一起的，即如果发生哈希碰撞且节点是链表结构，则放在链表头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">面试 Tips</span><br><span class="line"></span><br><span class="line">可以在回答时提及 HashMap 中的两类存储数据的方法：put () 和 putAll ()，put ()调用的putVal ()，然后再针对 putVal 展开回答</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="HashMap查找（get（）过程）"><a href="#HashMap查找（get（）过程）" class="headerlink" title="HashMap查找（get（）过程）"></a>HashMap查找（get（）过程）</h3><p>HashMap 的查找主要分为以下三步：</p>
<ul>
<li>根据 hash 算法定位数组的索引位置，equals 判断当前节点是否是我们需要寻找的 key，是的话直接返回，不是的话往下。</li>
<li>判断当前节点有无 next 节点，有的话判断是链表类型，还是红黑树类型。</li>
<li>分别走链表和红黑树不同类型的查找方法。</li>
</ul>
<h3 id="HashMap的table的容量如何确定-loadFactor是什么-该容量如何变化-这种变化会带来什么问题"><a href="#HashMap的table的容量如何确定-loadFactor是什么-该容量如何变化-这种变化会带来什么问题" class="headerlink" title="HashMap的table的容量如何确定?loadFactor是什么?该容量如何变化?这种变化会带来什么问题?"></a>HashMap的table的容量如何确定?loadFactor是什么?该容量如何变化?这种变化会带来什么问题?</h3><ul>
<li><code>table</code>数组大小是由<code>capacity</code>这个参数确定的,默认是16,也可以构造时传入,最大限制是1&lt;&lt;30;</li>
<li><code>loadFactor</code>是装载因子,主要目的是用来确认<code>table</code>数组是否需要动态扩展,默认值是0.75,比如<code>table</code>数组大小为16,装载因子为0.75时,<code>threshold</code>就是12,当<code>table</code>的实际大小超过12时,<code>table</code>就需要动态扩容;</li>
<li>扩容时,调用<code>resize()</code>方法,将<code>table</code>长度变为原来的两倍(注意是table长度,而不是<code>threshold</code>)</li>
<li>如果数据很大的情况下,扩展时将会带来性能的损失,在性能要求很高的地方,这种损失很可能很致命。</li>
</ul>
<h3 id="节点为链表时的新增"><a href="#节点为链表时的新增" class="headerlink" title="节点为链表时的新增"></a>节点为链表时的新增</h3><p>当链表长度大于等于 8 时，此时的链表就会转化成红黑树，转化的方法是：treeifyBin，此方法有一个判断，当链表长度大于等于 8，并且整个数组大小大于 64 时，才会转成红黑树，当数组大小小于 64 时，只会触发扩容，不会转化成红黑树</p>
<h3 id="为什么是8的时候转化成红黑树"><a href="#为什么是8的时候转化成红黑树" class="headerlink" title="为什么是8的时候转化成红黑树"></a>为什么是8的时候转化成红黑树</h3><p>当链表个数太多了，遍历可能比较耗时，转化成红黑树，可以使遍历的时间复杂度降低，但转化成红黑树，有空间和转化耗时的成本，我们通过泊松分布公式计算，正常情况下，链表个数出现 8 的概念不到千万分之一，所以说正常情况下，链表都不会转化成红黑树，这样设计的目的，是为了防止非正常情况下，比如 hash 算法出了问题时，导致链表个数轻易大于等于 8 时，仍然能够快速遍历。</p>
<p><strong>延伸问题：红黑树什么时候转变成链表。</strong></p>
<p>答：当节点的个数小于等于 6 时，红黑树会自动转化成链表，主要还是考虑红黑树的空间成本问题，当节点个数小于等于 6 时，遍历链表也很快，所以红黑树会重新变成链表。</p>
<h3 id="红黑树新增节点过程"><a href="#红黑树新增节点过程" class="headerlink" title="红黑树新增节点过程"></a>红黑树新增节点过程</h3><ol>
<li><p>首先判断新增的节点在红黑树上是不是已经存在，判断手段有如下两种：</p>
<p>1.1. 如果节点没有实现 Comparable 接口，使用 equals 进行判断；</p>
<p>1.2. 如果节点自己实现了  Comparable 接口，使用 compareTo 进行判断。</p>
</li>
<li><p>新增的节点如果已经在红黑树上，直接返回；不在的话，判断新增节点是在当前节点的左边还是右边，左边值小，右边值大；</p>
</li>
<li><p>自旋递归 1 和 2 步，直到当前节点的左边或者右边的节点为空时，停止自旋，当前节点即为我们新增节点的父节点；</p>
</li>
<li><p>把新增节点放到当前节点的左边或右边为空的地方，并于当前节点建立父子节点关系；</p>
</li>
<li><p>进行着色和旋转，结束。</p>
<p>着色指的是给红黑树的节点着上红色或黑色，旋转是为了让红黑树更加平衡，提高查询的效率</p>
</li>
</ol>
<h3 id="数组扩容的过程"><a href="#数组扩容的过程" class="headerlink" title="数组扩容的过程"></a>数组扩容的过程</h3><p>创建一个新的数组,其容量为旧数组的两倍,并重新计算旧数组中结点的存储位置。结点在新数组中的位置只有两种,原下标位置或原下标+旧数组的大小。</p>
<h4 id="什么时候扩容"><a href="#什么时候扩容" class="headerlink" title="什么时候扩容"></a>什么时候扩容</h4><ol>
<li>put 时，发现数组为空，进行初始化扩容，默认扩容大小为 16;</li>
<li>put 成功后，当HashMap中的数组大小超过threshold **（数组大小(数组长度)*loadFactor(负载因子)）**时，就会进行数组扩容（resize () 操作）</li>
</ol>
<h3 id="拉链法导致的链表过深问题为什么不用二叉查找树代替-而选择红黑树-为什么不一直使用红黑树"><a href="#拉链法导致的链表过深问题为什么不用二叉查找树代替-而选择红黑树-为什么不一直使用红黑树" class="headerlink" title="拉链法导致的链表过深问题为什么不用二叉查找树代替,而选择红黑树?为什么不一直使用红黑树?"></a>拉链法导致的链表过深问题为什么不用二叉查找树代替,而选择红黑树?为什么不一直使用红黑树?</h3><p>红黑树是为了解决二叉查找树的缺陷,二叉查找树在特殊情况下会变成一条线性结构(这就跟原来使用链表结构一样了,造成很深的问题),遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋,右旋、变色这些操作来保持平衡,引入红黑树就是为了查找数据快,解决链表查询深度的问题,</p>
<h4 id="说说你对红黑树的见解"><a href="#说说你对红黑树的见解" class="headerlink" title="说说你对红黑树的见解"></a>说说你对红黑树的见解</h4><ul>
<li>1、每个节点非红即黑</li>
<li>2、根节点总是黑色的</li>
<li>3、如果节点是红色的,则它的子节点必须是黑色的(反之不一定)</li>
<li>4、每个叶子节点都是黑色的空节点(NIL节点)</li>
<li>5、从根节点到叶节点或空子节点的每条路径,必须包含相同数目的黑色节点(即相同的黑色高度)</li>
</ul>
<h2 id="当两个对象的hashCode相同会发生什么"><a href="#当两个对象的hashCode相同会发生什么" class="headerlink" title="当两个对象的hashCode相同会发生什么?"></a>当两个对象的hashCode相同会发生什么?</h2><p>因为<code>hashCode</code>相同,不一定就是相等的(<code>equals</code>方法比较),所以两个对象所在数组的下标相同,”碰撞”就此发生。又因为<code>HashMap</code>使用链表存储对象,这个<code>Node</code>会存储到链表中。</p>
<h2 id="HashMap是使用了哪些方法来有效解决哈希冲突的"><a href="#HashMap是使用了哪些方法来有效解决哈希冲突的" class="headerlink" title="HashMap是使用了哪些方法来有效解决哈希冲突的"></a>HashMap是使用了哪些方法来有效解决哈希冲突的</h2><p><strong>1. 使用链地址法（使用散列表）来链接拥有相同hash值的数据；</strong><br><strong>2. 使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</strong><br><strong>3. 引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</strong></p>
<h2 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方"></a>HashMap 的长度为什么是 2 的幂次方</h2><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到  2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40  亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。</p>
<p><strong>这个算法应该如何设计呢？</strong></p>
<p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</strong></p>
<h2 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题"></a>HashMap 多线程操作导致死循环问题</h2><p>主要原因在于并发下的 Rehash 会造成元素之间会形成一个循环链表。</p>
<h2 id="HashMap线程安全方面会出现什么问题"><a href="#HashMap线程安全方面会出现什么问题" class="headerlink" title="HashMap线程安全方面会出现什么问题"></a>HashMap线程安全方面会出现什么问题</h2><ul>
<li>在jdk1.7中，在多线程环境下，扩容时会造成环形链或数据丢失。</li>
<li>在jdk1.8中，在多线程环境下，会发生数据覆盖的情况</li>
</ul>
<h2 id="如果-hashCode-相同，如何获取对象呢"><a href="#如果-hashCode-相同，如何获取对象呢" class="headerlink" title="如果 hashCode 相同，如何获取对象呢"></a>如果 hashCode 相同，如何获取对象呢</h2><p>hashCode 相同，说明这些对象的数据都在同一个数组下标对应的链表或者树上。get 方法的签名是 V get (Object key)  ，入参只有一个 key，因此通过遍链表或者树，取出每一个节点对比 hash 值是否相等且 key 是否相等 (= 或者 equals)。</p>
<h2 id="HashMap-有哪几种常见的遍历方式"><a href="#HashMap-有哪几种常见的遍历方式" class="headerlink" title="HashMap 有哪几种常见的遍历方式?"></a>HashMap 有哪几种常见的遍历方式?</h2><p>HashMap <strong>遍历从大的方向来说，可分为以下 4 类</strong>：</p>
<ol>
<li>迭代器（Iterator）方式遍历；</li>
<li>For Each 方式遍历；</li>
<li>Lambda 表达式遍历（JDK 1.8+）;</li>
<li>Streams API 遍历（JDK 1.8+）。</li>
</ol>
<p>但每种类型下又有不同的实现方式，因此具体的遍历方式又可以分为以下 7 种：</p>
<ol>
<li>使用迭代器（Iterator）EntrySet 的方式进行遍历；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">            System.out.print(entry.getKey());</span><br><span class="line">            System.out.print(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<blockquote>
<p>1 Java 2 JDK 3 Spring Framework 4 MyBatis framework 5 Java中文社群</p>
</blockquote>
<ol start="2">
<li>使用迭代器（Iterator）KeySet 的方式进行遍历；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer key = iterator.next();</span><br><span class="line">            System.out.print(key);</span><br><span class="line">            System.out.print(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果为：</p>
<blockquote>
<p>1 Java 2 JDK 3 Spring Framework 4 MyBatis framework 5 Java中文社群</p>
</blockquote>
<ol start="3">
<li>使用 For Each EntrySet 的方式进行遍历；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.print(entry.getKey());</span><br><span class="line">            System.out.print(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果为：</p>
<blockquote>
<p>1 Java 2 JDK 3 Spring Framework 4 MyBatis framework 5 Java中文社群</p>
</blockquote>
<ol start="4">
<li>使用 For Each KeySet 的方式进行遍历；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            System.out.print(key);</span><br><span class="line">            System.out.print(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果为：</p>
<blockquote>
<p>1 Java 2 JDK 3 Spring Framework 4 MyBatis framework 5 Java中文社群</p>
</blockquote>
<ol start="5">
<li>使用 Lambda 表达式的方式进行遍历；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.forEach((key, value) -&gt; &#123;</span><br><span class="line">            System.out.print(key);</span><br><span class="line">            System.out.print(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果为：</p>
<blockquote>
<p>1 Java 2 JDK 3 Spring Framework 4 MyBatis framework 5 Java中文社群</p>
</blockquote>
<ol start="6">
<li>使用 Streams API 单线程的方式进行遍历；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.print(entry.getKey());</span><br><span class="line">            System.out.print(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果为：</p>
<blockquote>
<p>1 Java 2 JDK 3 Spring Framework 4 MyBatis framework 5 Java中文社群</p>
</blockquote>
<ol start="7">
<li>使用 Streams API 多线程的方式进行遍历。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.print(entry.getKey());</span><br><span class="line">            System.out.print(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果为：</p>
<blockquote>
<p>4 MyBatis framework 5 Java中文社群 1 Java 2 JDK 3 Spring Framework</p>
</blockquote>
<h2 id="HashMap常用方法测试"><a href="#HashMap常用方法测试" class="headerlink" title="HashMap常用方法测试"></a>HashMap常用方法测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">// 键不能重复，值可以重复</span></span><br><span class="line">        map.put(<span class="string">&quot;san&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;si&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wu&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wang&quot;</span>, <span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wang&quot;</span>, <span class="string">&quot;老王2&quot;</span>);<span class="comment">// 老王被覆盖</span></span><br><span class="line">        map.put(<span class="string">&quot;lao&quot;</span>, <span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------直接输出hashmap:-------&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历HashMap</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 1.获取Map中的所有键</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------foreach获取Map中所有的键:------&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            System.out.print(key+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line">        <span class="comment">// 2.获取Map中所有值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------foreach获取Map中所有的值:------&quot;</span>);</span><br><span class="line">        Collection&lt;String&gt; values = map.values();</span><br><span class="line">        <span class="keyword">for</span> (String value : values) &#123;</span><br><span class="line">            System.out.print(value+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line">        <span class="comment">// 3.得到key的值的同时得到key所对应的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------得到key的值的同时得到key所对应的值:-------&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys2 = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys2) &#123;</span><br><span class="line">            System.out.print(key + <span class="string">&quot;：&quot;</span> + map.get(key)+<span class="string">&quot;   &quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果既要遍历key又要value，那么建议这种方式，因为如果先获取keySet然后再执行map.get(key)，map内部会执行两次遍历。</span></span><br><span class="line"><span class="comment">         * 一次是在获取keySet的时候，一次是在遍历所有key的时候。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 当我调用put(key,value)方法的时候，首先会把key和value封装到</span></span><br><span class="line">        <span class="comment">// Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span></span><br><span class="line">        <span class="comment">// map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span></span><br><span class="line">        <span class="comment">// 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span></span><br><span class="line">        Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;--&quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * HashMap其他常用方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after map.size()：&quot;</span>+map.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.isEmpty()：&quot;</span>+map.isEmpty());</span><br><span class="line">        System.out.println(map.remove(<span class="string">&quot;san&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.remove()：&quot;</span>+map);</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.get(si)：&quot;</span>+map.get(<span class="string">&quot;si&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.containsKey(si)：&quot;</span>+map.containsKey(<span class="string">&quot;si&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after containsValue(李四)：&quot;</span>+map.containsValue(<span class="string">&quot;李四&quot;</span>));</span><br><span class="line">        System.out.println(map.replace(<span class="string">&quot;si&quot;</span>, <span class="string">&quot;李四2&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.replace(si, 李四2):&quot;</span>+map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>HashMap 中有四个构造方法，它们分别如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">     putMapEntries(m, <span class="keyword">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">     <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">     <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>putMapEntries方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><p>HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。</p>
<p><strong>对putVal方法添加元素的分析如下：</strong></p>
<ul>
<li><p>空数组有无初始化，没有的话初始化；</p>
</li>
<li><p>①如果定位到的数组位置没有元素 就直接插入。</p>
</li>
<li><p>②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</p>
</li>
</ul>
<p><img src="https://img1.sycdn.imooc.com/5d5fc7e200016af809121188.jpg" alt="图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 将第一个元素赋值给e，用e来记录</span></span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值，转化为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>我们再来对比一下 JDK1.7 put方法的代码</strong></p>
<p><strong>对于put方法的分析如下：</strong></p>
<ul>
<li>①如果定位到的数组位置没有元素 就直接插入。</li>
<li>②如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(table == EMPTY_TABLE)</span> </span>&#123; </span><br><span class="line">    inflateTable(threshold); </span><br><span class="line">&#125;  </span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123; <span class="comment">// 先遍历</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);  <span class="comment">// 再插入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组元素相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 桶中不止一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h3><p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ? (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="putTreeVal方法"><a href="#putTreeVal方法" class="headerlink" title="putTreeVal方法"></a>putTreeVal方法</h3><p>红黑树新增节点过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入参 h：key 的hash值</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//找到根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="comment">// p hash 值大于 h，说明 p 在 h 的右边</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// p hash 值小于 h，说明 p 在 h 的左边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//要放进去key在当前树中已经存在了(equals来判断)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">//自己实现的Comparable的话，不能用hashcode比较了，需要用compareTo</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  <span class="comment">//得到key的Class类型，如果key没有实现Comparable就是null</span></span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                  <span class="comment">//当前节点pk和入参k不等</span></span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="comment">//找到和当前hashcode值相近的节点(当前节点的左右子节点其中一个为空即可)</span></span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            <span class="comment">//生成新的节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="comment">//把新节点放在当前子节点为空的位置上</span></span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            <span class="comment">//当前节点和新节点建立父子，前后关系</span></span><br><span class="line">            xp.next = x;</span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">            <span class="comment">//balanceInsertion 对红黑树进行着色或旋转，以达到更多的查找效率，着色或旋转的几种场景如下</span></span><br><span class="line">            <span class="comment">//着色：新节点总是为红色；如果新节点的父亲是黑色，则不需要重新着色；如果父亲是红色，那么必须通过重新着色或者旋转的方法，再次达到红黑树的5个约束条件</span></span><br><span class="line">            <span class="comment">//旋转： 父亲是红色，叔叔是黑色时，进行旋转</span></span><br><span class="line">            <span class="comment">//如果当前节点是父亲的右节点，则进行左旋</span></span><br><span class="line">            <span class="comment">//如果当前节点是父亲的左节点，则进行右旋</span></span><br><span class="line">          </span><br><span class="line">            <span class="comment">//moveRootToFront 方法是把算出来的root放到根节点上</span></span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/03/30/redis%E6%8C%81%E4%B9%85%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/30/redis%E6%8C%81%E4%B9%85%E5%8C%96/" itemprop="url">redis持久化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-30T23:39:29+08:00">
                2021-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis知识点</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E7%9F%A5%E8%AF%86%E7%82%B9/redis-redis%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index">
                    <span itemprop="name">redis - redis配置</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">* 如果1个缓存更新，则3600 seconds (an hour)后备份</span><br><span class="line">* 如果100个缓存更新，则300 seconds (5 minutes)后备份</span><br><span class="line">* 如果10000个缓存更新，则60 seconds后备份</span><br><span class="line">save 3600 1</span><br><span class="line">save 300 100</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> yes:如果save过程出错，则停止写操作</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> no: 可能造成数据不一致</span></span><br><span class="line"></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> yes:开启rdb压缩模式，会造成cpu耗损</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> no：关闭，但是文件会大</span></span><br><span class="line"></span><br><span class="line">rdbchecksum yes</span><br><span class="line"><span class="meta">#</span><span class="bash">yes：使用CRC64算法校验对rdb进行数据校验</span></span><br><span class="line"><span class="meta">#</span><span class="bash">no：不校验</span></span><br></pre></td></tr></table></figure>

<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> AOF 默认关闭，yes可以开启</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> AOF 的文件名</span></span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> no：不同步</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> everysec：每秒备份，推荐使用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> always：每次操作都会备份，安全并且数据完整，但是慢性能差</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重写的时候是否要同步，no可以保证数据安全</span></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重写机制：避免文件越来越大，自动优化压缩指令，会fork一个新的进程去完成重写动作，新进程里的内存数据会被重写，此时旧的aof文件不会被读取使用，类似rdb</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前AOF文件的大小是上次AOF大小的100% 并且文件体积达到64m，满足两者则触发重写</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Redis-的持久化机制是什么？各自的优缺点？"><a href="#Redis-的持久化机制是什么？各自的优缺点？" class="headerlink" title="Redis 的持久化机制是什么？各自的优缺点？"></a>Redis 的持久化机制是什么？各自的优缺点？</h1><p>redis 提供两种持久化方式。</p>
<p><strong>RDB（Redis DataBase）</strong>，用数据集快照的方式，定时将 redis 存储的数据生成快照并存储到磁盘等介质上即在指定目录下生成一个 dump.rdb 文件；</p>
<p>Redis 提供了 SAVE 和BGSAVE两个命令来生成RDB文件，区别是前者是阻塞的，后者是后台 fork 子进程进行，不会阻塞主进程处理命令请求</p>
<p>持久化key之前，会检查是否过期，过期的key不进入RDB文件。数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）。</p>
<p>RDB适合大量数据的恢复，但是数据的完整性和一致性可能会不足。</p>
<p> <strong>AOF（Append -only file）</strong>，Redis默认不开启，它采用日志的形式来记录每个写操作，生成一个appendonly.aof 文件，并将日志追加到文件末尾。Redis重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<p>重写时，会先判断key是否过期，已过期的key不会重写到aof文件。</p>
<p>如果同时存在<code>RDB</code>和<code>AOF</code>的话会优先使用<code>AOF</code> 重建数据集，因为其保存的数据更完整。</p>
<h2 id="RDB-的优点："><a href="#RDB-的优点：" class="headerlink" title="RDB 的优点："></a>RDB 的优点：</h2><ol>
<li><p>每个一段时间备份，全量备份；</p>
</li>
<li><p>容灾简单，可以远程传输</p>
</li>
<li><p>性能最大化，fork 子进程来完成写操作，让主进程继续处理命令且不会进行任何 IO 操作的，这样就确保了 redis 极高的性能；</p>
</li>
<li><p>相对于数据集大时，比 AOF 的启动效率更高。</p>
</li>
</ol>
<h2 id="RDB-的缺点："><a href="#RDB-的缺点：" class="headerlink" title="RDB 的缺点："></a>RDB 的缺点：</h2><p>数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发 生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候；</p>
<p>备份时占用内存，因为Redis在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍），最后再将临时文件替换之前的备份文件</p>
<h2 id="RDB对过期key的处理"><a href="#RDB对过期key的处理" class="headerlink" title="RDB对过期key的处理"></a>RDB对过期key的处理</h2><p>过期key对RDB没有任何影响</p>
<ul>
<li>从内存数据库持久化数据到RDB文件<ul>
<li>持久化key之前，会检查是否过期，过期的key不进入RDB文件</li>
</ul>
</li>
<li>从RDB文件恢复数据到内存数据库<ul>
<li>数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）</li>
</ul>
</li>
</ul>
<h2 id="AOF-的优点："><a href="#AOF-的优点：" class="headerlink" title="AOF 的优点："></a>AOF 的优点：</h2><p>A. 数据安全，aof 持久化可以配置 append fsync 属性，比如无 fsync，每秒钟一次 fsync，或者每次执行写入命令时 fsync，一般只会丢失一秒钟的数据，或者最后一次执行的数据，对缓存来说，这已经足够。<br>B. 某些场景下还可以恢复数据。比如说某同学在操作 redis 时，不小心执行了 FLUSHALL，导致 redis 内存中的数据全部被清空了。如果 AOF 文件还没有被重写（rewrite），我们就可以用最快的速度暂停 redis 并编辑 AOF 文件，将最后一行的 FLUSHALL 命令删除，然后重启 redis，就可以恢复 redis 的所有数据到 FLUSHALL 之前的状态了。</p>
<h2 id="AOF-的缺点："><a href="#AOF-的缺点：" class="headerlink" title="AOF 的缺点："></a>AOF 的缺点：</h2><ol>
<li>相同的数据，同一份数据，AOF比RDB大</li>
<li>针对不同的同步机制，AOF会比RDB慢，因为AOF每秒都会备份做写操作，这样相对与RDB来说就略低。 每秒备份fsync没毛病，但是如果客户端的每次写入就做一次备份fsync的话，那么redis的性能就会下降。</li>
<li>AOF发生过bug，就是数据恢复的时候数据不完整，这样显得AOF会比较脆弱，容易出现bug，因为AOF没有RDB那么简单，但是呢为了防止bug的产生，AOF就不会根据旧的指令去重构，而是根据当时缓存中存在的数据指令去做重构，这样就更加健壮和可靠了。</li>
</ol>
<h2 id="AOF对过期key的处理"><a href="#AOF对过期key的处理" class="headerlink" title="AOF对过期key的处理"></a>AOF对过期key的处理</h2><p>过期key对AOF没有任何影响</p>
<ul>
<li>从内存数据库持久化数据到AOF文件：<ul>
<li>当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）</li>
<li>当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）</li>
</ul>
</li>
<li>AOF重写<ul>
<li>重写时，会先判断key是否过期，已过期的key不会重写到aof文件</li>
</ul>
</li>
</ul>
<h2 id="RDB-和-AOF-对比："><a href="#RDB-和-AOF-对比：" class="headerlink" title="RDB 和 AOF 对比："></a>RDB 和 AOF 对比：</h2><table>
<thead>
<tr>
<th>命令</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>丢数据</td>
<td>根据策略决定</td>
</tr>
<tr>
<td>轻重</td>
<td>重</td>
<td>轻</td>
</tr>
</tbody></table>
<h2 id="AOF-文件太大会怎么样？"><a href="#AOF-文件太大会怎么样？" class="headerlink" title="AOF 文件太大会怎么样？"></a>AOF 文件太大会怎么样？</h2><p>AOF 文件过大时，后台会自动地对 AOF 进行重写（rewrite)，重写时会压缩 AOF 文件的内容，只保留可以恢复数据的最小指令集。比如说，假如我们调用了 100 次 INCR 指令，在 AOF 文件中就要存储 100 条指令，但这明显是很低效的，完全可以把这 100 条指令合并成一条 SET 指令。</p>
<p>在进行 AOF 重写时，仍然是采用先写临时文件，全部完成后再替换的流程，所以断电、磁盘满等问题都不会影响 AOF 文件的可用性。</p>
<h2 id="采用RDB还是AOF"><a href="#采用RDB还是AOF" class="headerlink" title="采用RDB还是AOF"></a>采用RDB还是AOF</h2><ol>
<li>如果你能接受一段时间的缓存丢失，那么可以使用RDB</li>
<li>如果你对实时性的数据比较care，那么就用AOF</li>
<li>使用RDB和AOF结合一起做持久化，RDB做冷备，可以在不同时期对不同版本做恢复，AOF做热备，保证数据仅仅只有1秒的损失。当AOF破损不可用了，那么再用RDB恢复，这样就做到了两者的相互结合，也就是说Redis恢复会先加载AOF，如果AOF有问题会再加载RDB，这样就达到冷热备份的目的了。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <!--<a href="/archives/%7C%7Carchive">-->
                <a href="/archives/">
              
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuanyayuan" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:liyuan0707@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LiYuan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
