<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="工作中技术总结">
<meta property="og:type" content="website">
<meta property="og:title" content="Hikari的Java之路">
<meta property="og:url" content="https://yuanyayuan.github.io/page/3/index.html">
<meta property="og:site_name" content="Hikari的Java之路">
<meta property="og:description" content="工作中技术总结">
<meta property="og:locale">
<meta property="article:author" content="LiYuan">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yuanyayuan.github.io/page/3/"/>





  <title>Hikari的Java之路</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hikari的Java之路</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Hello,world</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/19/%E5%88%86%E6%AD%A5%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/19/%E5%88%86%E6%AD%A5%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/" itemprop="url">分步式-分布式理论</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-19T00:59:37+08:00">
                2021-04-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E6%AD%A5%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">分步式 - 分布式理论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>摘抄<a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/distributed-system/CAP%E7%90%86%E8%AE%BA">《CAP理论解读》</a></p>
<p>摘抄<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903936718012430">《神一样的CAP理论被应用在何方》</a></p>
<h1 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h1><p>CAP 也就是 Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错性） 这三个单词首字母组合。</p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/%E5%88%86%E5%B8%83%E5%BC%8F/CAP.png?ynotemdtimestamp=1618749953489" alt="img"></p>
<p>CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计读写操作时，只能能同时满足以下三点中的两个：</p>
<ul>
<li><strong>一致性（Consistence）</strong> : 所有节点访问同一份最新的数据副本</li>
<li><strong>可用性（Availability）</strong>: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</li>
<li><strong>分区容错性（Partition tolerance）</strong> : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</li>
</ul>
<h2 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h2><blockquote>
<p>P代表分区容错性，分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫网络分区。</p>
</blockquote>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%8C%BA%E5%AE%B9%E9%94%99.png?ynotemdtimestamp=1618749953489" alt="img"></p>
<p>分区容错性指在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。就好比是N1节点和N2节点出现故障，但是依然可以很好地对外提供服务。</p>
<h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><blockquote>
<p>C代表一致性，一致性指的是所有节点在同一时间的数据完全一致。举例来说，某条记录是 v0，用户向 G1 发起一个写操作，将其改为 v1。</p>
<p>接下来，用户的读操作就会得到 v1</p>
</blockquote>
<p><strong>对于一致性，也可以分为从客户端和服务端两个不同的视角来理解。</strong></p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。也就是小明和小华同时访问，如何获取更新的最新的数据。</p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>从服务端来看，则是更新如何分布到整个系统，以保证数据最终一致。也就是N1节点和N2节点如何通信保持数据的一致。</p>
<p><strong>对于一致性，一致的程度不同大体可以分为强、弱、最终一致性三类。</strong></p>
<h3 id="强一致性"><a href="#强一致性" class="headerlink" title="强一致性"></a>强一致性</h3><p>对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。比如小明更新V0到V1，那么小华读取的时候也应该是V1。</p>
<h3 id="弱一致性"><a href="#弱一致性" class="headerlink" title="弱一致性"></a>弱一致性</h3><p>如果能容忍后续的部分或者全部访问不到，则是弱一致性。比如小明更新VO到V1，可以容忍那么小华读取的时候是V0。</p>
<h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。比如小明更新VO到V1，可以使得小华在一段时间之后读取的时候是V0。</p>
<h2 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h2><p>可用性指服务一直可用，而且是正常响应时间。就好比N1和N2节点，不管什么时候访问，都可以正常的获取数据值。而不会出现问题。好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。</p>
<h1 id="分区容错性是必须要实现的"><a href="#分区容错性是必须要实现的" class="headerlink" title="分区容错性是必须要实现的"></a>分区容错性是必须要实现的</h1><blockquote>
<p>CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。</p>
</blockquote>
<h2 id="为什么无同时保证-C（一致性）A（可用性）-呢？"><a href="#为什么无同时保证-C（一致性）A（可用性）-呢？" class="headerlink" title="为什么无同时保证 C（一致性）A（可用性） 呢？"></a><strong>为什么无同时保证 C（一致性）A（可用性） 呢？</strong></h2><p>发生网络分区时，</p>
<p>为了把证C（一致性），那么N1必须在写操作时，锁定 N2 的读操作和写操作。只有数据同步后，才能重新开放读写，锁定期间，N2 不能读写，这就和 A （可用性）发生冲突了。</p>
<p>如果为了保证 A（可用性），其他节点的读写操作正常的话，那么势必不能锁定 N2，那就和 C （一致性）发生冲突了。</p>
<p><strong>C（一致性）A（可用性）的取舍根据具体业务来选择</strong></p>
<h1 id="CAP在服务中实际的应用例子"><a href="#CAP在服务中实际的应用例子" class="headerlink" title="CAP在服务中实际的应用例子"></a>CAP在服务中实际的应用例子</h1><ul>
<li>注册中心</li>
<li>分布式锁</li>
<li>分布式事务</li>
<li>MQ高可用</li>
</ul>
<h2 id="分布式注册中心是选择AP还是CP"><a href="#分布式注册中心是选择AP还是CP" class="headerlink" title="分布式注册中心是选择AP还是CP"></a>分布式注册中心是选择AP还是CP</h2><h3 id="服务注册中心解决的问题"><a href="#服务注册中心解决的问题" class="headerlink" title="服务注册中心解决的问题"></a>服务注册中心解决的问题</h3><p>在讨论CAP之前先明确下服务注册中心主要是解决什么问题：一个是服务注册，一个是服务发现。</p>
<ul>
<li>服务注册：实例将自身服务信息注册到注册中心，这部分信息包括服务的主机IP和服务的Port，以及暴露服务自身状态和访问协议信息等。</li>
<li>服务发现：实例请求注册中心所依赖的服务信息，服务实例通过注册中心，获取到注册到其中的服务实例的信息，通过这些信息去请求它们提供的服务。</li>
</ul>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png?ynotemdtimestamp=1618749953489" alt="img"></p>
<p>目前作为注册中心的一些组件大致有：Zookeeper，Eureka，consul，Nacos</p>
<h3 id="Zookeeper选择CP"><a href="#Zookeeper选择CP" class="headerlink" title="Zookeeper选择CP"></a>Zookeeper选择CP</h3><p>Zookeep保证CP，即任何时刻对Zookeeper的访问请求能得到一致性的数据结果，同时系统对网络分割具备容错性，但是它不能保证每次服务的可用性。从实际情况来分析，在使用Zookeeper获取服务列表时，如果zk正在选举或者zk集群中半数以上的机器不可用，那么将无法获取数据。所以说，zk不能保证服务可用性。</p>
<h3 id="eureka选择AP"><a href="#eureka选择AP" class="headerlink" title="eureka选择AP"></a>eureka选择AP</h3><p>eureka保证AP，eureka在设计时优先保证可用性，每一个节点都是平等的，一部分节点挂掉不会影响到正常节点的工作，不会出现类似zk的选举leader的过程，客户端发现向某个节点注册或连接失败，会自动切换到其他的节点，只要有一台eureka存在，就可以保证整个服务处在可用状态，只不过有可能这个服务上的信息并不是最新的信息。</p>
<h3 id="zookeeper和eureka的数据一致性问题"><a href="#zookeeper和eureka的数据一致性问题" class="headerlink" title="zookeeper和eureka的数据一致性问题"></a>zookeeper和eureka的数据一致性问题</h3><p>先要明确一点，eureka的创建初心就是为一个注册中心，但是zk更多是作为分布式协调服务的存在，只不过因为它的特性被dubbo赋予了注册中心，它的职责更多是保证数据（配置数据，状态数据）在管辖下的所有服务之间保持一致，所有这个就不难理解为何zk被设计成CP而不是AP，zk最核心的算法ZAB，就是为了解决分布式系统下数据在多个服务之间一致同步的问题。</p>
<p>更深层的原因，zookeeper是按照CP原则构建，也就是说它必须保持每一个节点的数据都保持一致，如果zookeeper下节点断开或者集群中出现网络分割（例如交换机的子网间不能互访），那么zk会将它们从自己的管理范围中剔除，外界不能访问这些节点，即使这些节点是健康的可以提供正常的服务，所以导致这些节点请求都会丢失。</p>
<p>而eureka则完全没有这方面的顾虑，它的节点都是相对独立，不需要考虑数据一致性的问题，这个应该是eureka的诞生就是为了注册中心而设计，相对zk来说剔除了leader节点选取和事务日志极致，这样更有利于维护和保证eureka在运行的健壮性。</p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/%E5%88%86%E5%B8%83%E5%BC%8F/ZookeeperAndEureka.png?ynotemdtimestamp=1618749953489" alt="image"></p>
<p>再来看看，数据不一致性在注册服务中中会给eureka带来什么问题，无非就是某一个节点被注册的服务多，某个节点注册的服务少，在某一个瞬间可能导致某些ip节点被调用数多，某些ip节点调用数少的问题。也有可能存在一些本应该被删除而没被删除的脏数据。</p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/%E5%88%86%E5%B8%83%E5%BC%8F/Eureka%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5.png?ynotemdtimestamp=1618749953489" alt="image"></p>
<h2 id="小结：服务注册应该选择AP还是CP"><a href="#小结：服务注册应该选择AP还是CP" class="headerlink" title="小结：服务注册应该选择AP还是CP"></a>小结：服务注册应该选择AP还是CP</h2><p>对于服务注册来说，针对同一个服务，即使注册中心的不同节点保存的服务注册信息不相同，也并不会造成灾难性的后果，对于服务消费者来说，能消费才是最重要的，就算拿到的数据不是最新的数据，消费者本身也可以进行尝试失败重试。总比为了追求数据的一致性而获取不到实例信息整个服务不可用要好。</p>
<p>所以，对于服务注册来说，可用性比数据一致性更加的重要，选择AP。</p>
<h2 id="分布式锁，是选择AP还是选择CP-？"><a href="#分布式锁，是选择AP还是选择CP-？" class="headerlink" title="分布式锁，是选择AP还是选择CP ？"></a>分布式锁，是选择AP还是选择CP ？</h2><ul>
<li>redis提供给高性能的AP模型，无法确保数据的一致性</li>
<li>zookeeper采用CP模型，分布式锁要比redis可靠很多，但性能不如redis</li>
</ul>
<h1 id="Base理论"><a href="#Base理论" class="headerlink" title="Base理论"></a>Base理论</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong> 、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。</p>
<h2 id="BASE-理论的核心思想"><a href="#BASE-理论的核心思想" class="headerlink" title="BASE 理论的核心思想"></a>BASE 理论的核心思想</h2><p>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<blockquote>
<p>也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。</p>
</blockquote>
<p><strong>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。</strong></p>
<p><strong>为什么这样说呢？</strong></p>
<p>CAP 理论这节我们也说过了：</p>
<blockquote>
<p>如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。因此，<strong>如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。</strong></p>
</blockquote>
<p>因此，AP 方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。在分区故障恢复后，系统应该达到最终一致性。这一点其实就是 BASE 理论延伸的地方。</p>
<h2 id="BASE-理论三要素"><a href="#BASE-理论三要素" class="headerlink" title="BASE 理论三要素"></a>BASE 理论三要素</h2><p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/%E5%88%86%E5%B8%83%E5%BC%8F/Base%E4%B8%89%E8%A6%81%E7%B4%A0.png?ynotemdtimestamp=1618749953489" alt="BASE理论三要素"></p>
<h3 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h3><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。</p>
<p><strong>什么叫允许损失部分可用性呢？</strong></p>
<ul>
<li><strong>响应时间上的损失</strong>: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。</li>
<li><strong>系统功能上的损失</strong>：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</li>
</ul>
<h3 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h3><p>软状态指允许系统中的数据存在中间状态（<strong>CAP 理论中的数据不一致</strong>），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
<h3 id="最终一致性-1"><a href="#最终一致性-1" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<blockquote>
<p>分布式一致性的 3 种级别：</p>
<ol>
<li><strong>强一致性</strong> ：系统写入了什么，读出来的就是什么。</li>
<li><strong>弱一致性</strong> ：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。</li>
<li><strong>最终一致性</strong> ：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。</li>
</ol>
<p><strong>业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。</strong></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。</strong></p>
<p>理解什么是**分布式和集群 **</p>
<p>比如，有一个秒杀服务，并发量太大单机系统承受不住，那我加几台服务器也 <strong>一样</strong> 提供秒杀服务，这个时候就是 <strong><code>Cluster</code> 集群</strong> 。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ffcb080eb66f242ffcd8d2047a7f46aa.png?ynotemdtimestamp=1618749953489" alt="cluster"></p>
<p>但是，我现在换一种方式，我将一个秒杀服务 <strong>拆分成多个子服务</strong> ，比如创建订单服务，增加积分服务，扣优惠券服务等等，<strong>然后我将这些子服务都部署在不同的服务器上</strong> ，这个时候就是 <strong><code>Distributed</code> 分布式</strong> 。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/07191f38aa947b0075e5c0a6a019a11d.png?ynotemdtimestamp=1618749953489" alt="distributed"></p>
<p><strong>分布式</strong>不等于加机器</p>
<p>加机器更加适用于构建集群，因为它真是只有加机器。而对于分布式来说，你首先需要将业务进行拆分，然后再加机器（不仅仅是加机器那么简单），同时你还要去解决分布式带来的一系列问题。</p>
<p>比如各个分布式组件如何协调起来，如何减少各个系统之间的耦合度，分布式事务的处理，如何去配置整个分布式系统等等。<code>ZooKeeper</code> 主要就是解决这些问题的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/18/%E5%88%86%E6%AD%A5%E5%BC%8F-%E5%88%86%E6%AD%A5%E5%BC%8F%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/18/%E5%88%86%E6%AD%A5%E5%BC%8F-%E5%88%86%E6%AD%A5%E5%BC%8F%E9%94%81/" itemprop="url">分步式-分步式锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-18T18:18:15+08:00">
                2021-04-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E6%AD%A5%E5%BC%8F-%E5%88%86%E6%AD%A5%E5%BC%8F%E9%94%81/" itemprop="url" rel="index">
                    <span itemprop="name">分步式 - 分步式锁</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="高效分布式锁"><a href="#高效分布式锁" class="headerlink" title="高效分布式锁"></a>高效分布式锁</h1><ol>
<li>互斥<br> 在分布式高并发的条件下，我们最需要保证，同一时刻只能有一个线程获得锁，这是最基本的一点。</li>
<li>防止死锁<br>在分布式高并发的条件下，比如有个线程获得锁的同时，还没有来得及去释放锁，就因为系统故障或者其它原因使它无法执行释放锁的命令,导致其它线程都无法获得锁，造成死锁。<br>所以分布式非常有必要设置锁的有效时间，确保系统出现故障后，在一定时间内能够主动去释放锁，避免造成死锁的情况。</li>
<li>性能<br>对于访问量大的共享资源，需要考虑减少锁等待的时间，避免导致大量线程阻塞。<br>所以在锁的设计时，需要考虑两点。<br>1、锁的颗粒度要尽量小。比如你要通过锁来减库存，那这个锁的名称你可以设置成是商品的ID,而不是任取名称。这样这个锁只对当前商品有效,锁的颗粒度小。<br>2、锁的范围尽量要小。比如只要锁2行代码就可以解决问题的，那就不要去锁10行代码了。</li>
<li>重入<br>我们知道ReentrantLock是可重入锁，那它的特点就是：同一个线程可以重复拿到同一个资源的锁。重入锁非常有利于资源的高效利用。关于这点之后会做演示。</li>
</ol>
<h1 id="如何选择分布式锁"><a href="#如何选择分布式锁" class="headerlink" title="如何选择分布式锁"></a>如何选择分布式锁</h1><p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/%E5%88%86%E6%AD%A5%E5%BC%8F%E9%94%81%E4%BC%98%E7%BC%BA%E7%82%B9.png" alt="image"></p>
<h1 id="基于数据库的分布式锁"><a href="#基于数据库的分布式锁" class="headerlink" title="基于数据库的分布式锁"></a>基于数据库的分布式锁</h1><p>这种方式对于单主却无法自动切换主从的mysql来说，基本就无法现实P分区容错性，（Mysql自动主从切换在目前并没有十分完美的解决方案）。可以说这种方式强依赖于数据库的可用性，数据库写操作是一个单点，一旦数据库挂掉，就导致锁的不可用。这种方式基本不在CAP的一个讨论范围。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>通过<code>select......for opdate</code>访问同一条数据 for update锁定数据，其他线程只能等待</p>
<blockquote>
<p>一个线程执行select …… for opdate 只要不提交事务就一直占用，其他线程执行select …… 时就会等待</p>
</blockquote>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>简单方便、易于理解、易于操作</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>并发量大时，对数据库压力大</li>
</ul>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>作为锁的数据库与业务数据库分开</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="基于独立的一张表记录"><a href="#基于独立的一张表记录" class="headerlink" title="基于独立的一张表记录"></a>基于独立的一张表记录</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `database_lock` (</span><br><span class="line">	`id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">	`resource` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;锁定的资源&#x27;</span>,</span><br><span class="line">	`description` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> &quot;&quot; COMMENT <span class="string">&#x27;描述&#x27;</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">	<span class="keyword">UNIQUE</span> KEY `uiq_idx_resource` (`resource`) </span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;数据库分布式锁表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>当我们想要获得锁时，可以插入一条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> database_lock(resource, description) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;lock&#x27;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在表database_lock中，resource字段做了唯一性约束，这样如果有多个请求同时提交到数据库的话，数据库可以保证只有一个操作可以成功（其它的会报错：ERROR 1062 (23000): Duplicate entry ‘1’ for key ‘uiq_idx_resource’），那么那么我们就可以认为操作成功的那个请求获得了锁。</p>
</blockquote>
<p>当需要释放锁的时，可以删除这条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> database_lock <span class="keyword">WHERE</span> resource<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="基于乐观锁"><a href="#基于乐观锁" class="headerlink" title="基于乐观锁"></a>基于乐观锁</h3><p>引入了version字段，在进行业务逻辑时：</p>
<ul>
<li>STEP1 - 获取资源： SELECT resource, version FROM optimistic_lock WHERE id = 1</li>
<li>STEP2 - 执行业务逻辑</li>
<li>STEP3 - 更新资源：UPDATE optimistic_lock SET resource = resource -1, version = version + 1 WHERE id = 1 AND version = oldVersion</li>
</ul>
<h3 id="基于悲观锁"><a href="#基于悲观锁" class="headerlink" title="基于悲观锁"></a>基于悲观锁</h3><p>通过select……for update访问同一条数据, for update锁定数据，其他线程只能等待</p>
<p><strong>加锁信号量</strong>：select …… for update</p>
<p><strong>解锁信号量</strong>：commit </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `distribute_lock`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `distribute_lock`  (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `business_code` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `business_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> Compact;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `distribute_lock` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;demo&#x27;</span>, <span class="string">&#x27;demo演示&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>dao</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DistributeLock <span class="title">selectDistributeLock</span><span class="params">(<span class="meta">@Param(&quot;businessCode&quot;)</span> String businessCode)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>mapper：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectDistributeLock&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.distributelock.DistributeLock&quot;</span>&gt;</span></span><br><span class="line">    select </span><br><span class="line">        * </span><br><span class="line">    from </span><br><span class="line">        distribute_lock</span><br><span class="line">    where </span><br><span class="line">        business_code = #&#123;businessCode,jdbcType=VARCHAR&#125;</span><br><span class="line">    for update</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>controller</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DistributeLockMapper distributeLockMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;singleLock&quot;)</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">singleLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;我进入了方法！&quot;</span>);</span><br><span class="line">        DistributeLock distributeLock = distributeLockMapper.selectDistributeLock(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (distributeLock==<span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;分布式锁找不到&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;我进入了锁！&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我已经执行完成！&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>唯一要注意的就是controller层需要打上事务注解，如果不加的话查询sql会自动提交事务导致分布式锁失效。</p>
</blockquote>
<h1 id="基于redis实现分布式锁（基于AP的分布式锁）"><a href="#基于redis实现分布式锁（基于AP的分布式锁）" class="headerlink" title="基于redis实现分布式锁（基于AP的分布式锁）"></a>基于redis实现分布式锁（基于AP的分布式锁）</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>SET resource_name my_random_value NX PX 30000</p>
<ul>
<li>NX: key不存在时设置成功，key存在则设置不成功（基于redis单线程特性）</li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li>获取锁的Redis命令</li>
<li>SET resource_name my_random_value NX PX 30000<ul>
<li>set命令</li>
<li>resource_name: 资源名称，可根据不同的业务区分不同的锁</li>
<li>my_random_value: 随机值，<strong>每个线程</strong>的随机值都不同，用于释放锁时的校验</li>
<li>NX: key不存在时设置成功，key存在则设置不成功（基于redis单线程特性）</li>
<li>PX: 自动失效时间，出现异常情况，锁可以过期失效</li>
</ul>
</li>
<li>利用NX的原子性，多个线程并发时，只有一个线程可以设置成功</li>
<li>设置成功即获得锁，可以执行后续的业务处理</li>
<li>如果出现异常，过了锁的有效期，锁自动释放</li>
<li>释放锁采用Redis的delete命令</li>
<li>释放锁是检验之前设置的随机数，相同才释放</li>
<li>释放锁时用lua脚本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) &#x3D;&#x3D; ARGV[1] then </span><br><span class="line">    return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>KEYS[1] – redis中的值</p>
<p>ARGV[1] – 传入的值</p>
<h2 id="简单例子代码"><a href="#简单例子代码" class="headerlink" title="简单例子代码"></a>简单例子代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLockController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;redisLock&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">redisLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;我进入了方法&quot;</span>);</span><br><span class="line">        String key = <span class="string">&quot;redisKey&quot;</span>;</span><br><span class="line">        String value = UUID.randomUUID().toString();</span><br><span class="line">        RedisCallback&lt;Boolean&gt; redisCallback = connection -&gt; &#123;</span><br><span class="line">            <span class="comment">//设置NX</span></span><br><span class="line">            RedisStringCommands.SetOption setOption = RedisStringCommands.SetOption.SET_IF_ABSENT;</span><br><span class="line">            <span class="comment">//设置过期时间</span></span><br><span class="line">            Expiration expiration = Expiration.seconds(<span class="number">30</span>);</span><br><span class="line">            <span class="comment">//序列化key</span></span><br><span class="line">            <span class="keyword">byte</span>[] redisKey = redisTemplate.getKeySerializer().serialize(key);</span><br><span class="line">            <span class="comment">//序列化value</span></span><br><span class="line">            <span class="keyword">byte</span>[] redisValue = redisTemplate.getValueSerializer().serialize(value);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">assert</span> redisKey != <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">assert</span> redisValue != <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> connection.set(redisKey, redisValue, expiration, setOption);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//获取分布式锁</span></span><br><span class="line">        Boolean lock = (Boolean)redisTemplate.execute(redisCallback);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(lock!=<span class="keyword">null</span> &amp;&amp; lock)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;我进入了锁&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">15000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                String script = <span class="string">&quot;if redis.call(\&quot;get\&quot;,KEYS[1]) == ARGV[1] then\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;    return redis.call(\&quot;del\&quot;,KEYS[1])\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;else\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;    return 0\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;end&quot;</span>;</span><br><span class="line">                List&lt;String&gt; keys = Collections.singletonList(key);</span><br><span class="line">                RedisScript&lt;Boolean&gt; redisScript = RedisScript.of(script,Boolean.class);</span><br><span class="line">                Boolean result = (Boolean)redisTemplate.execute(redisScript, keys, value);</span><br><span class="line">                log.info(<span class="string">&quot;释放锁的结果：&quot;</span> + result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;方法执行完成&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;方法执行完成&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="基于Redisson实现分布式锁"><a href="#基于Redisson实现分布式锁" class="headerlink" title="基于Redisson实现分布式锁"></a>基于Redisson实现分布式锁</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/Redisson%E5%8E%9F%E7%90%86.png"></p>
<h3 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h3><p>线程去获取锁，获取成功: 根据hash节点选择一台机器执行lua脚本，保存数据到redis数据库。</p>
<blockquote>
<p>注意，仅仅只是选择一台机器！</p>
</blockquote>
<p>线程去获取锁，获取失败: 一直通过while循环尝试获取锁，获取成功后，执行lua脚本，保存数据到redis数据库。</p>
<h3 id="为啥要用lua脚本"><a href="#为啥要用lua脚本" class="headerlink" title="为啥要用lua脚本"></a>为啥要用lua脚本</h3><p>一大坨复杂的业务逻辑，可以通过封装在lua脚本中发送给redis，保证这段复杂业务逻辑执行的原子性。</p>
<h3 id="watch-dog自动延期机制"><a href="#watch-dog自动延期机制" class="headerlink" title="watch dog自动延期机制"></a>watch dog自动延期机制</h3><p>客户端加锁的key默认生存时间是30秒，如果超过了30秒，客户端还想一直持有这把锁，怎么办呢？</p>
<p>只要客户端一旦加锁成功，就会启动一个watch dog看门狗，他是一个后台线程，每到过期时间1/3（默认生存时间是30s的话，就是10s）就去重新刷一次，如果客户端还持有锁key，那么就会不断的延长锁key的生存时间，如果key不存在则停止刷新。</p>
<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>1、Redis存储锁的数据类型是 Hash类型<br>2、Hash数据类型的key值包含了当前线程信息。</p>
<h3 id="释放锁机制"><a href="#释放锁机制" class="headerlink" title="释放锁机制"></a>释放锁机制</h3><p>如果执行lock.unlock()，就可以释放分布式锁，此时的业务逻辑其实很简单。</p>
<p>就是每次都对myLock数据结构中的那个加锁次数减1。</p>
<p>如果发现加锁次数是0了，说明这个客户端已经不再持有锁了，此时就会用： “del myLock”命令，从redis里删除这个key。</p>
<h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><ul>
<li>引入redission依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>SpringBoot集成Redission<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment"># Redis数据库索引（默认为0）</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># Redis服务器地址</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="comment"># Redis服务器连接端口</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment"># Redis服务器连接密码（默认为空）</span></span><br><span class="line">    <span class="attr">password:</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="comment"># 连接池最大连接数（使用负值表示没有限制） 默认 8</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment">#  连接池最大阻塞等待时间（使用负值表示没有限制） 默认 -1</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 连接池中的最大空闲连接 默认 8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment"># 连接池中的最小空闲连接 默认 0</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 连接超时时间（毫秒）</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissionLockController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redisson;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;redissonLock&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">redissonLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RLock rLock = redisson.getLock(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;我进入了方法！！&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rLock.lock(<span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">            log.info(<span class="string">&quot;我获得了锁！！！&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;我释放了锁！！&quot;</span>);</span><br><span class="line">            rLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;方法执行完成！！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;方法执行完成！！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Redis分布式锁会有个缺陷，就是在Redis哨兵模式下"><a href="#Redis分布式锁会有个缺陷，就是在Redis哨兵模式下" class="headerlink" title="Redis分布式锁会有个缺陷，就是在Redis哨兵模式下:"></a>Redis分布式锁会有个缺陷，就是在Redis哨兵模式下:</h1><h2 id="问题出现"><a href="#问题出现" class="headerlink" title="问题出现"></a>问题出现</h2><p><code>客户端1</code> 对某个<code>master节点</code>写入了redisson锁，此时会异步复制给对应的 slave节点。但是这个过程中一旦发生 master节点宕机，主备切换，slave节点从变为了 master节点。</p>
<p>这时<code>客户端2</code> 来尝试加锁的时候，在新的master节点上也能加锁，此时就会导致多个客户端对同一个分布式锁完成了加锁。</p>
<p><code>缺陷</code>在哨兵模式或者主从模式下，如果 master实例宕机的时候，可能导致多个客户端同时完成加锁。</p>
<p><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%BC%BA%E9%99%B7.png" alt="image"></p>
<p>详细步骤：</p>
<ol>
<li>业务线程-1 向主节点请求锁</li>
<li>业务线程-1 获取锁</li>
<li>业务线程-1 获取到锁并开始执行业务</li>
<li>这个时候redis刚生成的锁在主从之间还未进行同步</li>
<li>redis这时候主节点挂掉了</li>
<li>redis的从节点升级为主节点</li>
<li>业务线程-2 想新的主节点请求锁</li>
<li>业务线程-2 获取到新的主节点返回的锁</li>
<li>业务线程-2 获取到锁开始执行业务</li>
<li>这个时候 业务线程-1 和 业务线程-2 同时在执行任务</li>
</ol>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>redis采用了<code>A</code>（可用性）<code>P</code>（分区容错性）模型，它本身无法确保我们对一致性的要求</p>
<h2 id="能否使用redis作为分布式锁"><a href="#能否使用redis作为分布式锁" class="headerlink" title="能否使用redis作为分布式锁"></a>能否使用redis作为分布式锁</h2><p>能不能使用redis作为分布式锁，这个本身就不是redis的问题，还是取决于业务场景，我们先要自己确认我们的场景是适合 AP 还是 CP ， 如果在社交发帖等场景下，我们并没有非常强的事务一致性问题，redis提供给我们高性能的AP模型是非常适合的，但如果是交易类型，对数据一致性非常敏感的场景，我们可能要寻在一种更加适合的 CP 模型</p>
<h1 id="基于zookeeper实现分布式锁（基于CP的分布式锁）"><a href="#基于zookeeper实现分布式锁（基于CP的分布式锁）" class="headerlink" title="基于zookeeper实现分布式锁（基于CP的分布式锁）"></a>基于zookeeper实现分布式锁（基于CP的分布式锁）</h1><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><ul>
<li>利用Zookeeper的瞬时有序节点的特性</li>
<li>多线程并发创建瞬时节点时，得到有序的序列</li>
<li>序号最小的线程获得锁</li>
<li>其他的线程则监听自己序号的前一个序号</li>
<li>以此类推</li>
<li>创建节点时，已经确定线程的执行顺序</li>
</ul>
<img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/redis/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86.png" alt="image" style="zoom:67%;" />

<p><strong>zk组合分布式锁:</strong></p>
<ol>
<li>业务线程-1 业务线程-2 分别向zk的/lock目录下，申请创建有序的临时节点</li>
<li>业务线程-1 抢到/lock0001 的文件，也就是在整个目录下最小序的节点，也就是线程-1获取到了锁</li>
<li>业务线程-2 只能抢到/lock0002的文件，并不是最小序的节点，线程2未能获取锁</li>
<li>业务线程-1 与 lock0001 建立了连接，并维持了心跳，维持的心跳也就是这把锁的租期</li>
<li>当业务线程-1 完成了业务，将释放掉与zk的连接，也就是释放了这把锁</li>
</ol>
<h1 id="究竟该用CP还是AP的分布式锁"><a href="#究竟该用CP还是AP的分布式锁" class="headerlink" title="究竟该用CP还是AP的分布式锁"></a>究竟该用CP还是AP的分布式锁</h1><p>首先得了解清楚我们使用分布式锁的场景，为何使用分布式锁，用它来帮我们解决什么问题，先聊场景后聊分布式锁的技术选型。</p>
<p>无论是redis，zk，例如redis的AP模型会限制很多使用场景，但它却拥有了几者中最高的性能，zookeeper的分布式锁要比redis可靠很多，但他繁琐的实现机制导致了它的性能不如redis，而且zk会随着集群的扩大而性能更加下降。</p>
<p>简单来说，先了解业务场景，后进行技术选型。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/17/MySQL-MyBatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/17/MySQL-MyBatis/" itemprop="url">MySQL-MyBatis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-17T23:54:16+08:00">
                2021-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MyBatis-MyBatis%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">MyBatis - MyBatis知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是Mybatis"><a href="#什么是Mybatis" class="headerlink" title="什么是Mybatis"></a>什么是Mybatis</h1><ol>
<li><p>Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程</p>
</li>
<li><p>MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p>
</li>
<li><p>通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和 statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回</p>
</li>
</ol>
<h1 id="Mybaits的优点："><a href="#Mybaits的优点：" class="headerlink" title="Mybaits的优点："></a>Mybaits的优点：</h1><ol>
<li>基于SQL语句编程，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用</li>
<li>很好的与各种数据库兼容</li>
<li>能够与Spring很好的集成</li>
<li>提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</li>
</ol>
<h1 id="MyBatis框架的缺点："><a href="#MyBatis框架的缺点：" class="headerlink" title="MyBatis框架的缺点："></a>MyBatis框架的缺点：</h1><p>（1）SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</p>
<p>（2）SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p>
<h1 id="parameterType，-resultmap与-resulttype"><a href="#parameterType，-resultmap与-resulttype" class="headerlink" title="@parameterType，@resultmap与@resulttype"></a>@parameterType，@resultmap与@resulttype</h1><h2 id="parameterType"><a href="#parameterType" class="headerlink" title="@parameterType"></a>@parameterType</h2><ol>
<li><p>基本数据类型，如输入参数只有一个，其数据类型可以是基本的数据类型，也可以是自己定的类类型。包括int,String,Integer,Date,如下：</p>
<p> （1）根据id进行相应的删除：<delete id="deleteById" parameterType="Integer"></p>
<p>（2）添加员工：<insert id="addEmp" parameterType="com.pojo.Employee"></p>
</li>
<li><p>复杂数据类型：包含java实体类，map。</p>
<p>配置如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectTeacher&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.myapp.domain.Teacher&quot;</span>&gt;</span> </span><br><span class="line">	select * from Teacher where c_id=#&#123;id&#125; and sex=#&#123;sex&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map=<span class="keyword">new</span> HasMap&lt;String,String&gt;(); </span><br><span class="line">map.put(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;2&quot;</span>); </span><br><span class="line">map.put(<span class="string">&quot;sex&quot;</span>,<span class="string">&quot;男&quot;</span>); </span><br><span class="line">List&lt;Teacher&gt; tList = teacherMapper.selectTeacher(map);  </span><br><span class="line"><span class="keyword">for</span> (Teacher entityTemp : tList) &#123;  </span><br><span class="line">    System.out.println(entityTemp.toString()); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Param"><a href="#Param" class="headerlink" title="@Param"></a>@Param</h3><p>   使用<code>@Param</code>添加<strong>多个参数</strong>，xml中不用写<code>@parameterType</code></p>
<h2 id="resultmap与-resulttype"><a href="#resultmap与-resulttype" class="headerlink" title="@resultmap与@resulttype"></a>@resultmap与@resulttype</h2><p>1、resultmap：resultMap如果查询出来的列名和pojo的属性名不一致，通过在xml中定义一个resultMap对列名和pojo属性名之间作一个映射关系。</p>
<p>2、resulttype：resultType使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功</p>
<h1 id="当实体类中的属性名和表中的字段名不一样-，怎么办"><a href="#当实体类中的属性名和表中的字段名不一样-，怎么办" class="headerlink" title="当实体类中的属性名和表中的字段名不一样 ，怎么办"></a>当实体类中的属性名和表中的字段名不一样 ，怎么办</h1><ol>
<li><p>通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectorder”</span> <span class="attr">parametertype</span>=<span class="string">”int”</span></span></span><br><span class="line"><span class="tag"><span class="attr">resultetype</span>=<span class="string">”me.gacl.domain.order”</span>&gt;</span></span><br><span class="line">select order_id id, order_no orderno ,order_price price form orders where</span><br><span class="line">order_id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>通过来映射字段名和实体类属性名的一一对应的关系</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getOrder&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;orderresultmap&quot;</span>&gt;</span></span><br><span class="line">	select * from orders where order_id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">”me.gacl.domain.order”</span> <span class="attr">id</span>=<span class="string">”orderresultmap”</span>&gt;</span></span><br><span class="line">    &lt;!–用id属性来映射主键字段–&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">”id”</span> <span class="attr">column</span>=<span class="string">”order_id”</span>&gt;</span></span><br><span class="line">    &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span> = <span class="string">“orderno”</span> <span class="attr">column</span> =<span class="string">”order_no”/</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">”price”</span> <span class="attr">column</span>=<span class="string">”order_price”</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">reslutMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h1><ul>
<li><code>$&#123;&#125;</code>是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为<code>com.mysql.jdbc.Driver</code>。</li>
<li><code>#&#123;&#125;</code>是 sql 的参数占位符，MyBatis 会将 sql 中的<code>#&#123;&#125;</code>替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值，比如 ps.setInt(0, parameterValue)，<code>#&#123;item.name&#125;</code> 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 <code>param.getItem().getName()</code>。</li>
<li>由于 <code>$&#123;&#125;</code> 可能会引起 SQL 注入，所以一般能用 <code>#&#123;&#125;</code>就别用 <code>$&#123;&#125;</code>。</li>
</ul>
<h1 id="Xml-映射文件中，除了常见的-select-insert-updae-delete-标签之外，还有哪些标签？"><a href="#Xml-映射文件中，除了常见的-select-insert-updae-delete-标签之外，还有哪些标签？" class="headerlink" title="Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？"></a>Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？</h1><p>还有很多其他的标签，<code>&lt;resultMap&gt;</code>、<code>&lt;parameterMap&gt;</code>、<code>&lt;sql&gt;</code>、<code>&lt;include&gt;</code>、<code>&lt;selectKey&gt;</code>，加上动态 sql 的 9 个标签，<code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>等，其中为 sql 片段标签，通过<code>&lt;include&gt;</code>标签引入 sql 片段，<code>&lt;selectKey&gt;</code>为不支持自增的主键生成策略标签。</p>
<h1 id="通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？"><a href="#通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？"></a>通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</h1><p>Dao 接口，就是人们常说的 <code>Mapper</code>接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中<code>MappedStatement</code>的 id 值，接口方法内的参数，就是传递给 sql 的参数。<code>Mapper</code>接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个<code>MappedStatement</code>，</p>
<p>Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p>
<p>Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行<code>MappedStatement</code>所代表的 sql，然后将 sql 执行结果返回。</p>
<h1 id="MyBatis-是如何进行分页的？分页插件的原理是什么？"><a href="#MyBatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="MyBatis 是如何进行分页的？分页插件的原理是什么？"></a>MyBatis 是如何进行分页的？分页插件的原理是什么？</h1><p>MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页</p>
<p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<h1 id="MyBatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？"><a href="#MyBatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？" class="headerlink" title="MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？"></a>MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？</h1><p>MyBatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能，MyBatis 提供了 9 种动态 sql 标签 <code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>。</p>
<h1 id="MyBatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#MyBatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h1><p>MyBatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 MyBatis 配置文件中，可以配置是否启用延迟加载 <code>lazyLoadingEnabled=true|false。</code></p>
<p>它的原理是，使用<code>CGLIB</code> 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 <code>a.getB().getName()</code>，拦截器 <code>invoke()</code>方法发现 <code>a.getB()</code>是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 <code>a.getB().getName()</code>方法的调用。这就是延迟加载的基本原理。</p>
<h1 id="MyBatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？"><a href="#MyBatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？" class="headerlink" title="MyBatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？"></a>MyBatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？</h1><p>不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践而已。</p>
<p>原因就是 namespace+id 是作为 <code>Map&lt;String, MappedStatement&gt;</code>的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。</p>
<h1 id="MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h1><p>MyBatis 有三种基本的 Executor 执行器，**<code>SimpleExecutor</code>、<code>ReuseExecutor</code>、<code>BatchExecutor</code>。**</p>
<p><strong>SimpleExecutor</strong>：每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。</p>
<p><strong>ReuseExecutor</strong>：执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用 Statement 对象。</p>
<p><strong>BatchExecutor</strong>：执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。</p>
<p>作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。</p>
<h1 id="MyBatis-中如何指定使用哪一种-Executor-执行器？"><a href="#MyBatis-中如何指定使用哪一种-Executor-执行器？" class="headerlink" title="MyBatis 中如何指定使用哪一种 Executor 执行器？"></a>MyBatis 中如何指定使用哪一种 Executor 执行器？</h1><p>在 MyBatis 配置文件中，可以指定默认的 ExecutorType 执行器类型，也可以手动给 <code>DefaultSqlSessionFactory</code> 的创建 SqlSession 的方法传递 ExecutorType 类型参数。</p>
<h1 id="为什么说-MyBatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？"><a href="#为什么说-MyBatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？" class="headerlink" title="为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？"></a>为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</h1><p>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 MyBatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。</p>
<h1 id="说说-Mybatis-与-Hibernate-的相同点和不同点"><a href="#说说-Mybatis-与-Hibernate-的相同点和不同点" class="headerlink" title="说说 Mybatis 与 Hibernate 的相同点和不同点"></a>说说 Mybatis 与 Hibernate 的相同点和不同点</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>Hibernate 与 MyBatis 都是优秀 ORM 框架，都可以通过 XML 配置文件由 SessionFactoryBuider 生成 SessionFactory，然后由 SessionFactory 生成 Session，最后由 Session 来开启执行事务和 SQL 语句。</p>
<p>其中 SessionFactoryBuider，SessionFactory，Session 的生命周期都是差不多的。Hibernate 和 MyBatis 都支持 JDBC 和 JTA 事务处理。</p>
<h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><ol>
<li><p><strong>Hibernate 是全自动，而 MyBatis 是半自动</strong></p>
<p>查询关联对象或者关联集合对象时，Hibernate 可以根据对象关系直接获取，自动生成 sql；而 MyBatis 仅有基本的字段映射，需要手动编写 sql 来完成。</p>
</li>
<li><p><strong>Hibernate 数据库耦合性比 MyBatis 要低很多</strong></p>
<p>Hibernate 通过对象映射和 hql 语言，降低了语言与源数据库（Oracle、MySQL 等）的耦合性；而 MyBatis 由于需要手写 sql，因此与源数据库的耦合性很高，如果要移植到不同的数据库，又使用了某数据库特有的 sql 语法，还需要手动修改 sql，移值性比较差。</p>
</li>
<li><p><strong>Hibernate 的 SQL 灵活度和优化上比 MyBatis 要差很多</strong></p>
<p>Hibernate 的 sql 很多都是自动生成的，无法直接维护 sql，而它的 hql 功能要比 sql 差不少，优化起来比较麻烦；而 MyBatis 的 sql 都是写在 xml 里，因此优化 sql 会方便很多。</p>
</li>
<li><p><strong>Hibernate 的缓存机制 MyBatis 不同</strong></p>
<p>Hibernate 使用二级缓存时如果出现脏数据，系统会报错并提示；MyBatis 的二级缓存是在每个具体的表 - 对象映射中进行配置，这样针对不同的表可以自定义不同的缓存机制；而且 Mybatis 可以在命名空间中通过 Cache-ref 来共享相同的缓存配置和实例。</p>
</li>
<li><p><strong>Hibernate 的日志系统比 MyBatis 更好</strong></p>
<p>Hibernate 日志系统非常健全，涉及广泛，包括：sql 记录、关系异常、优化警告、缓存提示、脏数据警告等；MyBatis 主要是基本的记录功能，要差很多。</p>
</li>
</ol>
<h1 id="介绍一下Mybatis和主要的工作过程？"><a href="#介绍一下Mybatis和主要的工作过程？" class="headerlink" title="介绍一下Mybatis和主要的工作过程？"></a>介绍一下Mybatis和主要的工作过程？</h1><p>每一个Mybatis的应用程序都以一个SqlSessionFactory对象的实例为核心。首先用字节流通过Resource将配置文件读入，然后通过SqlSessionFactoryBuilder().build方法创建SqlSessionFactory，然后再通过SqlSessionFactory.openSession()方法创建一个SqlSession为每一个数据库事务服务。</p>
<p>经历了Mybatis初始化 –&gt;创建SqlSession –&gt;运行SQL语句，返回结果三个过程。</p>
<h1 id="MyBatis编程步骤是什么样的？"><a href="#MyBatis编程步骤是什么样的？" class="headerlink" title="MyBatis编程步骤是什么样的？"></a>MyBatis编程步骤是什么样的？</h1><p>1、创建SqlSessionFactory</p>
<p>2、通过SqlSessionFactory创建SqlSession</p>
<p>3、通过sqlsession执行数据库操作</p>
<p>4、调用session.commit()提交事务</p>
<p>5、调用session.close()关闭会话</p>
<h1 id="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h1><p>第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。第二<br>种是使用sql 列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，<br>对象属性名一般是name，小写，但是列名不区分大小写，Mybatis 会忽略列名大小<br>写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis<br>一样可以正常工作。<br>有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象<br>的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h1 id="简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a>简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h1><p>答：Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<parameterMap>标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。<resultMap>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</p>
<h1 id="java使用jdbc连接数据库步骤"><a href="#java使用jdbc连接数据库步骤" class="headerlink" title="java使用jdbc连接数据库步骤"></a>java使用jdbc连接数据库步骤</h1><ol>
<li>加载数据库驱动 Class.forName(“com.mysql.cj.jdbc.Driver”);</li>
<li>连接数据库 String url=“jdbc:mysql://localhost/studentserverTimezone=GMT%2B8&amp;useSSL=false”; String databasename=“root”; String pass=“123456”;</li>
<li>得到与数据库的连接对象</li>
<li>声明sql语句</li>
<li>得到语句对象</li>
<li>执行sql语句</li>
<li>分析结果集</li>
<li>释放资源</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/17/MySQL-MySQl%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/17/MySQL-MySQl%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/" itemprop="url">MySQL-MySQl联表查询练习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-17T23:39:30+08:00">
                2021-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL-MySQL%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL - MySQL知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BB%83%E4%B9%A02.png" style="zoom: 67%;" />

<h1 id="三表连接查询"><a href="#三表连接查询" class="headerlink" title="三表连接查询"></a>三表连接查询</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TableA (ID, Number, Name, etc.)</span><br><span class="line"></span><br><span class="line">TableB (ID, <span class="keyword">Order</span>, TableA_ID, etc.)</span><br><span class="line"></span><br><span class="line">TableC (ID, <span class="keyword">Order</span>, Action, Device, TableB_ID, etc.) </span><br><span class="line"><span class="keyword">SELECT</span> TableB.Order, TableC.Order, </span><br><span class="line">         TableC.Action, TableC.Device  </span><br><span class="line">    <span class="keyword">FROM</span> TableC  </span><br><span class="line">   <span class="keyword">INNER</span> <span class="keyword">JOIN</span> TableB  </span><br><span class="line">      <span class="keyword">ON</span> TableB.Id <span class="operator">=</span> TableC.TableB_Id  </span><br><span class="line">   <span class="keyword">INNER</span> <span class="keyword">JOIN</span> TableA  </span><br><span class="line">      <span class="keyword">ON</span> TableA.Id <span class="operator">=</span> TableB.TableA_Id  </span><br><span class="line">   <span class="keyword">WHERE</span> TableA.Number  </span><br><span class="line">    <span class="keyword">LIKE</span> &quot;USER INPUT&quot;</span><br></pre></td></tr></table></figure>

<h1 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h1><h2 id="学生表student（Sid，Sname，Sage，Sex），课程表course（Cid，Cname，Tid），成绩表score（Sid，Cid，Score）"><a href="#学生表student（Sid，Sname，Sage，Sex），课程表course（Cid，Cname，Tid），成绩表score（Sid，Cid，Score）" class="headerlink" title="学生表student（Sid，Sname，Sage，Sex），课程表course（Cid，Cname，Tid），成绩表score（Sid，Cid，Score）"></a>学生表student（Sid，Sname，Sage，Sex），课程表course（Cid，Cname，Tid），成绩表score（Sid，Cid，Score）</h2><p>1.查询课程名称为“java”，成绩从高到低的学生信息（学号，姓名，成绩）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select stu.Sid,stu.Sname,sc.Score</span><br><span class="line">from student stu,course cou,score sc</span><br><span class="line">where stu.Sid &#x3D; sc.Sid and sc.Cid &#x3D; cou.Cid</span><br><span class="line">and cou.Cname &#x3D; &quot;java&quot;</span><br><span class="line">ORDER BY sc.Score DESC</span><br></pre></td></tr></table></figure>

<p>2.查询所有课程成绩小于60分的学生的信息（学号，姓名，成绩）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select stu.Sid,stu.Sname,sc.Score</span><br><span class="line">from student stu left join score sc</span><br><span class="line">on stu.Sid &#x3D; sc.Sid</span><br><span class="line">where Score &lt; 60</span><br></pre></td></tr></table></figure>

<p>3.查询所有学生的学号，姓名，选修课，总成绩</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select stu.Sid,stu.Sname,count(sc.Score) as &#39;选课数&#39;,sum(sc.Score)</span><br><span class="line">from student stu left join score sc</span><br><span class="line">on stu.Sid &#x3D; sc.Sid</span><br><span class="line">GROUP BY stu.Sid,stu.Sname</span><br></pre></td></tr></table></figure>

<h1 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h1><h2 id="表student-id-name-department-age-分别代表学员的学号，姓名，所属单位，年龄"><a href="#表student-id-name-department-age-分别代表学员的学号，姓名，所属单位，年龄" class="headerlink" title="表student(id,name,department,age)分别代表学员的学号，姓名，所属单位，年龄"></a>表student(id,name,department,age)分别代表学员的学号，姓名，所属单位，年龄</h2><h2 id="表course-id-name-分别代表课程编号课程名称"><a href="#表course-id-name-分别代表课程编号课程名称" class="headerlink" title="表course(id,name)分别代表课程编号课程名称"></a>表course(id,name)分别代表课程编号课程名称</h2><h2 id="表score-sid-cid-score-分别代表学号，所选的课程编号，学习成绩"><a href="#表score-sid-cid-score-分别代表学号，所选的课程编号，学习成绩" class="headerlink" title="表score(sid,cid,score) 分别代表学号，所选的课程编号，学习成绩"></a>表score(sid,cid,score) 分别代表学号，所选的课程编号，学习成绩</h2><ol>
<li><p>使用标准SQL嵌套语句查询没有选修课程编号为”C5“的课程的学员姓名和所属单位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT distinct student.name , student.department</span><br><span class="line">FROM student left join score</span><br><span class="line">on student.id &#x3D; score.sid</span><br><span class="line">where cid not in (select id from course where name &#x3D; &#39;C5&#39;)</span><br></pre></td></tr></table></figure></li>
<li><p>查询选修了课程的学员人数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select count(1)</span><br><span class="line">from student</span><br><span class="line">where id in(SELECT distinct score.sid FROM score )</span><br></pre></td></tr></table></figure></li>
<li><p>每个课选修人数</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT course.name ,count(score.cid)</span><br><span class="line">FROM score left join course</span><br><span class="line">on score.cid &#x3D; course.id</span><br><span class="line">GROUP BY score.cid</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>查询选修课程超过5门的学员学号和所属单位</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select id,department</span><br><span class="line">from student</span><br><span class="line">where id &#x3D; (</span><br><span class="line">    		select sid</span><br><span class="line">			from score</span><br><span class="line">			GROUP BY sid</span><br><span class="line">			HAVING count(score.cid)&gt;&#x3D;5</span><br><span class="line">           )</span><br></pre></td></tr></table></figure>

<h1 id="练习三"><a href="#练习三" class="headerlink" title="练习三"></a>练习三</h1><p>用户表 sys_user(表字段：userId-用户id，userName-用户名)，</p>
<p>角色表sys_role(表字段：roleId-角色id，roleName-角色名称)，</p>
<p>用户角色表sys_userRole（表字段：userId-用户id，roleId-角色id），</p>
<p>目前sys_user表和sys_role表中都有数据，sys_userRole表是空的。写个sql：把现有的sys_user和sys_role中的数据，插入到sys_userRole中，实现每个用户都有每个角色。（比如一个用户id=1，角色表sys_role中有10个角色，那么对应到sys_userRole表中就应该有10条记录，表示用户id=1，有10个角色）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">into</span> sys_userrole (user_id,role_id) <span class="keyword">SELECT</span> sys_user.user_id,sys_role.role_id <span class="keyword">FROM</span> sys_user,sys_role</span><br></pre></td></tr></table></figure>

<h1 id="练习四"><a href="#练习四" class="headerlink" title="练习四"></a>练习四</h1><p>mysql中存在订单表order，字段如下：</p>
<p> <img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BB%83%E4%B9%A0.png">                              </p>
<p>写个sql，求取每个用户中，订单总金额最大的那笔订单（要求查询结果里面包含订单表order里面的所有字段：如图上面的六个字段）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.<span class="operator">*</span> <span class="keyword">from</span> sys_order2 a <span class="keyword">inner</span> <span class="keyword">join</span> (<span class="keyword">select</span> user_id,<span class="built_in">max</span>(order_pay) <span class="keyword">as</span> ma <span class="keyword">from</span> sys_order2 <span class="keyword">GROUP</span> <span class="keyword">BY</span> user_id) b</span><br><span class="line"></span><br><span class="line"><span class="keyword">on</span> a.user_id <span class="operator">=</span> b.user_id <span class="keyword">and</span> a.order_pay <span class="operator">=</span> b.ma</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/17/MySQL-MySQL%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/17/MySQL-MySQL%E4%BC%98%E5%8C%96/" itemprop="url">MySQL-MySQL优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-17T23:33:32+08:00">
                2021-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL-MySQL%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL - MySQL知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>摘抄<a target="_blank" rel="noopener" href="https://www.cnblogs.com/huchong/p/10219318.html">原文地址</a><br>摘抄<a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/database/MySQL%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%AE">JavaGuide</a></p>
<h1 id="是否进行过数据库调优？一般如何性能调优"><a href="#是否进行过数据库调优？一般如何性能调优" class="headerlink" title="是否进行过数据库调优？一般如何性能调优"></a>是否进行过数据库调优？一般如何性能调优</h1><p>两个方面考虑：一是<strong>应用层架构</strong>；二是<strong>数据库架构</strong>；</p>
<ol>
<li><strong>应用层架构优化</strong>。核心是减少对数据库的调用次数，本质上是从业务应用层来审视流程是否合理，常用的方案有：</li>
</ol>
<ul>
<li>引入缓存，虚拟一层中间层，减少对数据库的读写；</li>
<li>将多次单个调用改为批量调用，比如说循环十次主键 select * FROM t where id = ‘xx’改为使用 IN 一性次读取 select * FROM t where id IN (‘xx’,‘xx’,…)；</li>
<li>使用搜索引擎。</li>
</ul>
<ol start="2">
<li><strong>数据库架构优化</strong>。核心是优化各种配置，提升数据库的性能，可分为：</li>
</ol>
<ul>
<li>优化 SQL 及索引，以达到减少数据访问、返回更少数据、减少交互次数等目标。常用的手段包括：创建并正确地使用索引（比如说减少回表查询）、优化执行计划、数据分页处理、只取需要的字段、慢查询优化、使用搜索引擎等；</li>
<li>优化数据库表结构。常用的的手段包括：使用占用空间最小的数据类型、使用简单的数据类型、尽可能地使用 NOT NULL 定义字段、尽量少使用 text 字段、分库分表等；</li>
<li>优化系统配置。包括操作系统的配置优化和数据库的配置优化。<ul>
<li>操作系统优化。数据库是基于操作系统（多为 Linux 系统）的，所以对于合理使用操作系统也会影响到数据库的性能。比如将数据库服务器应和业务服务器隔离、或者设置 net.ipv4.tcp_max_syn_backlog = 65535 以增加 tcp 支持的队列数等等；</li>
<li>数据库配置文件优化，以 MySQL 配置为例，可以修改 innodb_buffer_pool_size（设置数据和索引缓存的缓冲池）、max_connections 等参数。</li>
<li>优化硬件配置。比如说使用更好的服务器、更快的硬盘、更大的内存等等。</li>
</ul>
</li>
</ul>
<h2 id="切忌上来就说用-explain-去解析执行计划"><a href="#切忌上来就说用-explain-去解析执行计划" class="headerlink" title="切忌上来就说用 explain 去解析执行计划"></a>切忌上来就说用 explain 去解析执行计划</h2><p>应该把调优视为系统化的方案和工程</p>
<h3 id="使用-explain-查询执行计划需描述其步骤"><a href="#使用-explain-查询执行计划需描述其步骤" class="headerlink" title="使用 explain 查询执行计划需描述其步骤:"></a>使用 explain 查询执行计划需描述其步骤:</h3><p>（1）查看 slowlog，分析 slowlog，分析出查询慢的语句；</p>
<p>（2）按照一定优先级（比如说调用频率），进行一个一个的排查所有慢语句。</p>
<p>（3）分析 top sql，进行 explain 调试，查看语句执行时间。</p>
<p>（4）调整索引或语句本身。</p>
<h1 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h1><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<h2 id="1-限定数据的范围"><a href="#1-限定数据的范围" class="headerlink" title="1. 限定数据的范围"></a>1. 限定数据的范围</h2><p>务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</p>
<h2 id="2-读-写分离"><a href="#2-读-写分离" class="headerlink" title="2. 读/写分离"></a>2. 读/写分离</h2><p>经典的数据库拆分方案，主库负责写，从库负责读；</p>
<h2 id="3-垂直分区"><a href="#3-垂直分区" class="headerlink" title="3. 垂直分区"></a>3. 垂直分区</h2><p> <strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>
<p> <strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。 <img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9E%82%E7%9B%B4%E5%88%86%E5%8C%BA.png" alt="数据库垂直分区"></p>
<ul>
<li><strong>垂直拆分的优点：</strong> 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</li>
<li><strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</li>
</ul>
<h2 id="4-水平分区"><a href="#4-水平分区" class="headerlink" title="4. 水平分区"></a>4. 水平分区</h2><p><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong> </p>
<p> 水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B0%B4%E5%B9%B3%E6%8B%86%E5%88%86.png" alt="数据库水平拆分"></p>
<p>水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。</p>
<p>水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong>  ，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度</strong> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</p>
<p><strong>下面补充一下数据库分片的两种常见方案：</strong></p>
<ul>
<li><strong>客户端代理：</strong>  <strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</li>
<li><strong>中间件代理：</strong> <strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</li>
</ul>
<h1 id="数据库规范"><a href="#数据库规范" class="headerlink" title="数据库规范"></a>数据库规范</h1><h2 id="数据库命令规范"><a href="#数据库命令规范" class="headerlink" title="数据库命令规范"></a>数据库命令规范</h2><ul>
<li>所有数据库对象名称必须使用小写字母并用下划线分割</li>
<li>所有数据库对象名称禁止使用 MySQL 保留关键字</li>
<li>数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符</li>
<li>临时库表必须以 tmp_为前缀并以日期为后缀，备份表必须以 bak_为前缀并以日期 (时间戳) 为后缀</li>
<li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</li>
</ul>
<h2 id="数据库基本设计规范"><a href="#数据库基本设计规范" class="headerlink" title="数据库基本设计规范"></a>数据库基本设计规范</h2><h3 id="所有表必须使用-Innodb-存储引擎"><a href="#所有表必须使用-Innodb-存储引擎" class="headerlink" title="所有表必须使用 Innodb 存储引擎"></a>所有表必须使用 Innodb 存储引擎</h3><p>没有特殊要求（即 Innodb 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 Innodb 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 Innodb）。</p>
<p>Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。</p>
<h3 id="数据库和表的字符集统一使用-UTF8"><a href="#数据库和表的字符集统一使用-UTF8" class="headerlink" title="数据库和表的字符集统一使用 UTF8"></a>数据库和表的字符集统一使用 UTF8</h3><p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。</p>
<h3 id="所有表和字段都需要添加注释"><a href="#所有表和字段都需要添加注释" class="headerlink" title="所有表和字段都需要添加注释"></a>所有表和字段都需要添加注释</h3><p>使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护</p>
<h3 id="尽量控制单表数据量的大小-建议控制在-500-万以内。"><a href="#尽量控制单表数据量的大小-建议控制在-500-万以内。" class="headerlink" title="尽量控制单表数据量的大小,建议控制在 500 万以内。"></a>尽量控制单表数据量的大小,建议控制在 500 万以内。</h3><p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p>
<p>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p>
<h3 id="谨慎使用-MySQL-分区表"><a href="#谨慎使用-MySQL-分区表" class="headerlink" title="谨慎使用 MySQL 分区表"></a>谨慎使用 MySQL 分区表</h3><p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；</p>
<p>谨慎选择分区键，跨分区查询效率可能更低；</p>
<p>建议采用物理分表的方式管理大数据。</p>
<h3 id="尽量做到冷热数据分离-减小表的宽度"><a href="#尽量做到冷热数据分离-减小表的宽度" class="headerlink" title="尽量做到冷热数据分离,减小表的宽度"></a>尽量做到冷热数据分离,减小表的宽度</h3><blockquote>
<p>MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。</p>
</blockquote>
<p>减少磁盘 IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的 IO）；</p>
<p>更有效的利用缓存，避免读入无用的冷数据；</p>
<p>经常一起使用的列放到一个表中（避免更多的关联操作）。</p>
<h3 id="禁止在表中建立预留字段"><a href="#禁止在表中建立预留字段" class="headerlink" title="禁止在表中建立预留字段"></a>禁止在表中建立预留字段</h3><p>预留字段的命名很难做到见名识义。</p>
<p>预留字段无法确认存储的数据类型，所以无法选择合适的类型。</p>
<p>对预留字段类型的修改，会对表进行锁定。</p>
<h3 id="禁止在数据库中存储图片-文件等大的二进制数据"><a href="#禁止在数据库中存储图片-文件等大的二进制数据" class="headerlink" title="禁止在数据库中存储图片,文件等大的二进制数据"></a>禁止在数据库中存储图片,文件等大的二进制数据</h3><p>通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机 IO 操作，文件很大时，IO 操作很耗时。</p>
<p>通常存储于文件服务器，数据库只存储文件地址信息</p>
<h2 id="数据库字段设计规范"><a href="#数据库字段设计规范" class="headerlink" title="数据库字段设计规范"></a>数据库字段设计规范</h2><h3 id="优先选择符合存储需要的最小的数据类型"><a href="#优先选择符合存储需要的最小的数据类型" class="headerlink" title="优先选择符合存储需要的最小的数据类型"></a>优先选择符合存储需要的最小的数据类型</h3><p><strong>原因：</strong></p>
<p>列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差。</p>
<p><strong>方法：</strong></p>
<p><strong>a.将字符串转换成数字类型存储,如:将 IP 地址转换成整形数据</strong></p>
<p>MySQL 提供了两个方法来处理 ip 地址</p>
<p>•inet_aton 把 ip 转为无符号整型 (4-8 位)•inet_ntoa 把整型的 ip 转为地址</p>
<p>插入数据前，先用 inet_aton 把 ip 地址转为整型，可以节省空间，显示数据时，使用 inet_ntoa 把整型的 ip 地址转为地址显示即可。</p>
<p><strong>b.对于非负型的数据 (如自增 ID,整型 IP) 来说,要优先使用无符号整型来存储</strong></p>
<p><strong>原因：</strong></p>
<p>无符号相对于有符号可以多出一倍的存储空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SIGNED INT -2147483648~2147483647</span><br><span class="line">UNSIGNED INT 0~4294967295</span><br></pre></td></tr></table></figure>

<p>VARCHAR(N) 中的 N 代表的是字符数，而不是字节数，使用 UTF8 存储 255 个汉字 Varchar(255)=765 个字节。<strong>过大的长度会消耗更多的内存。</strong></p>
<h3 id="避免使用-TEXT-BLOB-数据类型，最常见的-TEXT-类型可以存储-64k-的数据"><a href="#避免使用-TEXT-BLOB-数据类型，最常见的-TEXT-类型可以存储-64k-的数据" class="headerlink" title="避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据"></a>避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据</h3><p><strong>a. 建议把 BLOB 或是 TEXT 列分离到单独的扩展表中</strong></p>
<p>MySQL 内存临时表不支持 TEXT、BLOB  这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，MySQL  还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。</p>
<p>如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 select * 而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。</p>
<p><strong>2、TEXT 或 BLOB 类型只能使用前缀索引</strong></p>
<p>因为MySQL[1] 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的</p>
<h3 id="避免使用-ENUM-类型"><a href="#避免使用-ENUM-类型" class="headerlink" title="避免使用 ENUM 类型"></a>避免使用 ENUM 类型</h3><p>修改 ENUM 值需要使用 ALTER 语句</p>
<p>ENUM 类型的 ORDER BY 操作效率低，需要额外操作</p>
<p>禁止使用数值作为 ENUM 的枚举值</p>
<h3 id="尽可能把所有列定义为-NOT-NULL"><a href="#尽可能把所有列定义为-NOT-NULL" class="headerlink" title="尽可能把所有列定义为 NOT NULL"></a>尽可能把所有列定义为 NOT NULL</h3><p><strong>原因：</strong></p>
<p>索引 NULL 列需要额外的空间来保存，所以要占用更多的空间</p>
<p>进行比较和计算时要对 NULL 值做特别的处理</p>
<h3 id="使用-TIMESTAMP-4-个字节-或-DATETIME-类型-8-个字节-存储时间"><a href="#使用-TIMESTAMP-4-个字节-或-DATETIME-类型-8-个字节-存储时间" class="headerlink" title="使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间"></a>使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间</h3><p>TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07</p>
<p>TIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高</p>
<p>超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储</p>
<p><strong>经常会有人用字符串存储日期型的数据（不正确的做法）</strong></p>
<p>•缺点 1：无法用日期函数进行计算和比较•缺点 2：用字符串存储日期要占用更多的空间</p>
<h3 id="同财务相关的金额类数据必须使用-decimal-类型"><a href="#同财务相关的金额类数据必须使用-decimal-类型" class="headerlink" title="同财务相关的金额类数据必须使用 decimal 类型"></a>同财务相关的金额类数据必须使用 decimal 类型</h3><p>非精准浮点：float,double</p>
<p>精准浮点：decimal</p>
<p>Decimal 类型为精准浮点数，在计算时不会丢失精度</p>
<p>占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节</p>
<p>可用于存储比 bigint 更大的整型数据</p>
<h2 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h2><h3 id="限制每张表上的索引数量-建议单张表索引不超过-5-个"><a href="#限制每张表上的索引数量-建议单张表索引不超过-5-个" class="headerlink" title="限制每张表上的索引数量,建议单张表索引不超过 5 个"></a>限制每张表上的索引数量,建议单张表索引不超过 5 个</h3><p>索引并不是越多越好！索引可以提高效率同样可以降低效率。</p>
<p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p>
<p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p>
<h3 id="禁止给表中的每一列都建立单独的索引"><a href="#禁止给表中的每一列都建立单独的索引" class="headerlink" title="禁止给表中的每一列都建立单独的索引"></a>禁止给表中的每一列都建立单独的索引</h3><p>5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。</p>
<h3 id="每个-Innodb-表必须有个主键"><a href="#每个-Innodb-表必须有个主键" class="headerlink" title="每个 Innodb 表必须有个主键"></a>每个 Innodb 表必须有个主键</h3><p>Innodb 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p>
<p>Innodb 是按照主键索引的顺序来组织表的</p>
<p>•不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）</p>
<p>•不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）</p>
<p>•主键建议使用自增 ID 值</p>
<h3 id="常见索引列建议"><a href="#常见索引列建议" class="headerlink" title="常见索引列建议"></a>常见索引列建议</h3><p>出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</p>
<p>包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</p>
<p>并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好</p>
<p>多表 join 的关联列</p>
<h3 id="如何选择索引列的顺序"><a href="#如何选择索引列的顺序" class="headerlink" title="如何选择索引列的顺序"></a>如何选择索引列的顺序</h3><p>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p>
<p>•区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）</p>
<p>•尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）</p>
<p>•使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</p>
<h3 id="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"><a href="#避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）" class="headerlink" title="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"></a>避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）</h3><p>•重复索引示例：primary key(id)、index(id)、unique index(id)<br>•冗余索引示例：index(a,b,c)、index(a,b)、index(a)</p>
<h3 id="对于频繁的查询优先考虑使用覆盖索引"><a href="#对于频繁的查询优先考虑使用覆盖索引" class="headerlink" title="对于频繁的查询优先考虑使用覆盖索引"></a>对于频繁的查询优先考虑使用覆盖索引</h3><p>覆盖索引：就是包含了所有查询字段 (where,select,ordery by,group by 包含的字段) 的索引</p>
<p>覆盖索引的好处：</p>
<p>•避免 Innodb 表进行索引的二次查询: Innodb 是以聚集索引的顺序来存储的，对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</p>
<p>•可以把随机 IO 变成顺序 IO 加快查询效率: 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</p>
<h3 id="索引-SET-规范"><a href="#索引-SET-规范" class="headerlink" title="索引 SET 规范"></a>索引 SET 规范</h3><p>尽量避免使用外键约束</p>
<p>•不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引</p>
<p>•外键可用于保证数据的参照完整性，但建议在业务端实现</p>
<p>•外键会影响父表和子表的写操作从而降低性能</p>
<h2 id="数据库-SQL-开发规范"><a href="#数据库-SQL-开发规范" class="headerlink" title="数据库 SQL 开发规范"></a>数据库 SQL 开发规范</h2><h3 id="建议使用预编译语句进行数据库操作"><a href="#建议使用预编译语句进行数据库操作" class="headerlink" title="建议使用预编译语句进行数据库操作"></a>建议使用预编译语句进行数据库操作</h3><p>预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。</p>
<p>只传参数，比传递 SQL 语句更高效。</p>
<p>相同语句可以一次解析，多次使用，提高处理效率。</p>
<h3 id="避免数据类型的隐式转换"><a href="#避免数据类型的隐式转换" class="headerlink" title="避免数据类型的隐式转换"></a>避免数据类型的隐式转换</h3><p>隐式转换会导致索引失效如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,phone from customer where id &#x3D; &#39;111&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="充分利用表上已经存在的索引"><a href="#充分利用表上已经存在的索引" class="headerlink" title="充分利用表上已经存在的索引"></a>充分利用表上已经存在的索引</h3><p>避免使用双%号的查询条件。如：a like ‘%123%’，（如果无前置%,只有后置%，是可以用到列上的索引的）</p>
<p>一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。</p>
<p>在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。</p>
<h3 id="数据库设计时，应该要对以后扩展进行考虑"><a href="#数据库设计时，应该要对以后扩展进行考虑" class="headerlink" title="数据库设计时，应该要对以后扩展进行考虑"></a>数据库设计时，应该要对以后扩展进行考虑</h3><h3 id="程序连接不同的数据库使用不同的账号，进制跨库查询"><a href="#程序连接不同的数据库使用不同的账号，进制跨库查询" class="headerlink" title="程序连接不同的数据库使用不同的账号，进制跨库查询"></a>程序连接不同的数据库使用不同的账号，进制跨库查询</h3><ul>
<li>为数据库迁移和分库分表留出余地</li>
<li>降低业务耦合度</li>
<li>避免权限过大而产生的安全风险</li>
</ul>
<h3 id="禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询"><a href="#禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询" class="headerlink" title="禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询"></a>禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询</h3><p><strong>原因：</strong></p>
<p>•消耗更多的 CPU 和 IO 以网络带宽资源</p>
<p>•无法使用覆盖索引</p>
<p>•可减少表结构变更带来的影响</p>
<h3 id="禁止使用不含字段列表的-INSERT-语句"><a href="#禁止使用不含字段列表的-INSERT-语句" class="headerlink" title="禁止使用不含字段列表的 INSERT 语句"></a>禁止使用不含字段列表的 INSERT 语句</h3><p>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into values (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);</span><br></pre></td></tr></table></figure>

<p>应使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t(c1,c2,c3) values (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="避免使用子查询，可以把子查询优化为-join-操作"><a href="#避免使用子查询，可以把子查询优化为-join-操作" class="headerlink" title="避免使用子查询，可以把子查询优化为 join 操作"></a>避免使用子查询，可以把子查询优化为 join 操作</h3><p>通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。</p>
<p><strong>子查询性能差的原因：</strong></p>
<p>子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p>
<p>由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</p>
<h3 id="避免使用-JOIN-关联太多的表"><a href="#避免使用-JOIN-关联太多的表" class="headerlink" title="避免使用 JOIN 关联太多的表"></a>避免使用 JOIN 关联太多的表</h3><p>对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。</p>
<p>在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。</p>
<p>如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。</p>
<p>同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL 最多允许关联 61 个表，建议不超过 5 个。</p>
<h3 id="减少同数据库的交互次数"><a href="#减少同数据库的交互次数" class="headerlink" title="减少同数据库的交互次数"></a>减少同数据库的交互次数</h3><p>数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。</p>
<h3 id="对应同一列进行-or-判断时，使用-in-代替-or"><a href="#对应同一列进行-or-判断时，使用-in-代替-or" class="headerlink" title="对应同一列进行 or 判断时，使用 in 代替 or"></a>对应同一列进行 or 判断时，使用 in 代替 or</h3><p>in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</p>
<h3 id="禁止使用-order-by-rand-进行随机排序"><a href="#禁止使用-order-by-rand-进行随机排序" class="headerlink" title="禁止使用 order by rand() 进行随机排序"></a>禁止使用 order by rand() 进行随机排序</h3><p>order by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。</p>
<p>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</p>
<h3 id="WHERE-从句中禁止对列进行函数转换和计算"><a href="#WHERE-从句中禁止对列进行函数转换和计算" class="headerlink" title="WHERE 从句中禁止对列进行函数转换和计算"></a>WHERE 从句中禁止对列进行函数转换和计算</h3><p>对列进行函数转换或计算时会导致无法使用索引</p>
<p><strong>不推荐：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where date(create_time)&#x3D;&#39;20190101&#39;</span><br></pre></td></tr></table></figure>

<p><strong>推荐：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where create_time &gt;&#x3D; &#39;20190101&#39; and create_time &lt; &#39;20190102&#39;</span><br></pre></td></tr></table></figure>

<h3 id="在明显不会有重复值时使用-UNION-ALL-而不是-UNION"><a href="#在明显不会有重复值时使用-UNION-ALL-而不是-UNION" class="headerlink" title="在明显不会有重复值时使用 UNION ALL 而不是 UNION"></a>在明显不会有重复值时使用 UNION ALL 而不是 UNION</h3><p>•UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作</p>
<p>•UNION ALL 不会再对结果集进行去重操作</p>
<h3 id="拆分复杂的大-SQL-为多个小-SQL"><a href="#拆分复杂的大-SQL-为多个小-SQL" class="headerlink" title="拆分复杂的大 SQL 为多个小 SQL"></a>拆分复杂的大 SQL 为多个小 SQL</h3><p>•大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL</p>
<p>•MySQL 中，一个 SQL 只能使用一个 CPU 进行计算</p>
<p>•SQL 拆分后可以通过并行执行来提高处理效率</p>
<h2 id="数据库操作行为规范"><a href="#数据库操作行为规范" class="headerlink" title="数据库操作行为规范"></a>数据库操作行为规范</h2><h3 id="超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作"><a href="#超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作" class="headerlink" title="超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作"></a>超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作</h3><p><strong>大批量操作可能会造成严重的主从延迟</strong></p>
<p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间， 而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p>
<p><strong>binlog 日志为 row 格式时会产生大量的日志</strong></p>
<p>大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p>
<p><strong>避免产生大事务操作</strong></p>
<p>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。</p>
<p>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</p>
<h3 id="对于大表使用-pt-online-schema-change-修改表结构"><a href="#对于大表使用-pt-online-schema-change-修改表结构" class="headerlink" title="对于大表使用 pt-online-schema-change 修改表结构"></a>对于大表使用 pt-online-schema-change 修改表结构</h3><p>•避免大表修改产生的主从延迟•避免在对表字段进行修改时进行锁表</p>
<p>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。</p>
<p>pt-online-schema-change  它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。</p>
<h3 id="禁止为程序使用的账号赋予-super-权限"><a href="#禁止为程序使用的账号赋予-super-权限" class="headerlink" title="禁止为程序使用的账号赋予 super 权限"></a>禁止为程序使用的账号赋予 super 权限</h3><p>•当达到最大连接数限制时，还运行 1 个有 super 权限的用户连接<br>•super 权限只能留给 DBA 处理问题的账号使用</p>
<h3 id="对于程序连接数据库账号-遵循权限最小原则"><a href="#对于程序连接数据库账号-遵循权限最小原则" class="headerlink" title="对于程序连接数据库账号,遵循权限最小原则"></a>对于程序连接数据库账号,遵循权限最小原则</h3><p>•程序使用数据库账号只能在一个 DB 下使用，不准跨库<br>•程序使用的账号原则上不准有 drop 权限**</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/17/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85-rabbitmq%E5%AE%89%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/17/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85-rabbitmq%E5%AE%89%E8%A3%85/" itemprop="url">软件安装-rabbitmq安装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-17T20:13:21+08:00">
                2021-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85-rabbitmq%E5%AE%89%E8%A3%85/" itemprop="url" rel="index">
                    <span itemprop="name">软件安装 - rabbitmq安装</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="需要软件"><a href="#需要软件" class="headerlink" title="需要软件"></a>需要软件</h1><p>erlang， rabbitmq</p>
<h2 id="注意版本"><a href="#注意版本" class="headerlink" title="注意版本"></a>注意版本</h2><p>rabbitmq 和 erlang 是有版本依赖的，不能两个版本相差太多</p>
<p> <a target="_blank" rel="noopener" href="https://www.rabbitmq.com/which-erlang.html">rabbitmq和erlang版本依赖说明</a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="上传到-Linux"><a href="#上传到-Linux" class="headerlink" title="上传到 Linux"></a>上传到 Linux</h2><p>在 /usr/local 下创建一个 rabbitmq 文件夹</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost local]# mkdir rabbitmq</span><br></pre></td></tr></table></figure>

<h2 id="安装Erlang"><a href="#安装Erlang" class="headerlink" title="安装Erlang"></a>安装Erlang</h2><ol>
<li><p><strong>环境</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost rabbitmq]# yum -y install ncurses-devel</span><br><span class="line">[root@localhost rabbitmq]# yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel</span><br></pre></td></tr></table></figure></li>
<li><p><strong>解压</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost rabbitmq]# tar -xvf otp_src_21.1.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p><strong>安装</strong></p>
<p>进入解压后的 otp_src_21.1 目录，执行以下命令生成 erlang 目录</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost rabbitmq]# cd otp_src_21.1</span><br><span class="line">[root@localhost otp_src_21.1]# ./configure --prefix=/usr/local/rabbitmq/erlang --without-javac</span><br></pre></td></tr></table></figure></li>
<li><p><strong>编译、安装</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost otp_src_21.1]# make</span><br><span class="line">[root@localhost otp_src_21.1]# make install</span><br></pre></td></tr></table></figure></li>
<li><p><strong>去usr/local/rabbitmq测试</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost rabbitmq]# cd erlang/</span><br><span class="line">[root@localhost erlang]# ./bin/erl</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h2><ol>
<li><strong>环境</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost rabbitmq]# yum install python -y</span><br><span class="line">[root@localhost rabbitmq]# yum install xmlto -y</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>解压（先得到tar格式文件，接着再解压）</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost rabbitmq]# xz -d rabbitmq-server-generic-unix-3.7.17.tar.xz </span><br><span class="line">[root@localhost rabbitmq]# tar -xvf rabbitmq-server-generic-unix-3.7.17.tar</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>改名（原名过长就改为rabbitmq）</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost rabbitmq]# mv rabbitmq_server-3.7.17/ /usr/local/rabbitmq/</span><br></pre></td></tr></table></figure>

<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost rabbitmq]# vi /etc/profile</span><br></pre></td></tr></table></figure>

<p>在 profile 文件末尾加上下面这句话（同时包含了erlang的环境变量配置），要注意路径要正确，最后wq保存退出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/rabbitmq/erlang/bin:/usr/local/rabbitmq/rabbitmq/sbin</span><br></pre></td></tr></table></figure>

<p>使配置立即生效</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost rabbitmq]# source /etc/profile</span><br></pre></td></tr></table></figure>

<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>由于上面已经配置环境变量，所以可不必进入到 rabbitmq 的 sbin 命令目录，直接 rabbitmq-server 即可启动。<br>当然也可以进入到 sbin 目录，使用 ./rabbitmq-server 进行启动（目前不是后台启动，可以清楚看到启动情况）</p>
<h1 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]# .&#x2F;rabbitmqctl stop</span><br></pre></td></tr></table></figure>

<h1 id="RabbitMQ账号设置"><a href="#RabbitMQ账号设置" class="headerlink" title="RabbitMQ账号设置"></a>RabbitMQ账号设置</h1><ol>
<li><strong>启动插件功能</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]# ./rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>创建一个账号</strong></li>
</ol>
<p>（1）创建之前，可以先查看一下当前有哪些用户和权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]# ./rabbitmqctl list_users</span><br><span class="line">[root@localhost sbin]# ./rabbitmqctl list_user_permissions guest</span><br></pre></td></tr></table></figure>

<p>（2）添加用户（我这里账号就设为 admin，密码也是 admin，随意）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]# ./rabbitmqctl add_user admin admin</span><br><span class="line">[root@localhost sbin]# ./rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure>

<p>（3）设置其权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]# ./rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/17/MySQL-MySQL%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/17/MySQL-MySQL%E5%AD%A6%E4%B9%A0/" itemprop="url">MySQL-MySQL学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-17T17:50:40+08:00">
                2021-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL-MySQL%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL - MySQL知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h1><h2 id="一条SQL语句在MySQL中如何执行的"><a href="#一条SQL语句在MySQL中如何执行的" class="headerlink" title="一条SQL语句在MySQL中如何执行的"></a>一条SQL语句在MySQL中如何执行的</h2><p>SQL 等执行过程分为两类</p>
<p>对于查询等过程如下：权限校验—》查询缓存—》分析器—》优化器—》权限校验—》执行器—》引擎</p>
<p>对于更新等语句执行流程如下：分析器—-》权限校验—-》执行器—》引擎—redo log prepare—》binlog—》redo log commit</p>
<h2 id="SELECT-和-SELECT-全部字段两种写法有何优缺点"><a href="#SELECT-和-SELECT-全部字段两种写法有何优缺点" class="headerlink" title="SELECT * 和 SELECT 全部字段两种写法有何优缺点?"></a>SELECT * 和 SELECT 全部字段两种写法有何优缺点?</h2><ol>
<li>前者要解析数据字典，后者不需要；</li>
<li>结果输出顺序，前者与建表列顺序相同，后者按指定字段顺序；</li>
<li>表字段改名，前者不需要修改，后者需要改；</li>
<li>后者可以建立索引进行优化，前者无法优化；</li>
<li>后者的可读性比前者要高。</li>
</ol>
<h2 id="简单说一说drop、delete与truncate的区别？"><a href="#简单说一说drop、delete与truncate的区别？" class="headerlink" title="简单说一说drop、delete与truncate的区别？"></a>简单说一说drop、delete与truncate的区别？</h2><p>delete和truncate只删除表的数据不删除表的结构</p>
<p>速度：drop&gt; truncate &gt;delete</p>
<p>delete语句是dml，这个操作会放到rollback segement中，事务提交之后才生效；如果有相应的trigger，执行的时候将被触发。 </p>
<p>truncate,drop是ddl，操作立即生效，原数据不放到rollback segment中，不能回滚。操作不触发trigger</p>
<h2 id="LiKE声明中的％和-是什么意思？"><a href="#LiKE声明中的％和-是什么意思？" class="headerlink" title="LiKE声明中的％和_是什么意思？"></a>LiKE声明中的％和_是什么意思？</h2><p>％对应于0个或更多字符，_只是LIKE语句中的一个字符。</p>
<h2 id="HAVNG-子句-和-WHERE-的异同点"><a href="#HAVNG-子句-和-WHERE-的异同点" class="headerlink" title="HAVNG 子句 和 WHERE 的异同点?"></a>HAVNG 子句 和 WHERE 的异同点?</h2><ol>
<li>语法上：where 用表中列名，having 用 select 结果别名；</li>
<li>影响结果范围：where 从表读出数据的行数，having 返回客户端的行数</li>
<li>索引：where 可以使用索引，having 不能使用索引，只能在临时结果集操作</li>
<li>where 后面不能使用聚集函数，having 是专门使用聚集函数的。</li>
</ol>
<h2 id="一个-SQL-执行的很慢的原因"><a href="#一个-SQL-执行的很慢的原因" class="headerlink" title="一个 SQL 执行的很慢的原因"></a>一个 SQL 执行的很慢的原因</h2><p>1、大多数情况下很正常，偶尔很慢，则有如下原因</p>
<p>(1)、数据库在刷新脏页，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">redo log 写满了需要同步到磁盘。</span><br><span class="line">内存不够用了</span><br></pre></td></tr></table></figure>

<p>(2)、执行的时候，遇到锁，如表锁、行锁。</p>
<p>2、这条 SQL 语句一直执行的很慢，则有如下原因。</p>
<p>(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。</p>
<p>(2)、数据库选错了索引。系统是通过索引的区分度来判断的,区分度称之为基数。系统采样的方式，来预测索引的基数的，由于统计的失误会预测错索引的基数，导致系统没有走索引，而是走了全表扫描</p>
<h2 id="什么是内联接、左外联接、右外联接？"><a href="#什么是内联接、左外联接、右外联接？" class="headerlink" title="什么是内联接、左外联接、右外联接？"></a>什么是内联接、左外联接、右外联接？</h2><p>内联接（Inner Join）：匹配2张表中相关联的记录。<br>左外联接（Left Outer Join）：除了匹配2张表中相关联的记录外，还会匹配左表中剩余的记录，右表<br>中未匹配到的字段用NULL表示。<br>右外联接（Right Outer Join）：除了匹配2张表中相关联的记录外，还会匹配右表中剩余的记录，左表<br>中未匹配到的字段用NULL表示。</p>
<h2 id="什么是通用-SQL-函数？"><a href="#什么是通用-SQL-函数？" class="headerlink" title="什么是通用 SQL 函数？"></a>什么是通用 SQL 函数？</h2><p>1、CONCAT(A, B) – 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个<br>字段。<br>2、FORMAT(X, D)- 格式化数字 X 到 D 有效数字。<br>3、CURRDATE(), CURRTIME()- 返回当前日期或时间。<br>4、NOW（） – 将当前日期和时间作为一个值返回。<br>5、MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） – 从日期值中提取给定数据。<br>6、HOUR（），MINUTE（），SECOND（） – 从时间值中提取给定数据。<br>7、DATEDIFF（A，B） – 确定两个日期之间的差异，通常用于计算年龄<br>8、SUBTIMES（A，B） – 确定两次之间的差异。<br>9、FROMDAYS（INT） – 将整数天数转换为日期值</p>
<h2 id="SQL-注入漏洞产生的原因？如何防止？"><a href="#SQL-注入漏洞产生的原因？如何防止？" class="headerlink" title="SQL 注入漏洞产生的原因？如何防止？"></a>SQL 注入漏洞产生的原因？如何防止？</h2><p>SQL 注入产生的原因：程序开发过程中不注意规范书写 sql 语句和对特殊字符进行过滤，导致客户端可<br>以通过全局变量 POST 和 GET 提交一些 sql 语句正常执行。<br>防止 SQL 注入的方式：<br>开启配置文件中的 magic_quotes_gpc 和 magic_quotes_runtime 设置 执行 sql 语句时使用<br>addslashes 进行 sql 语句转换<br>Sql 语句书写尽量不要省略双引号和单引号。<br>过滤掉 sql 语句中的一些关键词：update、insert、delete、select、 * 。<br>提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。</p>
<h2 id="MySQL当记录不存在时insert-当记录存在时update，语句怎么写？"><a href="#MySQL当记录不存在时insert-当记录存在时update，语句怎么写？" class="headerlink" title="MySQL当记录不存在时insert,当记录存在时update，语句怎么写？"></a>MySQL当记录不存在时insert,当记录存在时update，语句怎么写？</h2><p>INSERT INTO table (a,b,c) VALUES (1,2,3) ON DUPLICATE KEY UPDATE c=c+1;</p>
<h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><h2 id="varchar与char的区别以及varchar-50-中的50代表的含义"><a href="#varchar与char的区别以及varchar-50-中的50代表的含义" class="headerlink" title="varchar与char的区别以及varchar(50)中的50代表的含义"></a>varchar与char的区别以及varchar(50)中的50代表的含义</h2><p>（1） varchar与char的区别</p>
<p> 变长和固定长度</p>
<p>（2）varchar(50)中50的涵义</p>
<p> 字符最大长度50，所代表的字节数与字符集有关，比如是utf8占3个字节，那么varchar(50)字段在表中最大取到150个字节。</p>
<p> varchar(50)和(200)存储<code>hello</code>所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。</p>
<p>（3） int（20）中20的涵义</p>
<p> 是指显示字符的长度不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示</p>
<p>（4） varchar(20)和int(20)中的20含义一样吗？</p>
<p>int(M) M表示的不是数据的最大长度，只是数据宽度，并不影响存储多少位长度的数据；</p>
<p>varchar(M) M表示的是varchar类型数据在数据库中存储的最大长度，超过则不存；</p>
<h2 id="FLOAT和DOUBLE的区别是什么？"><a href="#FLOAT和DOUBLE的区别是什么？" class="headerlink" title="FLOAT和DOUBLE的区别是什么？"></a>FLOAT和DOUBLE的区别是什么？</h2><ul>
<li><p>浮点数以8位精度存储在FLOAT中，有四个字节。</p>
</li>
<li><p>浮点数以18位精度存储在DOUBLE中，有八个字节。</p>
</li>
</ul>
<h2 id="BLOB和TEXT有什么区别？"><a href="#BLOB和TEXT有什么区别？" class="headerlink" title="BLOB和TEXT有什么区别？"></a>BLOB和TEXT有什么区别？</h2><p>BLOB是一个二进制对象，可以容纳可变数量的数据。有四种类型：TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB，它们只是在所能容纳价值的最大长度上有所不同。</p>
<p>TEXT是一个不区分大小写的BLOB。有四种类型：TINYTEXT、TEXT、MEDIUMTEXT和</p>
<p>LONGTEXT。它们对应于四种BLOB类型，并具有相同的最大长度和存储要求。</p>
<p>BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。</p>
<h2 id="MySQL-中-Float、Decimal-类型存储金额的区别？"><a href="#MySQL-中-Float、Decimal-类型存储金额的区别？" class="headerlink" title="MySQL 中 Float、Decimal 类型存储金额的区别？"></a>MySQL 中 Float、Decimal 类型存储金额的区别？</h2><p>Float 是非标准数据类型，存储金额时存储的是近似值，存在精度问题；Decimal 是标准数据类型，存储金额时存储的是精确值（以字符串的形式保存数值）。</p>
<h2 id="MySQL-中-TIMESTAMP和DATETIME的区别以及选择"><a href="#MySQL-中-TIMESTAMP和DATETIME的区别以及选择" class="headerlink" title="MySQL 中 TIMESTAMP和DATETIME的区别以及选择"></a>MySQL 中 TIMESTAMP和DATETIME的区别以及选择</h2><table>
<thead>
<tr>
<th>类型</th>
<th>TIMESTAMP</th>
<th>DATETIME</th>
</tr>
</thead>
<tbody><tr>
<td>不同点</td>
<td>存储空间：TIMESTAMP占用4个字节</td>
<td>存储空间：DATETIME占用8个字节</td>
</tr>
<tr>
<td></td>
<td>时区：TIMESTAMP实际记录的是1970-01-01 00:00:01到现在的数数，受时区影响</td>
<td>时区：DATETIME不受时区影响</td>
</tr>
<tr>
<td></td>
<td>存储方式：对于TIMESTAMP，它把客户端插入的时间从当前时区转化为UTC（世界标准时间）进行存储。查询时，将其又转化为客户端当前时区进行返回(中国属于东八区，所以应该是UTC+8）。</td>
<td>存储方式：而对于DATETIME，不做任何改变，基本上是原样输入和输出。</td>
</tr>
</tbody></table>
<h3 id="对于MySQL中timestamp数据类型的特点，为什么选择timestamp类型"><a href="#对于MySQL中timestamp数据类型的特点，为什么选择timestamp类型" class="headerlink" title="对于MySQL中timestamp数据类型的特点，为什么选择timestamp类型"></a>对于MySQL中timestamp数据类型的特点，为什么选择timestamp类型</h3><p>1.存储占用 4个字节，以年月日小时分秒的日期型式显示 2.存储范围’1970-01-01 00:00:01’ to ‘2038-01-19 03:14:07’. 3.以UTC时区进行存储，但是以系统当前时间进行显示 4.可以在insert和update时把值自动更新为当前时间</p>
<h2 id="NULL-是什么意思"><a href="#NULL-是什么意思" class="headerlink" title="NULL 是什么意思"></a>NULL 是什么意思</h2><p>NULL 这个值表示 UNKNOWN(未知):它不表示“”(空字符串)。对 NULL 这个值的任何比较都会生产一个<br>NULL 值。您不能把任何值与一个 NULL 值进行比较，并在逻辑上希望获得一个答案。使用 IS NULL 来<br>进行 NULL 判断</p>
<h2 id="自增ID问题"><a href="#自增ID问题" class="headerlink" title="自增ID问题"></a>自增ID问题</h2><p>一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</p>
<ol>
<li><p>如果表的类型是MyISAM，那么是18<br>因为MyISAM表会把自增主键的最大ID记录到数据文件里，重启MySQL自增主键的最大ID也不会丢失</p>
</li>
<li><p>如果表的类型是InnoDB，那么是15<br>InnoDB表只是把自增主键的最大ID记录到内存中，所以重启数据库或者是对表进行OPTIMIZE操作，都会导致最大ID丢失</p>
</li>
</ol>
<h1 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h1><h1 id="MySQL-支持哪些存储引擎"><a href="#MySQL-支持哪些存储引擎" class="headerlink" title="MySQL 支持哪些存储引擎"></a>MySQL 支持哪些存储引擎</h1><p>MySQL 支持的存储引擎主要有四种：</p>
<ol>
<li><strong>InnoDB</strong> 支持<strong>事务</strong>，<strong>行级锁定</strong>和<strong>外键</strong>，是<strong>事务型</strong>数据库的首选引擎；MySQL5.5.5 之后的默认存储引擎；</li>
<li><strong>MyISAM</strong> 拥有较高的插入、查询速度，但<strong>不支持事务</strong>。MySQL5.5.5 之前的默认存储引擎；</li>
<li><strong>Memory</strong> 基于散列，存储在内存中，对临时表有用。常见的应用场景是：<strong>临时存放数据，数据量不大，并且不需要较高的数据安全性</strong>；</li>
<li><strong>Archive</strong> 支持<strong>高并发</strong>的插入操作，但是本身不是事务安全的。常见的应用场景：<strong>存储归档数据，如记录日志信息可以使用 Archive</strong>。</li>
</ol>
<h2 id="MySQL中哪些存储引擎支持事务？"><a href="#MySQL中哪些存储引擎支持事务？" class="headerlink" title="MySQL中哪些存储引擎支持事务？"></a>MySQL中哪些存储引擎支持事务？</h2><p>最常用的存储引擎是InnoDB引擎和MyISAM存储引擎，InnoDB是MySQL的默认事务引擎。</p>
<table>
<thead>
<tr>
<th>特性比较</th>
<th>事务</th>
<th>并发</th>
<th>外键</th>
<th>备份</th>
<th>崩溃恢复</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>InnoDB</td>
<td>事务型</td>
<td>行级锁</td>
<td>支持</td>
<td>在线热备</td>
<td>概率低</td>
<td>聚簇索引，MVCC特性</td>
</tr>
<tr>
<td>MyISAM</td>
<td>非事务性</td>
<td>行级锁</td>
<td>支持</td>
<td>不支持</td>
<td>慢，已丢失</td>
<td>压缩表，空间数据索引</td>
</tr>
</tbody></table>
<h2 id="介绍一下mysql的MVCC机："><a href="#介绍一下mysql的MVCC机：" class="headerlink" title="介绍一下mysql的MVCC机："></a>介绍一下mysql的MVCC机：</h2><p>MVCC是一种多版本并发控制机制，是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。MVCC是通过保存数据在某个时间点的快照来实现该机制，其在每行记录后面保存两个隐藏的列，分别保存这个行的创建版本号和删除版本号，然后Innodb的MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行所有快照连接起来。</p>
<h2 id="InnoDB与MyISAM的区别"><a href="#InnoDB与MyISAM的区别" class="headerlink" title="InnoDB与MyISAM的区别"></a>InnoDB与MyISAM的区别</h2><ol>
<li>事务</li>
<li>外键</li>
<li>MyISAM-非聚集索引；InnoDB-聚集索引</li>
<li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一<br>个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li>
<li>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高</li>
</ol>
<h1 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h1><p>第一范式：列不可再分<br>第二范式：行可以唯一区分，主键约束<br>第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束<br>且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上 。</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构，可以帮助我们快速的进行数据的查找</p>
<p>MySQL索引使用的数据结构主要有BTree索引 和 哈希索引 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p>
<p>MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。</p>
<ul>
<li><p>MyISAM: B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p>
<blockquote>
<p>非聚集索引 (secondary index)，又称为辅助索引、普通索引，该索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表可以包含多个非聚集索引。</p>
</blockquote>
</li>
<li><p>InnoDB: 其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。</p>
<blockquote>
<p>聚集索引 (clustered index)，又称为主索引，该索引中键值的逻辑顺序决定了表中相应行的物理顺序。因为数据真正的数据只能有一种排序方式，所以一个表上只能有一个聚簇索引。</p>
</blockquote>
</li>
</ul>
<p>聚集索引 / 非聚集索引不是一种索引类型，而是一种存储数据的方式。在 InnoDB 中它们还有一个非常重要的区别：<strong>聚集索引的叶子节点的的 data 域包含了完整的数据记录，而非聚集索引的叶子节点的 data 域记录着主键的值</strong>。</p>
<p>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
<p>在使用非聚集索引进行查找时，需要先查找到主键值，然后再到聚集索引中进行查找，这称之为回表查询。非聚簇索引不一定会回表查询</p>
<h2 id="MySQL-索引底层是什么结构？为什么采用此结构？"><a href="#MySQL-索引底层是什么结构？为什么采用此结构？" class="headerlink" title="MySQL 索引底层是什么结构？为什么采用此结构？"></a>MySQL 索引底层是什么结构？为什么采用此结构？</h2><p>mysql 底层采用 B + 树的存储结构。采用 B + 树的原因：</p>
<p>（1）索引文件很大，不能全部存储在内存中，只能存储到磁盘上，因此索引的数据结构要尽量减少查找过程中磁盘 I/O 的存取次数；</p>
<p>（2）数据库系统利用了磁盘预读原理和磁盘预读，将一个节点的大小设为等于一个页，这样每个节点只需要一次 I/O 就可以完全载入。而 B + 树的高度是 2~4，检索一次最多只需要访问 4 个节点（4 次，即树的高度）。</p>
<h2 id="为什么不适用-B-树？"><a href="#为什么不适用-B-树？" class="headerlink" title="为什么不适用 B 树？"></a>为什么不适用 B 树？</h2><p>B + 树所有的 Data 域在叶子节点，其余节点用来索引，</p>
<p><img src="file:///E:/YouDaoYun/m18739288920@163.com/8dbe6e2d4f1e489d86f88afbbeda5c9b/xtnpu3ir.bmp?ynotemdtimestamp=1618651314817" alt="image"></p>
<p>而 B 树是每个索引节点都会有 Data 域；</p>
<p><img src="file:///E:/YouDaoYun/m18739288920@163.com/3b1a0be34dfa49e2a7dced52699dbd92/ygkj4yk5.bmp?ynotemdtimestamp=1618651314817" alt="image"></p>
<p>并且 B + 树所有叶子节点之间都有一个链指针。</p>
<p>这样遍历叶子节点就能获得全部数据，从而支持区分查询。在数据库中基于范围的查询是非常频繁的，而 B 树不支持这样的遍历操作。</p>
<h2 id="为什么不用哈希表？"><a href="#为什么不用哈希表？" class="headerlink" title="为什么不用哈希表？"></a>为什么不用哈希表？</h2><p>（1）哈希表只适用与查找等值查询， 不能支持区分条件（大于小于查询）、模糊查询等；</p>
<p>（2）hash 索引虽然在等值查询上较快，但是不稳定，性能不可预测，当某个键值存在大量重复的时候，发生 hash 碰撞，此时效率可能极差。而 B + 树的查询效率比较稳定。</p>
<h2 id="为什么不用红黑树？"><a href="#为什么不用红黑树？" class="headerlink" title="为什么不用红黑树？"></a>为什么不用红黑树？</h2><p>红黑树往往高度过大，从页造成磁盘 IO 读写过于频繁，效率低下。而且逻辑上很近的节点（父子）物理上可能很远，无法利用局部性原理。</p>
<h2 id="Hash索引和B-树所有有什么区别或者说优劣呢"><a href="#Hash索引和B-树所有有什么区别或者说优劣呢" class="headerlink" title="Hash索引和B+树所有有什么区别或者说优劣呢?"></a>Hash索引和B+树所有有什么区别或者说优劣呢?</h2><p>首先要知道Hash索引和B+树索引的底层实现原理:</p>
<p>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据；B+树底层实现是多路平衡查找树，对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据.。</p>
<p>那么可以看出他们有以下的不同:</p>
<p>1、hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询.</p>
<p>因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</p>
<p>2、hash索引不支持使用索引进行排序，原理同上；</p>
<p>3、hash索引不支持模糊查询以及多列索引的最左前缀匹配，原理也是因为hash函数的不可预测.AAAA和AAAAB的索引没有相关性；</p>
<p>4、hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询；</p>
<p>5、hash索引虽然在等值查询上较快,但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</p>
<p>因此在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度，而不需要使用hash索引。</p>
<h2 id="MySQL-支持的索引类型是哪些？"><a href="#MySQL-支持的索引类型是哪些？" class="headerlink" title="MySQL 支持的索引类型是哪些？"></a>MySQL 支持的索引类型是哪些？</h2><ol>
<li>普通索引：用表中的普通列构建的索引，没有任何限制；</li>
<li>唯一索引：唯一索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的合必须唯一；</li>
<li>主键索引：是一种特殊的唯一索引，根据主键建立索引，不允许重复，不允许空值；</li>
<li>全文索引：通过过建立倒排索引，快速匹配文档的方式。MySQL 5.7.6 之前仅支持英文，MySQL 5.7.6 之后支持中文；</li>
<li>组合索引：又叫联合索引。用多个列组合构建的索引，这多个列中的值不允许有空值。可以在创建表的时候指定，也可以修改表结构。</li>
</ol>
<h2 id="建立索引的原则有哪些？"><a href="#建立索引的原则有哪些？" class="headerlink" title="建立索引的原则有哪些？"></a>建立索引的原则有哪些？</h2><p>在经常需要搜索的列上，可以加快搜索的速度；</p>
<p>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p>
<p>在经常需要排序的列上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</p>
<p>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</p>
<p>在经常用在连接的列上，这 些列主要是一些外键，可以加快连接的速度；</p>
<p>避免 where 子句中对字段施加函数，这会造成无法命中索引。</p>
<p>在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</p>
<p>将某一列设置为default null，where 是可以走索引，另外索引列是否设置 null 是不影响性能的。 但是，还是不建议列上允许为空。最好限制not null，因为null需要更多的存储空间并且null值无法参与某些运算。</p>
<p>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 chema_unused_indexes 视图来查询哪些索引从未被使用</p>
<p>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</p>
<h2 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h2><p>MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name&#x3D;xx and city&#x3D;xx ; ／／可以命中索引</span><br><span class="line">select * from user where name&#x3D;xx ; &#x2F;&#x2F; 可以命中索引</span><br><span class="line">select * from user where city&#x3D;xx ; &#x2F;&#x2F; 无法命中索引            </span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 city= xx and name ＝xx，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。</p>
<p>由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDER BY子句也遵循此规则。</p>
<h2 id="索引建立越多越好吗"><a href="#索引建立越多越好吗" class="headerlink" title="索引建立越多越好吗?"></a>索引建立越多越好吗?</h2><p>索引并不是越多越好！索引可以提高效率同样可以降低效率。</p>
<p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p>
<p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p>
<h2 id="索引这么多优点，为什么不对表中的每一个列创建一个索引呢？"><a href="#索引这么多优点，为什么不对表中的每一个列创建一个索引呢？" class="headerlink" title="索引这么多优点，为什么不对表中的每一个列创建一个索引呢？"></a>索引这么多优点，为什么不对表中的每一个列创建一个索引呢？</h2><ol>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
</ol>
<h2 id="索引什么时候会失效？"><a href="#索引什么时候会失效？" class="headerlink" title="索引什么时候会失效？"></a>索引什么时候会失效？</h2><p>（1）条件中有 or；</p>
<p>（2）like 查询（以 % 开头）；</p>
<p>（3）如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不使用索引；</p>
<p>（4）对列进行函数运算（如 where md5 (password) = “xxxx”）；</p>
<p>（5）负向查询条件会导致无法使用索引，比如 NOT IN,NOT LIKE,!= 等；</p>
<p>（6）对于联合索引，不是使用的第一部分 (第一个)，则不会使用索引（最左匹配）；</p>
<p>（7）如果 mysql 评估使用全表扫描要比使用索引快，则不使用索引；</p>
<h3 id="索引追问"><a href="#索引追问" class="headerlink" title="索引追问"></a>索引追问</h3><p>表 A 建立了 INDEX (col1,col2,col3) 的联合索引，where 条件中使用 col1 = a1 and col3=c1 索引是否有效？</p>
<p>索引有效。</p>
<h4 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h4><p>联合索引的最左前缀匹配原则，顾名思义，它是指在检索数据时从联合索引的最左边开始匹配。如果你创建一个了联合索引 (col1, col2, col3)，那么该索引的任何前缀都会用于查询，即 (col1), (col1, col2), (col1, col2, col3) 都会使用索引查询。</p>
<p>其实最左匹配原则也是和 B + 树的结构相关，比如使用 (col1, col2, col3) 上述索引，B + 树是按照从左到右的顺序来建立搜索树的，比如当检索 (‘a1’,‘b1’,‘c1’) 时，B + 树会优先比较’a1’再来确定下一步的搜索方向，如果 col1 相同再依次比较 col2 和 col3，最后得到检索的数据；但当检索 (‘b1’,‘c1’) 这样的没有 col1 的数据时，B + 树就不知道第一步该查哪个节点，所以不能使用索引。而当检索 (‘a1’,‘c1’) 时，B + 树可以用 col1 来指定搜索方向，即使下一个字段 col2 缺失，也能把所有 col1=’a1’的数据找出来，然后再匹配 col3=’c1’数据。</p>
<h2 id="索引有什么缺点？"><a href="#索引有什么缺点？" class="headerlink" title="索引有什么缺点？"></a>索引有什么缺点？</h2><p>（1）索引需要额外的占用物理空间，索引越多，所以空间越多；</p>
<p>（2）当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的写入速度；</p>
<h2 id="使用索引查询一定能提高查询的性能吗？为什么"><a href="#使用索引查询一定能提高查询的性能吗？为什么" class="headerlink" title="使用索引查询一定能提高查询的性能吗？为什么"></a>使用索引查询一定能提高查询的性能吗？为什么</h2><p>通常,通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价.</p>
<p>索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况:</p>
<ul>
<li>基于一个范围的检索,一般查询返回结果集小于表中记录数的30%</li>
<li>基于非唯一性索引的检索</li>
</ul>
<h2 id="为什么索引能提高查询速度"><a href="#为什么索引能提高查询速度" class="headerlink" title="为什么索引能提高查询速度"></a>为什么索引能提高查询速度</h2><p>MySQL的基本存储结构是页(记录都存在页里边)</p>
<p>各个数据页可以组成一个双向链表</p>
<p>每个数据页中的记录又可以组成一个单向链表</p>
<p>如果不用索引：定位到记录所在的页：需要遍历双向链表，找到所在的页，从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。</p>
<h2 id="事务是如何通过日志来实现的，说得越深入越好"><a href="#事务是如何通过日志来实现的，说得越深入越好" class="headerlink" title="事务是如何通过日志来实现的，说得越深入越好"></a>事务是如何通过日志来实现的，说得越深入越好</h2><p>因为事务在修改页时，要先记 undo，在记 undo之前要记 undo 的 redo， 然后修改数据页，再记数据页修改的 redo。redo（里面包括 undo 的修改） 一定要比数据页先持久化到磁盘。当事务需要回滚时，因为有 undo，可以把数据页回滚到前镜像的状态；崩溃恢复时，如果 redo log 中事务没有对应的 commit 记录，那么需要用 undo把该事务的修改回滚到事务开始之前。如果有 commit 记录，就用 redo 前滚到该事务完成时并提交掉。</p>
<h2 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a>事务有哪些特性？</h2><p>1、原子性（Atomicity）：事务是一个不可分割的单位，事务中的所有SQL等操作要么都发生，要么都不发生。</p>
<p>2、一致性（Consistency）：事务发生前和发生后，数据的完整性必须保持一致。</p>
<p>3、隔离性（Isolation）：当并发访问数据库时，一个正在执行的事务在执行完毕前，对应其他的会话是不可见的，多个并发事务之间的数据是相互隔离的。备份的参数 –single-transaction</p>
<p>4、持久性（Durability）：一个事务一旦被提交，它对数据库中的数据改变就是永久性的。如果出了错误，事务也不允许撤销，只能通过“补偿性事务”。</p>
<p>MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？</p>
<p>InnoDB是基于索引来完成行锁。</p>
<p>例如在<code>select * from tab_with_index where id = 1 for update</code>中。for update 可以根据条件来完成行锁锁定,并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起。</p>
<h2 id="并发事务带来哪些问题"><a href="#并发事务带来哪些问题" class="headerlink" title="并发事务带来哪些问题?"></a>并发事务带来哪些问题?</h2><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一<br>数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>
<p><strong>脏读（Dirty read）</strong>: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据<br>库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数<br>据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p>
<p><strong>丢失修改（Lost to modify）</strong>: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在<br>第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢<br>失，因此称为丢失修。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，<br>事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</p>
<p><strong>不可重复读（Unrepeatableread）</strong>: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另<br>一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个<br>事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称<br>为不可重复读。</p>
<p><strong>幻读（Phantom read）</strong>: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另<br>一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不<br>存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
<p><strong>不可重复读和幻读区别</strong>：<br>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者<br>删除比如多次读取一条记录发现记录增多或减少了</p>
<h2 id="详述一下数据库事务隔离的四个级别"><a href="#详述一下数据库事务隔离的四个级别" class="headerlink" title="详述一下数据库事务隔离的四个级别"></a>详述一下数据库事务隔离的四个级别</h2><blockquote>
<p>MySQL 的默认事务处理级别是可重复读，Oracle 的默认事务处理级别是读提交。</p>
</blockquote>
<p>（1）Read Uncommitted（<strong>读未提交</strong>）：事务可以看到其他<strong>未提交事务</strong>的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。而且可能出现<strong>脏读</strong>（Dirty Read），即<strong>一个事务读取到另一个事务还有没提交的记录</strong>。</p>
<p>（2） Read Committed（<strong>读提交</strong>） ：事务只能看见<strong>已经提交的事务</strong>所做的改变。这种隔离级别可能导致<strong>不可重复读</strong>（Nonrepeatable Read），<strong>即同一事务的其他实例在该实例处理其间可能会有新的 commit，所以同一个查询操作执行两次或多次的结果不一致</strong>。</p>
<p>（3）Repeatable Read（<strong>可重复读</strong>） ， <strong>事务的多个实例在并发读取数据时读到同样的数据行</strong>。不过理论上，这会导致另一个棘手的问题：<strong>幻读</strong>（PhantomRead），它是指<strong>当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的 “幻影” 数据</strong>。</p>
<p>（4）Serializable（<strong>串行化</strong>） ：通过强制<strong>事务排序</strong>，使之不可能相互冲突，从而解决幻读问题。简言之，它是在<strong>每个读的数据行上加上共享锁</strong>。在这个级别，可能导致<strong>大量的超时现象和锁竞争</strong>。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻影读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED（<strong>读未提交</strong>）</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED（<strong>读提交</strong>）</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ（<strong>可重复读</strong>）</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE（<strong>串行化</strong>）</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p>
<h3 id="不可重复度和幻读区别："><a href="#不可重复度和幻读区别：" class="headerlink" title="不可重复度和幻读区别："></a>不可重复度和幻读区别：</h3><p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>
<p>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。</p>
<p>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。 </p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>redo log 是 InnoDB 引擎特有的；</p>
<p>binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</p>
<hr>
<p><strong>区别</strong></p>
<ul>
<li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；</li>
<li>binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</li>
<li>redo log 是循环写的，空间固定会用完；</li>
<li>binlog 是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
<li>redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit =1表示每次事务的redo log</li>
<li>都持久化到磁盘，保证mysql异常重启之后数据不丢失。Sync_binlog=1参数设置为1，表示每次事务的binlog都持久化到磁盘，保证mysql异常重启之后binlog不丢失。</li>
</ul>
<h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><p>解释一下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?</p>
<p>这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，<strong>在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果使用了所有连接，则会建立一个新连接并将其添加到池中</strong></p>
<h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><ul>
<li>主：129<ul>
<li>从：131</li>
</ul>
</li>
</ul>
<h2 id="主从配置1"><a href="#主从配置1" class="headerlink" title="主从配置1"></a>主从配置1</h2><ul>
<li>主配置log-bin，指定文件的名字</li>
<li>主配置server-id 默认为1</li>
<li>从配置server-id 与主不能重复</li>
</ul>
<h3 id="主配置"><a href="#主配置" class="headerlink" title="主配置"></a>主配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">...</span><br><span class="line">log-bin=my_mysql</span><br><span class="line">server-id=1</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>

<h3 id="从配置"><a href="#从配置" class="headerlink" title="从配置"></a>从配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">...</span><br><span class="line">server-id=2</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>

<h2 id="主从配置2"><a href="#主从配置2" class="headerlink" title="主从配置2"></a>主从配置2</h2><ul>
<li>主创建备份账户并授权REPLICATION SLAVE</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CREATE USER <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;12345&#x27;</span>;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> GRANT REPLICATION SLAVE ON *.* TO <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> flush privileges;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>主进行行锁表FLUSH TABLE WITH READ LOCK；（主从同步的时间内阻塞所有写入操作）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> FLUSH TABLES WITH READ LOCK;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>主 找到log-bin的位置 SHOW MASTER STATUS；</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; SHOW MASTER STATUS;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File            | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+-----------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| my_mysql.000001 |      849 |              |                  |                   |</span><br><span class="line">+-----------------+----------+--------------+------------------+-------------------+</span><br></pre></td></tr></table></figure>

<ul>
<li>主备份数据</li>
</ul>
<blockquote>
<p>需要新建会话，不能再mysql客户端运行，也不能exit，因为正在锁表</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump --all-databases --master-data &gt; dbdump.db -uroot -p</span><br></pre></td></tr></table></figure>

<ul>
<li>把主上的dbdump.db拷贝至从</li>
</ul>
<blockquote>
<p>在从节点上进行操作</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp root@192.168.159.129:/opt/dbdump.db .</span><br><span class="line">mysql &lt; dbdump.db -uroot -p</span><br></pre></td></tr></table></figure>

<ul>
<li>放开主上的锁表</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> UNLOCK TABLES;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在从上设置住的配置</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CHANGE MASTER TO</span></span><br><span class="line"><span class="meta">	-&gt;</span><span class="bash"> MASTER_HOST=<span class="string">&#x27;master_host_name&#x27;</span>,</span> 	</span><br><span class="line"><span class="meta">	-&gt;</span><span class="bash"> MASTER_PORT=port_num</span> </span><br><span class="line"><span class="meta">	-&gt;</span><span class="bash"> MASTER_USER=<span class="string">&#x27;replication_user_name&#x27;</span>,</span> </span><br><span class="line"><span class="meta">	-&gt;</span><span class="bash"> MASTER_PASSWORD=<span class="string">&#x27;replication_password&#x27;</span>,</span> 			        </span><br><span class="line"><span class="meta">	-&gt;</span><span class="bash"> MASTER_LOG_FILE=<span class="string">&#x27;recorded_log_file_name&#x27;</span>,</span>			   </span><br><span class="line">    -&gt; MASTER_LOG_POS=recorded_log_position;</span><br></pre></td></tr></table></figure>

<ul>
<li>从执行START SLAVE</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> START SLAVE;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show slave status;</span></span><br></pre></td></tr></table></figure>



<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>在MySQL主从复制架构中，读操作可以在所有的服务器上面进行，而写操作只能在主服务器上面进行。主从复制架构虽然给读操作提供了扩展，可如果写操作也比较多的话（多台从服务器还要从主服务器上面同步数据），单主模型的复制中主服务器势必会成为性能瓶颈。</p>
<ol>
<li>基于记录的复制：主服务器上面执行的语句在从服务器上面再执行一遍，在MySQL-3.23版本以后支持。</li>
</ol>
<ul>
<li>存在的问题：时间上可能不完全同步造成偏差，执行语句的用户也可能是不同一个用户</li>
</ul>
<ol>
<li>基于语句的复制：把主服务器上面改编后的内容直接复制过去，而不关心到底改变该内容是由哪条语句引发的，在MySQL-5.0版本以后引入。</li>
</ol>
<ul>
<li>存在的问题：比如一个工资表中有一万个用户，我们把每个用户的工资+1000，那么基于行的复制则要复制一万行的内容，由此造成的开销比较大，而基于语句的复制仅仅一条语句就可以了。</li>
</ul>
<h2 id="复制过程："><a href="#复制过程：" class="headerlink" title="复制过程："></a>复制过程：</h2><ol>
<li>在每个事务更新数据完成之前，master在二进制日志记录这些改变。写入二进制日志完成后，master通知存储引擎提交事务。</li>
<li>Slave将master的binary log复制到其中继日志。首先slave开始一个工作线程（I/O），I/O线程在master上打开一个普通的连接，然后开始binlog dump process。binlog dump process从master的二进制日志中读取事件，如果已经跟上master，它会睡眠并等待master产生新的事件，I/O线程将这些事件写入中继日志。</li>
<li>Sql slave thread（sql从线程）处理该过程的最后一步，sql线程从中继日志读取事件，并重放其中的事件而更新slave数据，使其与master中的数据一致，只要该线程与I/O线程保持一致，中继日志通常会位于os缓存中，所以中继日志的开销很小。</li>
</ol>
<h2 id="分库分表之后-id-主键如何处理"><a href="#分库分表之后-id-主键如何处理" class="headerlink" title="分库分表之后,id 主键如何处理"></a>分库分表之后,id 主键如何处理</h2><p>因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来<br>支持。<br>生成全局 id 有下面这几种方式：<br><strong>UUID</strong>：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字<br>的标示比如文件的名字。<br><strong>数据库自增 id</strong> : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id<br>有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。<br><strong>利用 redis 生成 id</strong> : 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复<br>杂，可用性降低，编码更加复杂，增加了系统成本。<br><strong>Twitter的snowflake算法</strong> ：Github 地址：<a target="_blank" rel="noopener" href="https://github.com/twitter-archive/snowflake%E3%80%82">https://github.com/twitter-archive/snowflake。</a><br>**美团的Leaf分布式ID生成系统 **：Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、<br>单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等<br>中间件。感觉还不错。美团技术团队的一篇文章：<a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/04/21/mt-leaf.ht">https://tech.meituan.com/2017/04/21/mt-leaf.ht</a><br>ml</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="MySQL-中有哪几种锁？"><a href="#MySQL-中有哪几种锁？" class="headerlink" title="MySQL 中有哪几种锁？"></a>MySQL 中有哪几种锁？</h2><p>1、表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。<br>2、行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<br>3、页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发<br>度一般</p>
<h2 id="锁的优化策略"><a href="#锁的优化策略" class="headerlink" title="锁的优化策略"></a>锁的优化策略</h2><p>1、读写分离<br>2、分段加锁<br>3、减少锁持有的时间<br>4.多个线程尽量以相同的顺序去获取资源不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放<br>次数过多，反而效率不如一次加一把大锁。</p>
<h1 id="优化数据库"><a href="#优化数据库" class="headerlink" title="优化数据库"></a>优化数据库</h1><p>最好是按照以下顺序优化：<br>1、SQL 语句及索引的优化<br>2、数据库表结构的优化<br>3、系统配置的优化<br>4、硬件的优化</p>
<hr>
<p>1、选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置 NOTNULL，例如’省份’、’性<br>别’最好适用 ENUM<br>2、使用连接(JOIN)来代替子查询<br>3、适用联合(UNION)来代替手动创建的临时表<br>4、事务处理<br>5、锁定表、优化事务处理<br>6、适用外键，优化锁定表<br>7、建立索引<br>8、优化查询语句</p>
<h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><p>1、查询语句中不要使用select *<br>2、尽量减少子查询，使用关联查询（left join,right join,inner join）替代<br>3、减少使用IN或者NOT IN ,使用exists，not exists或者关联查询语句替代<br>4、or 的查询尽量用 union或者union all 代替(在确认没有重复数据或者不用剔除重复数据时，union<br>all会更好)<br>5、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。<br>6、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫<br>描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null<br>值，然后这样查询： select id from t where num=0</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/16/%E4%B8%AD%E9%97%B4%E4%BB%B6-elasticsearch%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/16/%E4%B8%AD%E9%97%B4%E4%BB%B6-elasticsearch%E5%AD%A6%E4%B9%A0/" itemprop="url">中间件-elasticsearch学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-16T16:04:12+08:00">
                2021-04-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/16/%E5%88%86%E6%AD%A5%E5%BC%8F-%E5%88%86%E6%AD%A5%E5%BC%8F%E4%BC%9A%E8%AF%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/16/%E5%88%86%E6%AD%A5%E5%BC%8F-%E5%88%86%E6%AD%A5%E5%BC%8F%E4%BC%9A%E8%AF%9D/" itemprop="url">分步式-分步式会话</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-16T16:03:07+08:00">
                2021-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E6%AD%A5%E5%BC%8F-%E5%88%86%E6%AD%A5%E5%BC%8F%E4%BC%9A%E8%AF%9D/" itemprop="url" rel="index">
                    <span itemprop="name">分步式 - 分步式会话</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是会话"><a href="#什么是会话" class="headerlink" title="什么是会话"></a>什么是会话</h1><p>会话Session代表的是客户端与服务器的一次交互过程，</p>
<p>这个过程可以是连续也可以是时断时续的。曾经的Servlet时代（jsp），一旦用户与服务端交互，服务器tomcat就会为用户创建一个session，同时前端会有一个sessionid，每次交互都会携带。</p>
<p>如此一来，服务器只要在接到用户请求时候，就可以拿到jsessionid，并根据这个ID在内存中找到对应的会话session，当拿到session会话后，那么我们就可以操作会话了。会话存活期间，我们就能认为用户一直处于正在使用着网站的状态，一旦session超期过时，那么就可以认为用户已经离开网站，停止交互了。用户的身份信息，我们也是通过session来判断的，在session中可以保存不同用户的信息</p>
<p>操作<code>session</code>的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/setSession&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">setSession</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    HttpSession session = request.getSession();</span><br><span class="line">    session.setAttribute(<span class="string">&quot;userInfo&quot;</span>, <span class="string">&quot;new user&quot;</span>);</span><br><span class="line">    session.setMaxInactiveInterval(<span class="number">3600</span>);</span><br><span class="line">    session.getAttribute(<span class="string">&quot;userInfo&quot;</span>);</span><br><span class="line">    <span class="comment">// session.removeAttribute(&quot;userInfo&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="无状态会话"><a href="#无状态会话" class="headerlink" title="无状态会话"></a>无状态会话</h2><p>HTTP请求是无状态的，用户向服务端发起多个请求，服务端并不会知道这多次请求都是来自同一用户，这个就是无状态的。cookie的出现就是为了有状态的记录用户。</p>
<p>常见的，ios与服务端交互，安卓与服务端交互，前后端分离，小程序与服务端交互，他们都是通过发起http来调用接口数据的，每次交互服务端都不会拿到客户端的状态，但是我们可以通过手段去处理，比如每次用户发起请求的时候携带一个userid或者user-token，如此一来，就能让服务端根据用户id或token来获得相应的数据。每个用户的下一次请求都能被服务端识别来自同一个用户。</p>
<h2 id="有状态会话"><a href="#有状态会话" class="headerlink" title="有状态会话"></a>有状态会话</h2><p>Tomcat中的会话，就是有状态的，一旦用户和服务端交互，就有会话，会话保存了用户的信息，这样用户就“有状态”了，服务端会和每个客户端都保持着这样的一层关系，这个由容器来管理（也就是tomcat），这个session会话是保存到内存空间里的，如此一来，当不同的用户访问服务端，那么就能通过会话知道谁是谁了。tomcat会话的出现也是为了让http请求变的有状态。如果用户不再和服务端交互，那么会话超时则消失，结束了他的生命周期。如此一来，每个用户其实都会有一个会话被维护，这就是有状态会话。 场景：在传统项目或者jsp项目中是使用的最多的session都是有状态的，session的存在就是为了弥补http的无状态。</p>
<p><strong>注：</strong>tomcat会话可以通过手段实现多系统之间的状态同步，但是会损耗一定的时间，一旦发生同步那么用户请求就会等待，这种做法不可取。</p>
<h3 id="单Tomcat会话"><a href="#单Tomcat会话" class="headerlink" title="单Tomcat会话"></a>单Tomcat会话</h3><p>单个tomcat会话，这个就是有状态的，用户首次访问服务端，这个时候会话产生，并且会设置jsessionid放入cookie中，后续每次请求都会携带jsessionid以保持用户状态。</p>
<img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E6%AD%A5%E5%BC%8F%E4%BC%9A%E8%AF%9D/%E5%8D%95Tomcat%E4%BC%9A%E8%AF%9D.png" style="zoom:50%;" />

<h3 id="动静分离会话"><a href="#动静分离会话" class="headerlink" title="动静分离会话"></a>动静分离会话</h3><p>用户请求服务端，由于动静分离，前端发起http请求，不会携带任何状态，当用户第一次请求以后，我们手动设置一个token，作为用户会话，放入redis中，如此作为redis-session，并且这个token设置后放入前端cookie中（app或小程序可以放入本地缓存），如此后续交互过程中，前端只需要传递token给后端，后端就能识别这个用户请求来自谁了。 </p>
<img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E6%AD%A5%E5%BC%8F%E4%BC%9A%E8%AF%9D/%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E4%BC%9A%E8%AF%9D.png" style="zoom: 50%;" />

<h3 id="集群分布式系统会话"><a href="#集群分布式系统会话" class="headerlink" title="集群分布式系统会话"></a>集群分布式系统会话</h3><p>集群或分布式系统本质都是多个系统，假设这个里有两个服务器节点，分别是AB系统，他们可以是集群，也可以是分布式系统，一开始用户和A系统交互，那么这个时候的用户状态，我们可以保存到redis中，作为A系统的会话信息，随后用户的请求进入到了B系统，那么B系统中的会话我也同样和redis关联，如此AB系统的session就统一了。当然cookie是会随着用户的访问携带过来的。那么这个其实就是分布式会话，通过redis来保存用户的状态。 </p>
<blockquote>
<p>相同顶级域名的二级域名才可以共享cookie</p>
</blockquote>
<blockquote>
<p>集群状态下还可以使用ip_hash的模式保证同一个ip访问同一个tomcat</p>
</blockquote>
<h1 id="相同顶级域名的单点登录"><a href="#相同顶级域名的单点登录" class="headerlink" title="相同顶级域名的单点登录"></a>相同顶级域名的单点登录</h1><h2 id="Cookie-Redis-实现-SSO"><a href="#Cookie-Redis-实现-SSO" class="headerlink" title="Cookie + Redis 实现 SSO"></a>Cookie + Redis 实现 SSO</h2><p>分布式会话后端是基于redis的，如此会话可以流窜在后端的任意系统，都能获取到缓存中的用户数据信息。前端通过使用cookie，可以保证在同域名的下的单点登录</p>
<p><strong>原理</strong></p>
<ul>
<li><p>cookie和网站的依赖关系，顶级域名 <a target="_blank" rel="noopener" href="http://www.test.com和*.test.com的cookie值是可以共享的,可以被携带至后端的,比如设置为/">www.test.com和*.test.com的cookie值是可以共享的，可以被携带至后端的，比如设置为</a> 一级域名设置为<code>.imooc.com</code>或<code>.t.mukewang.com</code>。</p>
</li>
<li><p>二级域名自己的独立cookie是不能共享的，不能被其他二级域名获取，比如：music.test.com的cookie是不能被mtv.test.com共享，两者互不影响，要共享必须是解析于同一个顶级域名之下,cookieDomain设置为<code>.imooc.com</code>才行。</p>
</li>
</ul>
<h1 id="不同顶级域名的单点登录"><a href="#不同顶级域名的单点登录" class="headerlink" title="不同顶级域名的单点登录"></a>不同顶级域名的单点登录</h1><blockquote>
<p>谷歌禁用sso了，本身现在也不流行这种做法了，所以了解一下即可,通常也只做同级域名的单点登录，跨域名不做的。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://www.test.com要和www.demo.com的会话实现共享,这个时候的cookie由于顶级域名不同,就不能实现cookie跨域了,每个站点各自请求到服务端,cookie无法同步.比如,www.test.com下的用户发起请求后会有cookie,但是他又访问了www.demo.com,由于cookie无法携带,所以会要你二次登录./">www.test.com要和www.demo.com的会话实现共享，这个时候的cookie由于顶级域名不同，就不能实现cookie跨域了，每个站点各自请求到服务端，cookie无法同步。比如，www.test.com下的用户发起请求后会有cookie，但是他又访问了www.demo.com，由于cookie无法携带，所以会要你二次登录。</a> </p>
<h2 id="解决方法——CAS系统"><a href="#解决方法——CAS系统" class="headerlink" title="解决方法——CAS系统"></a>解决方法——CAS系统</h2><p>多个系统之间的登录会通过一个独立的登录系统去做验证，它就相当于是一个中介公司，整合了所有人，你要看房经过中介允许拿钥匙就行，实现了统一的登录。CAS全称为Central Authentication Service即中央认证服务，是一个单点登录的解决方案，可以用于不同顶级域名之间的单点登录</p>
<p>用户在浏览需要登录的页面时，客户端将AuthToken提交给CAS服务校验登录状态/获取用户登录信息</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AuthToken</td>
<td>直接使用UUID/GUID即可，如果有验证AuthToken合法性需求，可以将userId+时间戳加密生成，服务端解密之后验证合法性</td>
</tr>
<tr>
<td>登录信息</td>
<td>通常是将UserId，UserName缓存起来</td>
</tr>
</tbody></table>
<h2 id="CAS系统时序图"><a href="#CAS系统时序图" class="headerlink" title="CAS系统时序图"></a>CAS系统时序图</h2><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E6%AD%A5%E5%BC%8F%E4%BC%9A%E8%AF%9D/CAS%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="image" style="zoom: 50%;" />



<h3 id="第一部分（用户初次访问MTV系统）"><a href="#第一部分（用户初次访问MTV系统）" class="headerlink" title="第一部分（用户初次访问MTV系统）"></a>第一部分（用户初次访问MTV系统）</h3><ol>
<li><p>用户初次访问<a target="_blank" rel="noopener" href="http://www.mtv.com:8080/sso-mtv/index.html">http://www.mtv.com:8080/sso-mtv/index.html</a></p>
</li>
<li><p>mtv系统在Cookie中未获取到用户信息</p>
</li>
<li><p>跳转至携带回跳URL访问CAS系统<a target="_blank" rel="noopener" href="http://www.sso.com:8090/login?returnUrl=http://www.mtv.com:8080/sso-mtv/index.html">http://www.sso.com:8090/login?returnUrl=http://www.mtv.com:8080/sso-mtv/index.html</a></p>
</li>
<li><p>CAS系统未能从cookie中能够获取到userTicket门票，证明用户从未登录过</p>
<ul>
<li><p>用户从未登录过则跳转到CAS的统一登录页面</p>
</li>
<li><p>验证登录信息</p>
<ol>
<li><p>创建用户的会话（登录信息，AuthToken统一存放的VO）存入redis</p>
</li>
<li><p>创建全局门票存入Cookie,全局门票和用户ID关联放入到redis中，代表这个用户有门票了，可以在访问各个站点了</p>
</li>
</ol>
</li>
<li><p>生成临时票据（存入redis中并对value加密，设置过期时间），回跳到调用端网站</p>
</li>
<li><p>mtv系统接收到临时票据会凭临时票据向CAS系统换取用户会话</p>
</li>
<li><p>CAS系统使用一次性临时票据来验证用户是否登录（redis中查找这个临时票据），之前的临时票据value加密是为了此时验证临时票据是否正确，如果登录过需要销毁临时票据，并从CAS系统的Cookie中取出全局门票，去redis中查到用户ID，后再用用户ID在redis中查到用户会话（登录信息，AuthToken统一存放的VO），把用户会话信息返回给站点</p>
</li>
<li><p>mtv系统使用Cookie保存用户会话</p>
</li>
<li><p>显示登陆成功</p>
</li>
</ul>
</li>
</ol>
<h2 id="第二部分（用户在次访问MUSIC系统）"><a href="#第二部分（用户在次访问MUSIC系统）" class="headerlink" title="第二部分（用户在次访问MUSIC系统）"></a>第二部分（用户在次访问MUSIC系统）</h2><ol>
<li><p>用户在次访问<a target="_blank" rel="noopener" href="http://www.music.com:8080/sso-music/index.html">http://www.music.com:8080/sso-music/index.html</a></p>
</li>
<li><p>music系统在Cookie中未获取到用户信息</p>
</li>
<li><p>跳转至携带回跳URL访问CAS系统<a target="_blank" rel="noopener" href="http://www.sso.com:8090/login?returnUrl=http://www.music.com:8080/sso-music/index.html">http://www.sso.com:8090/login?returnUrl=http://www.music.com:8080/sso-music/index.html</a></p>
</li>
<li><p>CAS系统从Cookie中能够获取到userTicket门票，证明用户登录过，此时签发一个一次性的临时票据（存入redis中并对value加密，设置过期时间）并且回跳</p>
<ul>
<li>music系统接收到临时票据会凭临时票据向CAS系统换取用户会话</li>
<li>CAS系统使用一次性临时票据来验证用户是否登录（redis中查找这个临时票据），之前的临时票据value加密是为了此时验证临时票据是否正确，如果登录过需要销毁临时票据，并从CAS系统的Cookie中取出全局门票，去redis中查到用户ID，后再用用户ID在redis中查到用户会话（登录信息，AuthToken统一存放的VO），把用户会话信息返回给站点</li>
<li>music系统使用Cookie保存用户会话</li>
<li>显示登陆成功</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/16/Java-%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/16/Java-%E9%98%9F%E5%88%97/" itemprop="url">Java-队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-16T00:59:58+08:00">
                2021-04-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="栈（Stack）和队列（Queue）的相同点和不同点是什么？如何用两个栈实现队列（入队和出队）"><a href="#栈（Stack）和队列（Queue）的相同点和不同点是什么？如何用两个栈实现队列（入队和出队）" class="headerlink" title="栈（Stack）和队列（Queue）的相同点和不同点是什么？如何用两个栈实现队列（入队和出队）"></a>栈（Stack）和队列（Queue）的相同点和不同点是什么？如何用两个栈实现队列（入队和出队）</h1><ul>
<li>相同点<ul>
<li>栈和队列都是属于线性表；</li>
<li>栈和队列插入操作都是限定在线性表的头尾进行；</li>
<li>栈和队列插入与删除的时间复杂度都是 O (1)；</li>
</ul>
</li>
<li>不同点<ul>
<li>特性不同，栈后进先出（LIFO，Last In First Out），队列先进先出（FIFO，First In First Out）；</li>
<li>栈只在表的一端进行插入和删除操作，队列只在表的一端进行插入操作，在表的另一端进行删除操作；</li>
<li>JAVA 中的栈 (Stack) 继承自 Vector，再往上的接口是 List/Collection；而队列（Queue) 直接继承的是 Collection 接口。</li>
</ul>
</li>
</ul>
<h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两个栈组成队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Stack&lt;E&gt; stack1 =<span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//入队操作的栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;E&gt; stack2 =<span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//出队操作的栈</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压入队列元素，只使用stack1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        stack1.add(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取出队列顶部元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// stack2的数据为空时，才把stack1中的元素压入stack2（两种情况：1、初始化时两个栈的数据均为空；2、stack2数据出栈出完了</span></span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stack1.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                stack2.add(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//stack1的数据出栈完成后，stack2仍然为空，说明两个栈的数据都为空</span></span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;queue is Empty!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        E head = stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StackQueue&lt;String&gt; stackQueue = <span class="keyword">new</span> StackQueue();</span><br><span class="line">        stackQueue.push(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">        stackQueue.push(<span class="string">&quot;second&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------first time poll in StackQueue---------&quot;</span>);</span><br><span class="line">        System.out.println(stackQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;------second time poll in StackQueue---------&quot;</span>);</span><br><span class="line">        System.out.println(stackQueue.poll());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------third time poll in StackQueue---------&quot;</span>);</span><br><span class="line">        stackQueue.push(<span class="string">&quot;third&quot;</span>);</span><br><span class="line">        System.out.println(stackQueue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h2><p>栈，只能在表尾插入或删除的线性表。对栈来说，表尾称为栈顶、表头称为栈底。因此，最先入栈的元素最后被删除，最晚入栈的元素最先被删除，所以栈又称为后进先出的线性表；</p>
<p>队列，只能在表的一端进行插入（队尾），在表的另一端删除元素（队头），所以又称先进先出的线性表；</p>
<p>本质上，是各自不同的数据结构决定了栈和队列的特性和应用场景，比如说栈经常用于括号匹配检验、行编辑程序、表达式求值、递归实现等等，而队列常用于作业任务排队等。</p>
<p><img src="file:///E:/YouDaoYun/m18739288920@163.com/1354e96afe6149689ecdfe7c5a9ed3c4/de5vxq7u.bmp?ynotemdtimestamp=1618464916797" alt="image"></p>
<p>stack1 用于存储元素，stack2 用于弹出元素。简单地说，就是把数据先压入 stack1，然后再从 stack1 中取出压入 stack2（后进先出），取数的时候直接从 stack2 出（后进先出），经过两次后进先出就符合队列先进先出的特性了。</p>
<h1 id="LinkedHashMap和PriorityQueue的区别？"><a href="#LinkedHashMap和PriorityQueue的区别？" class="headerlink" title="LinkedHashMap和PriorityQueue的区别？"></a>LinkedHashMap和PriorityQueue的区别？</h1><ul>
<li>PriorityQueue 是一个优先级队列,保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，</li>
<li>但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。</li>
</ul>
<h1 id="Queue中add-offer方法的区别？"><a href="#Queue中add-offer方法的区别？" class="headerlink" title="Queue中add/offer方法的区别？"></a>Queue中add/offer方法的区别？</h1><p>add()和offer()都是向队列中添加一个元素。一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，调用 add() 方法就会抛出IllegalStateException异常，而调用 offer() 方法会返回 false。</p>
<h1 id="Queue中remove-poll-方法的区别？"><a href="#Queue中remove-poll-方法的区别？" class="headerlink" title="Queue中remove()/poll()方法的区别？"></a>Queue中remove()/poll()方法的区别？</h1><p>poll()/remove()方法都是从队列中删除第一个元素。如果队列元素为空，调用remove() 则会抛出NoSuchElementException，而poll() 方法在用空集合调用时只是返回 null。</p>
<h1 id="Queue中element-peek-方法的区别？"><a href="#Queue中element-peek-方法的区别？" class="headerlink" title="Queue中element()/peek()方法的区别？"></a>Queue中element()/peek()方法的区别？</h1><p>element() 和 peek() 用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出NoSuchElementException异常，而 peek() 返回 null。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/">&lt;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <!--<a href="/archives/%7C%7Carchive">-->
                <a href="/archives/">
              
                  <span class="site-state-item-count">80</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">55</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuanyayuan" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:liyuan0707@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LiYuan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
