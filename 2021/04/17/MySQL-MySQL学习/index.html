<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="数据库,MySQL," />










<meta name="description" content="SQL语句一条SQL语句在MySQL中如何执行的SQL 等执行过程分为两类 对于查询等过程如下：权限校验—》查询缓存—》分析器—》优化器—》权限校验—》执行器—》引擎 对于更新等语句执行流程如下：分析器—-》权限校验—-》执行器—》引擎—redo log prepare—》binlog—》redo log commit SELECT * 和 SELECT 全部字段两种写法有何优缺点? 前者要解析数">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL-MySQL学习">
<meta property="og:url" content="https://yuanyayuan.github.io/2021/04/17/MySQL-MySQL%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hikari的Java之路">
<meta property="og:description" content="SQL语句一条SQL语句在MySQL中如何执行的SQL 等执行过程分为两类 对于查询等过程如下：权限校验—》查询缓存—》分析器—》优化器—》权限校验—》执行器—》引擎 对于更新等语句执行流程如下：分析器—-》权限校验—-》执行器—》引擎—redo log prepare—》binlog—》redo log commit SELECT * 和 SELECT 全部字段两种写法有何优缺点? 前者要解析数">
<meta property="og:locale">
<meta property="og:image" content="file:///E:/YouDaoYun/m18739288920@163.com/8dbe6e2d4f1e489d86f88afbbeda5c9b/xtnpu3ir.bmp?ynotemdtimestamp=1618651314817">
<meta property="og:image" content="file:///E:/YouDaoYun/m18739288920@163.com/3b1a0be34dfa49e2a7dced52699dbd92/ygkj4yk5.bmp?ynotemdtimestamp=1618651314817">
<meta property="article:published_time" content="2021-04-17T09:50:40.000Z">
<meta property="article:modified_time" content="2021-04-19T15:32:34.632Z">
<meta property="article:author" content="LiYuan">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="file:///E:/YouDaoYun/m18739288920@163.com/8dbe6e2d4f1e489d86f88afbbeda5c9b/xtnpu3ir.bmp?ynotemdtimestamp=1618651314817">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yuanyayuan.github.io/2021/04/17/MySQL-MySQL学习/"/>





  <title>MySQL-MySQL学习 | Hikari的Java之路</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hikari的Java之路</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Hello,world</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/17/MySQL-MySQL%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">MySQL-MySQL学习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-17T17:50:40+08:00">
                2021-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL-MySQL%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL - MySQL知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h1><h2 id="一条SQL语句在MySQL中如何执行的"><a href="#一条SQL语句在MySQL中如何执行的" class="headerlink" title="一条SQL语句在MySQL中如何执行的"></a>一条SQL语句在MySQL中如何执行的</h2><p>SQL 等执行过程分为两类</p>
<p>对于查询等过程如下：权限校验—》查询缓存—》分析器—》优化器—》权限校验—》执行器—》引擎</p>
<p>对于更新等语句执行流程如下：分析器—-》权限校验—-》执行器—》引擎—redo log prepare—》binlog—》redo log commit</p>
<h2 id="SELECT-和-SELECT-全部字段两种写法有何优缺点"><a href="#SELECT-和-SELECT-全部字段两种写法有何优缺点" class="headerlink" title="SELECT * 和 SELECT 全部字段两种写法有何优缺点?"></a>SELECT * 和 SELECT 全部字段两种写法有何优缺点?</h2><ol>
<li>前者要解析数据字典，后者不需要；</li>
<li>结果输出顺序，前者与建表列顺序相同，后者按指定字段顺序；</li>
<li>表字段改名，前者不需要修改，后者需要改；</li>
<li>后者可以建立索引进行优化，前者无法优化；</li>
<li>后者的可读性比前者要高。</li>
</ol>
<h2 id="简单说一说drop、delete与truncate的区别？"><a href="#简单说一说drop、delete与truncate的区别？" class="headerlink" title="简单说一说drop、delete与truncate的区别？"></a>简单说一说drop、delete与truncate的区别？</h2><p>delete和truncate只删除表的数据不删除表的结构</p>
<p>速度：drop&gt; truncate &gt;delete</p>
<p>delete语句是dml，这个操作会放到rollback segement中，事务提交之后才生效；如果有相应的trigger，执行的时候将被触发。 </p>
<p>truncate,drop是ddl，操作立即生效，原数据不放到rollback segment中，不能回滚。操作不触发trigger</p>
<h2 id="LiKE声明中的％和-是什么意思？"><a href="#LiKE声明中的％和-是什么意思？" class="headerlink" title="LiKE声明中的％和_是什么意思？"></a>LiKE声明中的％和_是什么意思？</h2><p>％对应于0个或更多字符，_只是LIKE语句中的一个字符。</p>
<h2 id="HAVNG-子句-和-WHERE-的异同点"><a href="#HAVNG-子句-和-WHERE-的异同点" class="headerlink" title="HAVNG 子句 和 WHERE 的异同点?"></a>HAVNG 子句 和 WHERE 的异同点?</h2><ol>
<li>语法上：where 用表中列名，having 用 select 结果别名；</li>
<li>影响结果范围：where 从表读出数据的行数，having 返回客户端的行数</li>
<li>索引：where 可以使用索引，having 不能使用索引，只能在临时结果集操作</li>
<li>where 后面不能使用聚集函数，having 是专门使用聚集函数的。</li>
</ol>
<h2 id="一个-SQL-执行的很慢的原因"><a href="#一个-SQL-执行的很慢的原因" class="headerlink" title="一个 SQL 执行的很慢的原因"></a>一个 SQL 执行的很慢的原因</h2><p>1、大多数情况下很正常，偶尔很慢，则有如下原因</p>
<p>(1)、数据库在刷新脏页，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">redo log 写满了需要同步到磁盘。</span><br><span class="line">内存不够用了</span><br></pre></td></tr></table></figure>

<p>(2)、执行的时候，遇到锁，如表锁、行锁。</p>
<p>2、这条 SQL 语句一直执行的很慢，则有如下原因。</p>
<p>(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。</p>
<p>(2)、数据库选错了索引。系统是通过索引的区分度来判断的,区分度称之为基数。系统采样的方式，来预测索引的基数的，由于统计的失误会预测错索引的基数，导致系统没有走索引，而是走了全表扫描</p>
<h2 id="什么是内联接、左外联接、右外联接？"><a href="#什么是内联接、左外联接、右外联接？" class="headerlink" title="什么是内联接、左外联接、右外联接？"></a>什么是内联接、左外联接、右外联接？</h2><p>内联接（Inner Join）：匹配2张表中相关联的记录。<br>左外联接（Left Outer Join）：除了匹配2张表中相关联的记录外，还会匹配左表中剩余的记录，右表<br>中未匹配到的字段用NULL表示。<br>右外联接（Right Outer Join）：除了匹配2张表中相关联的记录外，还会匹配右表中剩余的记录，左表<br>中未匹配到的字段用NULL表示。</p>
<h2 id="什么是通用-SQL-函数？"><a href="#什么是通用-SQL-函数？" class="headerlink" title="什么是通用 SQL 函数？"></a>什么是通用 SQL 函数？</h2><p>1、CONCAT(A, B) – 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个<br>字段。<br>2、FORMAT(X, D)- 格式化数字 X 到 D 有效数字。<br>3、CURRDATE(), CURRTIME()- 返回当前日期或时间。<br>4、NOW（） – 将当前日期和时间作为一个值返回。<br>5、MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） – 从日期值中提取给定数据。<br>6、HOUR（），MINUTE（），SECOND（） – 从时间值中提取给定数据。<br>7、DATEDIFF（A，B） – 确定两个日期之间的差异，通常用于计算年龄<br>8、SUBTIMES（A，B） – 确定两次之间的差异。<br>9、FROMDAYS（INT） – 将整数天数转换为日期值</p>
<h2 id="SQL-注入漏洞产生的原因？如何防止？"><a href="#SQL-注入漏洞产生的原因？如何防止？" class="headerlink" title="SQL 注入漏洞产生的原因？如何防止？"></a>SQL 注入漏洞产生的原因？如何防止？</h2><p>SQL 注入产生的原因：程序开发过程中不注意规范书写 sql 语句和对特殊字符进行过滤，导致客户端可<br>以通过全局变量 POST 和 GET 提交一些 sql 语句正常执行。<br>防止 SQL 注入的方式：<br>开启配置文件中的 magic_quotes_gpc 和 magic_quotes_runtime 设置 执行 sql 语句时使用<br>addslashes 进行 sql 语句转换<br>Sql 语句书写尽量不要省略双引号和单引号。<br>过滤掉 sql 语句中的一些关键词：update、insert、delete、select、 * 。<br>提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。</p>
<h2 id="MySQL当记录不存在时insert-当记录存在时update，语句怎么写？"><a href="#MySQL当记录不存在时insert-当记录存在时update，语句怎么写？" class="headerlink" title="MySQL当记录不存在时insert,当记录存在时update，语句怎么写？"></a>MySQL当记录不存在时insert,当记录存在时update，语句怎么写？</h2><p>INSERT INTO table (a,b,c) VALUES (1,2,3) ON DUPLICATE KEY UPDATE c=c+1;</p>
<h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><h2 id="varchar与char的区别以及varchar-50-中的50代表的含义"><a href="#varchar与char的区别以及varchar-50-中的50代表的含义" class="headerlink" title="varchar与char的区别以及varchar(50)中的50代表的含义"></a>varchar与char的区别以及varchar(50)中的50代表的含义</h2><p>（1） varchar与char的区别</p>
<p> 变长和固定长度</p>
<p>（2）varchar(50)中50的涵义</p>
<p> 字符最大长度50，所代表的字节数与字符集有关，比如是utf8占3个字节，那么varchar(50)字段在表中最大取到150个字节。</p>
<p> varchar(50)和(200)存储<code>hello</code>所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。</p>
<p>（3） int（20）中20的涵义</p>
<p> 是指显示字符的长度不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示</p>
<p>（4） varchar(20)和int(20)中的20含义一样吗？</p>
<p>int(M) M表示的不是数据的最大长度，只是数据宽度，并不影响存储多少位长度的数据；</p>
<p>varchar(M) M表示的是varchar类型数据在数据库中存储的最大长度，超过则不存；</p>
<h2 id="FLOAT和DOUBLE的区别是什么？"><a href="#FLOAT和DOUBLE的区别是什么？" class="headerlink" title="FLOAT和DOUBLE的区别是什么？"></a>FLOAT和DOUBLE的区别是什么？</h2><ul>
<li><p>浮点数以8位精度存储在FLOAT中，有四个字节。</p>
</li>
<li><p>浮点数以18位精度存储在DOUBLE中，有八个字节。</p>
</li>
</ul>
<h2 id="BLOB和TEXT有什么区别？"><a href="#BLOB和TEXT有什么区别？" class="headerlink" title="BLOB和TEXT有什么区别？"></a>BLOB和TEXT有什么区别？</h2><p>BLOB是一个二进制对象，可以容纳可变数量的数据。有四种类型：TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB，它们只是在所能容纳价值的最大长度上有所不同。</p>
<p>TEXT是一个不区分大小写的BLOB。有四种类型：TINYTEXT、TEXT、MEDIUMTEXT和</p>
<p>LONGTEXT。它们对应于四种BLOB类型，并具有相同的最大长度和存储要求。</p>
<p>BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。</p>
<h2 id="MySQL-中-Float、Decimal-类型存储金额的区别？"><a href="#MySQL-中-Float、Decimal-类型存储金额的区别？" class="headerlink" title="MySQL 中 Float、Decimal 类型存储金额的区别？"></a>MySQL 中 Float、Decimal 类型存储金额的区别？</h2><p>Float 是非标准数据类型，存储金额时存储的是近似值，存在精度问题；Decimal 是标准数据类型，存储金额时存储的是精确值（以字符串的形式保存数值）。</p>
<h2 id="MySQL-中-TIMESTAMP和DATETIME的区别以及选择"><a href="#MySQL-中-TIMESTAMP和DATETIME的区别以及选择" class="headerlink" title="MySQL 中 TIMESTAMP和DATETIME的区别以及选择"></a>MySQL 中 TIMESTAMP和DATETIME的区别以及选择</h2><table>
<thead>
<tr>
<th>类型</th>
<th>TIMESTAMP</th>
<th>DATETIME</th>
</tr>
</thead>
<tbody><tr>
<td>不同点</td>
<td>存储空间：TIMESTAMP占用4个字节</td>
<td>存储空间：DATETIME占用8个字节</td>
</tr>
<tr>
<td></td>
<td>时区：TIMESTAMP实际记录的是1970-01-01 00:00:01到现在的数数，受时区影响</td>
<td>时区：DATETIME不受时区影响</td>
</tr>
<tr>
<td></td>
<td>存储方式：对于TIMESTAMP，它把客户端插入的时间从当前时区转化为UTC（世界标准时间）进行存储。查询时，将其又转化为客户端当前时区进行返回(中国属于东八区，所以应该是UTC+8）。</td>
<td>存储方式：而对于DATETIME，不做任何改变，基本上是原样输入和输出。</td>
</tr>
</tbody></table>
<h3 id="对于MySQL中timestamp数据类型的特点，为什么选择timestamp类型"><a href="#对于MySQL中timestamp数据类型的特点，为什么选择timestamp类型" class="headerlink" title="对于MySQL中timestamp数据类型的特点，为什么选择timestamp类型"></a>对于MySQL中timestamp数据类型的特点，为什么选择timestamp类型</h3><p>1.存储占用 4个字节，以年月日小时分秒的日期型式显示 2.存储范围’1970-01-01 00:00:01’ to ‘2038-01-19 03:14:07’. 3.以UTC时区进行存储，但是以系统当前时间进行显示 4.可以在insert和update时把值自动更新为当前时间</p>
<h2 id="NULL-是什么意思"><a href="#NULL-是什么意思" class="headerlink" title="NULL 是什么意思"></a>NULL 是什么意思</h2><p>NULL 这个值表示 UNKNOWN(未知):它不表示“”(空字符串)。对 NULL 这个值的任何比较都会生产一个<br>NULL 值。您不能把任何值与一个 NULL 值进行比较，并在逻辑上希望获得一个答案。使用 IS NULL 来<br>进行 NULL 判断</p>
<h2 id="自增ID问题"><a href="#自增ID问题" class="headerlink" title="自增ID问题"></a>自增ID问题</h2><p>一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</p>
<ol>
<li><p>如果表的类型是MyISAM，那么是18<br>因为MyISAM表会把自增主键的最大ID记录到数据文件里，重启MySQL自增主键的最大ID也不会丢失</p>
</li>
<li><p>如果表的类型是InnoDB，那么是15<br>InnoDB表只是把自增主键的最大ID记录到内存中，所以重启数据库或者是对表进行OPTIMIZE操作，都会导致最大ID丢失</p>
</li>
</ol>
<h1 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h1><h1 id="MySQL-支持哪些存储引擎"><a href="#MySQL-支持哪些存储引擎" class="headerlink" title="MySQL 支持哪些存储引擎"></a>MySQL 支持哪些存储引擎</h1><p>MySQL 支持的存储引擎主要有四种：</p>
<ol>
<li><strong>InnoDB</strong> 支持<strong>事务</strong>，<strong>行级锁定</strong>和<strong>外键</strong>，是<strong>事务型</strong>数据库的首选引擎；MySQL5.5.5 之后的默认存储引擎；</li>
<li><strong>MyISAM</strong> 拥有较高的插入、查询速度，但<strong>不支持事务</strong>。MySQL5.5.5 之前的默认存储引擎；</li>
<li><strong>Memory</strong> 基于散列，存储在内存中，对临时表有用。常见的应用场景是：<strong>临时存放数据，数据量不大，并且不需要较高的数据安全性</strong>；</li>
<li><strong>Archive</strong> 支持<strong>高并发</strong>的插入操作，但是本身不是事务安全的。常见的应用场景：<strong>存储归档数据，如记录日志信息可以使用 Archive</strong>。</li>
</ol>
<h2 id="MySQL中哪些存储引擎支持事务？"><a href="#MySQL中哪些存储引擎支持事务？" class="headerlink" title="MySQL中哪些存储引擎支持事务？"></a>MySQL中哪些存储引擎支持事务？</h2><p>最常用的存储引擎是InnoDB引擎和MyISAM存储引擎，InnoDB是MySQL的默认事务引擎。</p>
<table>
<thead>
<tr>
<th>特性比较</th>
<th>事务</th>
<th>并发</th>
<th>外键</th>
<th>备份</th>
<th>崩溃恢复</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>InnoDB</td>
<td>事务型</td>
<td>行级锁</td>
<td>支持</td>
<td>在线热备</td>
<td>概率低</td>
<td>聚簇索引，MVCC特性</td>
</tr>
<tr>
<td>MyISAM</td>
<td>非事务性</td>
<td>行级锁</td>
<td>支持</td>
<td>不支持</td>
<td>慢，已丢失</td>
<td>压缩表，空间数据索引</td>
</tr>
</tbody></table>
<h2 id="介绍一下mysql的MVCC机："><a href="#介绍一下mysql的MVCC机：" class="headerlink" title="介绍一下mysql的MVCC机："></a>介绍一下mysql的MVCC机：</h2><p>MVCC是一种多版本并发控制机制，是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。MVCC是通过保存数据在某个时间点的快照来实现该机制，其在每行记录后面保存两个隐藏的列，分别保存这个行的创建版本号和删除版本号，然后Innodb的MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行所有快照连接起来。</p>
<h2 id="InnoDB与MyISAM的区别"><a href="#InnoDB与MyISAM的区别" class="headerlink" title="InnoDB与MyISAM的区别"></a>InnoDB与MyISAM的区别</h2><ol>
<li>事务</li>
<li>外键</li>
<li>MyISAM-非聚集索引；InnoDB-聚集索引</li>
<li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一<br>个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li>
<li>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高</li>
</ol>
<h1 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h1><p>第一范式：列不可再分<br>第二范式：行可以唯一区分，主键约束<br>第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束<br>且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上 。</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构，可以帮助我们快速的进行数据的查找</p>
<p>MySQL索引使用的数据结构主要有BTree索引 和 哈希索引 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p>
<p>MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。</p>
<ul>
<li><p>MyISAM: B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p>
<blockquote>
<p>非聚集索引 (secondary index)，又称为辅助索引、普通索引，该索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表可以包含多个非聚集索引。</p>
</blockquote>
</li>
<li><p>InnoDB: 其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。</p>
<blockquote>
<p>聚集索引 (clustered index)，又称为主索引，该索引中键值的逻辑顺序决定了表中相应行的物理顺序。因为数据真正的数据只能有一种排序方式，所以一个表上只能有一个聚簇索引。</p>
</blockquote>
</li>
</ul>
<p>聚集索引 / 非聚集索引不是一种索引类型，而是一种存储数据的方式。在 InnoDB 中它们还有一个非常重要的区别：<strong>聚集索引的叶子节点的的 data 域包含了完整的数据记录，而非聚集索引的叶子节点的 data 域记录着主键的值</strong>。</p>
<p>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
<p>在使用非聚集索引进行查找时，需要先查找到主键值，然后再到聚集索引中进行查找，这称之为回表查询。非聚簇索引不一定会回表查询</p>
<h2 id="MySQL-索引底层是什么结构？为什么采用此结构？"><a href="#MySQL-索引底层是什么结构？为什么采用此结构？" class="headerlink" title="MySQL 索引底层是什么结构？为什么采用此结构？"></a>MySQL 索引底层是什么结构？为什么采用此结构？</h2><p>mysql 底层采用 B + 树的存储结构。采用 B + 树的原因：</p>
<p>（1）索引文件很大，不能全部存储在内存中，只能存储到磁盘上，因此索引的数据结构要尽量减少查找过程中磁盘 I/O 的存取次数；</p>
<p>（2）数据库系统利用了磁盘预读原理和磁盘预读，将一个节点的大小设为等于一个页，这样每个节点只需要一次 I/O 就可以完全载入。而 B + 树的高度是 2~4，检索一次最多只需要访问 4 个节点（4 次，即树的高度）。</p>
<h2 id="为什么不适用-B-树？"><a href="#为什么不适用-B-树？" class="headerlink" title="为什么不适用 B 树？"></a>为什么不适用 B 树？</h2><p>B + 树所有的 Data 域在叶子节点，其余节点用来索引，</p>
<p><img src="file:///E:/YouDaoYun/m18739288920@163.com/8dbe6e2d4f1e489d86f88afbbeda5c9b/xtnpu3ir.bmp?ynotemdtimestamp=1618651314817" alt="image"></p>
<p>而 B 树是每个索引节点都会有 Data 域；</p>
<p><img src="file:///E:/YouDaoYun/m18739288920@163.com/3b1a0be34dfa49e2a7dced52699dbd92/ygkj4yk5.bmp?ynotemdtimestamp=1618651314817" alt="image"></p>
<p>并且 B + 树所有叶子节点之间都有一个链指针。</p>
<p>这样遍历叶子节点就能获得全部数据，从而支持区分查询。在数据库中基于范围的查询是非常频繁的，而 B 树不支持这样的遍历操作。</p>
<h2 id="为什么不用哈希表？"><a href="#为什么不用哈希表？" class="headerlink" title="为什么不用哈希表？"></a>为什么不用哈希表？</h2><p>（1）哈希表只适用与查找等值查询， 不能支持区分条件（大于小于查询）、模糊查询等；</p>
<p>（2）hash 索引虽然在等值查询上较快，但是不稳定，性能不可预测，当某个键值存在大量重复的时候，发生 hash 碰撞，此时效率可能极差。而 B + 树的查询效率比较稳定。</p>
<h2 id="为什么不用红黑树？"><a href="#为什么不用红黑树？" class="headerlink" title="为什么不用红黑树？"></a>为什么不用红黑树？</h2><p>红黑树往往高度过大，从页造成磁盘 IO 读写过于频繁，效率低下。而且逻辑上很近的节点（父子）物理上可能很远，无法利用局部性原理。</p>
<h2 id="Hash索引和B-树所有有什么区别或者说优劣呢"><a href="#Hash索引和B-树所有有什么区别或者说优劣呢" class="headerlink" title="Hash索引和B+树所有有什么区别或者说优劣呢?"></a>Hash索引和B+树所有有什么区别或者说优劣呢?</h2><p>首先要知道Hash索引和B+树索引的底层实现原理:</p>
<p>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据；B+树底层实现是多路平衡查找树，对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据.。</p>
<p>那么可以看出他们有以下的不同:</p>
<p>1、hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询.</p>
<p>因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</p>
<p>2、hash索引不支持使用索引进行排序，原理同上；</p>
<p>3、hash索引不支持模糊查询以及多列索引的最左前缀匹配，原理也是因为hash函数的不可预测.AAAA和AAAAB的索引没有相关性；</p>
<p>4、hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询；</p>
<p>5、hash索引虽然在等值查询上较快,但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</p>
<p>因此在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度，而不需要使用hash索引。</p>
<h2 id="MySQL-支持的索引类型是哪些？"><a href="#MySQL-支持的索引类型是哪些？" class="headerlink" title="MySQL 支持的索引类型是哪些？"></a>MySQL 支持的索引类型是哪些？</h2><ol>
<li>普通索引：用表中的普通列构建的索引，没有任何限制；</li>
<li>唯一索引：唯一索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的合必须唯一；</li>
<li>主键索引：是一种特殊的唯一索引，根据主键建立索引，不允许重复，不允许空值；</li>
<li>全文索引：通过过建立倒排索引，快速匹配文档的方式。MySQL 5.7.6 之前仅支持英文，MySQL 5.7.6 之后支持中文；</li>
<li>组合索引：又叫联合索引。用多个列组合构建的索引，这多个列中的值不允许有空值。可以在创建表的时候指定，也可以修改表结构。</li>
</ol>
<h2 id="建立索引的原则有哪些？"><a href="#建立索引的原则有哪些？" class="headerlink" title="建立索引的原则有哪些？"></a>建立索引的原则有哪些？</h2><p>在经常需要搜索的列上，可以加快搜索的速度；</p>
<p>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p>
<p>在经常需要排序的列上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</p>
<p>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</p>
<p>在经常用在连接的列上，这 些列主要是一些外键，可以加快连接的速度；</p>
<p>避免 where 子句中对字段施加函数，这会造成无法命中索引。</p>
<p>在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</p>
<p>将某一列设置为default null，where 是可以走索引，另外索引列是否设置 null 是不影响性能的。 但是，还是不建议列上允许为空。最好限制not null，因为null需要更多的存储空间并且null值无法参与某些运算。</p>
<p>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 chema_unused_indexes 视图来查询哪些索引从未被使用</p>
<p>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</p>
<h2 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h2><p>MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name&#x3D;xx and city&#x3D;xx ; ／／可以命中索引</span><br><span class="line">select * from user where name&#x3D;xx ; &#x2F;&#x2F; 可以命中索引</span><br><span class="line">select * from user where city&#x3D;xx ; &#x2F;&#x2F; 无法命中索引            </span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 city= xx and name ＝xx，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。</p>
<p>由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDER BY子句也遵循此规则。</p>
<h2 id="索引建立越多越好吗"><a href="#索引建立越多越好吗" class="headerlink" title="索引建立越多越好吗?"></a>索引建立越多越好吗?</h2><p>索引并不是越多越好！索引可以提高效率同样可以降低效率。</p>
<p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p>
<p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p>
<h2 id="索引这么多优点，为什么不对表中的每一个列创建一个索引呢？"><a href="#索引这么多优点，为什么不对表中的每一个列创建一个索引呢？" class="headerlink" title="索引这么多优点，为什么不对表中的每一个列创建一个索引呢？"></a>索引这么多优点，为什么不对表中的每一个列创建一个索引呢？</h2><ol>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
</ol>
<h2 id="索引什么时候会失效？"><a href="#索引什么时候会失效？" class="headerlink" title="索引什么时候会失效？"></a>索引什么时候会失效？</h2><p>（1）条件中有 or；</p>
<p>（2）like 查询（以 % 开头）；</p>
<p>（3）如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不使用索引；</p>
<p>（4）对列进行函数运算（如 where md5 (password) = “xxxx”）；</p>
<p>（5）负向查询条件会导致无法使用索引，比如 NOT IN,NOT LIKE,!= 等；</p>
<p>（6）对于联合索引，不是使用的第一部分 (第一个)，则不会使用索引（最左匹配）；</p>
<p>（7）如果 mysql 评估使用全表扫描要比使用索引快，则不使用索引；</p>
<h3 id="索引追问"><a href="#索引追问" class="headerlink" title="索引追问"></a>索引追问</h3><p>表 A 建立了 INDEX (col1,col2,col3) 的联合索引，where 条件中使用 col1 = a1 and col3=c1 索引是否有效？</p>
<p>索引有效。</p>
<h4 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h4><p>联合索引的最左前缀匹配原则，顾名思义，它是指在检索数据时从联合索引的最左边开始匹配。如果你创建一个了联合索引 (col1, col2, col3)，那么该索引的任何前缀都会用于查询，即 (col1), (col1, col2), (col1, col2, col3) 都会使用索引查询。</p>
<p>其实最左匹配原则也是和 B + 树的结构相关，比如使用 (col1, col2, col3) 上述索引，B + 树是按照从左到右的顺序来建立搜索树的，比如当检索 (‘a1’,‘b1’,‘c1’) 时，B + 树会优先比较’a1’再来确定下一步的搜索方向，如果 col1 相同再依次比较 col2 和 col3，最后得到检索的数据；但当检索 (‘b1’,‘c1’) 这样的没有 col1 的数据时，B + 树就不知道第一步该查哪个节点，所以不能使用索引。而当检索 (‘a1’,‘c1’) 时，B + 树可以用 col1 来指定搜索方向，即使下一个字段 col2 缺失，也能把所有 col1=’a1’的数据找出来，然后再匹配 col3=’c1’数据。</p>
<h2 id="索引有什么缺点？"><a href="#索引有什么缺点？" class="headerlink" title="索引有什么缺点？"></a>索引有什么缺点？</h2><p>（1）索引需要额外的占用物理空间，索引越多，所以空间越多；</p>
<p>（2）当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的写入速度；</p>
<h2 id="使用索引查询一定能提高查询的性能吗？为什么"><a href="#使用索引查询一定能提高查询的性能吗？为什么" class="headerlink" title="使用索引查询一定能提高查询的性能吗？为什么"></a>使用索引查询一定能提高查询的性能吗？为什么</h2><p>通常,通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价.</p>
<p>索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况:</p>
<ul>
<li>基于一个范围的检索,一般查询返回结果集小于表中记录数的30%</li>
<li>基于非唯一性索引的检索</li>
</ul>
<h2 id="为什么索引能提高查询速度"><a href="#为什么索引能提高查询速度" class="headerlink" title="为什么索引能提高查询速度"></a>为什么索引能提高查询速度</h2><p>MySQL的基本存储结构是页(记录都存在页里边)</p>
<p>各个数据页可以组成一个双向链表</p>
<p>每个数据页中的记录又可以组成一个单向链表</p>
<p>如果不用索引：定位到记录所在的页：需要遍历双向链表，找到所在的页，从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。</p>
<h2 id="事务是如何通过日志来实现的，说得越深入越好"><a href="#事务是如何通过日志来实现的，说得越深入越好" class="headerlink" title="事务是如何通过日志来实现的，说得越深入越好"></a>事务是如何通过日志来实现的，说得越深入越好</h2><p>因为事务在修改页时，要先记 undo，在记 undo之前要记 undo 的 redo， 然后修改数据页，再记数据页修改的 redo。redo（里面包括 undo 的修改） 一定要比数据页先持久化到磁盘。当事务需要回滚时，因为有 undo，可以把数据页回滚到前镜像的状态；崩溃恢复时，如果 redo log 中事务没有对应的 commit 记录，那么需要用 undo把该事务的修改回滚到事务开始之前。如果有 commit 记录，就用 redo 前滚到该事务完成时并提交掉。</p>
<h2 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a>事务有哪些特性？</h2><p>1、原子性（Atomicity）：事务是一个不可分割的单位，事务中的所有SQL等操作要么都发生，要么都不发生。</p>
<p>2、一致性（Consistency）：事务发生前和发生后，数据的完整性必须保持一致。</p>
<p>3、隔离性（Isolation）：当并发访问数据库时，一个正在执行的事务在执行完毕前，对应其他的会话是不可见的，多个并发事务之间的数据是相互隔离的。备份的参数 –single-transaction</p>
<p>4、持久性（Durability）：一个事务一旦被提交，它对数据库中的数据改变就是永久性的。如果出了错误，事务也不允许撤销，只能通过“补偿性事务”。</p>
<p>MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？</p>
<p>InnoDB是基于索引来完成行锁。</p>
<p>例如在<code>select * from tab_with_index where id = 1 for update</code>中。for update 可以根据条件来完成行锁锁定,并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起。</p>
<h2 id="并发事务带来哪些问题"><a href="#并发事务带来哪些问题" class="headerlink" title="并发事务带来哪些问题?"></a>并发事务带来哪些问题?</h2><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一<br>数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>
<p><strong>脏读（Dirty read）</strong>: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据<br>库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数<br>据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p>
<p><strong>丢失修改（Lost to modify）</strong>: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在<br>第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢<br>失，因此称为丢失修。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，<br>事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</p>
<p><strong>不可重复读（Unrepeatableread）</strong>: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另<br>一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个<br>事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称<br>为不可重复读。</p>
<p><strong>幻读（Phantom read）</strong>: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另<br>一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不<br>存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
<p><strong>不可重复读和幻读区别</strong>：<br>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者<br>删除比如多次读取一条记录发现记录增多或减少了</p>
<h2 id="详述一下数据库事务隔离的四个级别"><a href="#详述一下数据库事务隔离的四个级别" class="headerlink" title="详述一下数据库事务隔离的四个级别"></a>详述一下数据库事务隔离的四个级别</h2><blockquote>
<p>MySQL 的默认事务处理级别是可重复读，Oracle 的默认事务处理级别是读提交。</p>
</blockquote>
<p>（1）Read Uncommitted（<strong>读未提交</strong>）：事务可以看到其他<strong>未提交事务</strong>的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。而且可能出现<strong>脏读</strong>（Dirty Read），即<strong>一个事务读取到另一个事务还有没提交的记录</strong>。</p>
<p>（2） Read Committed（<strong>读提交</strong>） ：事务只能看见<strong>已经提交的事务</strong>所做的改变。这种隔离级别可能导致<strong>不可重复读</strong>（Nonrepeatable Read），<strong>即同一事务的其他实例在该实例处理其间可能会有新的 commit，所以同一个查询操作执行两次或多次的结果不一致</strong>。</p>
<p>（3）Repeatable Read（<strong>可重复读</strong>） ， <strong>事务的多个实例在并发读取数据时读到同样的数据行</strong>。不过理论上，这会导致另一个棘手的问题：<strong>幻读</strong>（PhantomRead），它是指<strong>当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的 “幻影” 数据</strong>。</p>
<p>（4）Serializable（<strong>串行化</strong>） ：通过强制<strong>事务排序</strong>，使之不可能相互冲突，从而解决幻读问题。简言之，它是在<strong>每个读的数据行上加上共享锁</strong>。在这个级别，可能导致<strong>大量的超时现象和锁竞争</strong>。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻影读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED（<strong>读未提交</strong>）</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED（<strong>读提交</strong>）</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ（<strong>可重复读</strong>）</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE（<strong>串行化</strong>）</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p>
<h3 id="不可重复度和幻读区别："><a href="#不可重复度和幻读区别：" class="headerlink" title="不可重复度和幻读区别："></a>不可重复度和幻读区别：</h3><p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>
<p>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。</p>
<p>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。 </p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>redo log 是 InnoDB 引擎特有的；</p>
<p>binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</p>
<hr>
<p><strong>区别</strong></p>
<ul>
<li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；</li>
<li>binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</li>
<li>redo log 是循环写的，空间固定会用完；</li>
<li>binlog 是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
<li>redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit =1表示每次事务的redo log</li>
<li>都持久化到磁盘，保证mysql异常重启之后数据不丢失。Sync_binlog=1参数设置为1，表示每次事务的binlog都持久化到磁盘，保证mysql异常重启之后binlog不丢失。</li>
</ul>
<h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><p>解释一下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?</p>
<p>这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，<strong>在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果使用了所有连接，则会建立一个新连接并将其添加到池中</strong></p>
<h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><ul>
<li>主：129<ul>
<li>从：131</li>
</ul>
</li>
</ul>
<h2 id="主从配置1"><a href="#主从配置1" class="headerlink" title="主从配置1"></a>主从配置1</h2><ul>
<li>主配置log-bin，指定文件的名字</li>
<li>主配置server-id 默认为1</li>
<li>从配置server-id 与主不能重复</li>
</ul>
<h3 id="主配置"><a href="#主配置" class="headerlink" title="主配置"></a>主配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">...</span><br><span class="line">log-bin=my_mysql</span><br><span class="line">server-id=1</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>

<h3 id="从配置"><a href="#从配置" class="headerlink" title="从配置"></a>从配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">...</span><br><span class="line">server-id=2</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>

<h2 id="主从配置2"><a href="#主从配置2" class="headerlink" title="主从配置2"></a>主从配置2</h2><ul>
<li>主创建备份账户并授权REPLICATION SLAVE</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CREATE USER <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;12345&#x27;</span>;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> GRANT REPLICATION SLAVE ON *.* TO <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> flush privileges;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>主进行行锁表FLUSH TABLE WITH READ LOCK；（主从同步的时间内阻塞所有写入操作）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> FLUSH TABLES WITH READ LOCK;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>主 找到log-bin的位置 SHOW MASTER STATUS；</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; SHOW MASTER STATUS;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File            | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+-----------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| my_mysql.000001 |      849 |              |                  |                   |</span><br><span class="line">+-----------------+----------+--------------+------------------+-------------------+</span><br></pre></td></tr></table></figure>

<ul>
<li>主备份数据</li>
</ul>
<blockquote>
<p>需要新建会话，不能再mysql客户端运行，也不能exit，因为正在锁表</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump --all-databases --master-data &gt; dbdump.db -uroot -p</span><br></pre></td></tr></table></figure>

<ul>
<li>把主上的dbdump.db拷贝至从</li>
</ul>
<blockquote>
<p>在从节点上进行操作</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp root@192.168.159.129:/opt/dbdump.db .</span><br><span class="line">mysql &lt; dbdump.db -uroot -p</span><br></pre></td></tr></table></figure>

<ul>
<li>放开主上的锁表</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> UNLOCK TABLES;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在从上设置住的配置</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CHANGE MASTER TO</span></span><br><span class="line"><span class="meta">	-&gt;</span><span class="bash"> MASTER_HOST=<span class="string">&#x27;master_host_name&#x27;</span>,</span> 	</span><br><span class="line"><span class="meta">	-&gt;</span><span class="bash"> MASTER_PORT=port_num</span> </span><br><span class="line"><span class="meta">	-&gt;</span><span class="bash"> MASTER_USER=<span class="string">&#x27;replication_user_name&#x27;</span>,</span> </span><br><span class="line"><span class="meta">	-&gt;</span><span class="bash"> MASTER_PASSWORD=<span class="string">&#x27;replication_password&#x27;</span>,</span> 			        </span><br><span class="line"><span class="meta">	-&gt;</span><span class="bash"> MASTER_LOG_FILE=<span class="string">&#x27;recorded_log_file_name&#x27;</span>,</span>			   </span><br><span class="line">    -&gt; MASTER_LOG_POS=recorded_log_position;</span><br></pre></td></tr></table></figure>

<ul>
<li>从执行START SLAVE</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> START SLAVE;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show slave status;</span></span><br></pre></td></tr></table></figure>



<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>在MySQL主从复制架构中，读操作可以在所有的服务器上面进行，而写操作只能在主服务器上面进行。主从复制架构虽然给读操作提供了扩展，可如果写操作也比较多的话（多台从服务器还要从主服务器上面同步数据），单主模型的复制中主服务器势必会成为性能瓶颈。</p>
<ol>
<li>基于记录的复制：主服务器上面执行的语句在从服务器上面再执行一遍，在MySQL-3.23版本以后支持。</li>
</ol>
<ul>
<li>存在的问题：时间上可能不完全同步造成偏差，执行语句的用户也可能是不同一个用户</li>
</ul>
<ol>
<li>基于语句的复制：把主服务器上面改编后的内容直接复制过去，而不关心到底改变该内容是由哪条语句引发的，在MySQL-5.0版本以后引入。</li>
</ol>
<ul>
<li>存在的问题：比如一个工资表中有一万个用户，我们把每个用户的工资+1000，那么基于行的复制则要复制一万行的内容，由此造成的开销比较大，而基于语句的复制仅仅一条语句就可以了。</li>
</ul>
<h2 id="复制过程："><a href="#复制过程：" class="headerlink" title="复制过程："></a>复制过程：</h2><ol>
<li>在每个事务更新数据完成之前，master在二进制日志记录这些改变。写入二进制日志完成后，master通知存储引擎提交事务。</li>
<li>Slave将master的binary log复制到其中继日志。首先slave开始一个工作线程（I/O），I/O线程在master上打开一个普通的连接，然后开始binlog dump process。binlog dump process从master的二进制日志中读取事件，如果已经跟上master，它会睡眠并等待master产生新的事件，I/O线程将这些事件写入中继日志。</li>
<li>Sql slave thread（sql从线程）处理该过程的最后一步，sql线程从中继日志读取事件，并重放其中的事件而更新slave数据，使其与master中的数据一致，只要该线程与I/O线程保持一致，中继日志通常会位于os缓存中，所以中继日志的开销很小。</li>
</ol>
<h2 id="分库分表之后-id-主键如何处理"><a href="#分库分表之后-id-主键如何处理" class="headerlink" title="分库分表之后,id 主键如何处理"></a>分库分表之后,id 主键如何处理</h2><p>因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来<br>支持。<br>生成全局 id 有下面这几种方式：<br><strong>UUID</strong>：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字<br>的标示比如文件的名字。<br><strong>数据库自增 id</strong> : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id<br>有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。<br><strong>利用 redis 生成 id</strong> : 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复<br>杂，可用性降低，编码更加复杂，增加了系统成本。<br><strong>Twitter的snowflake算法</strong> ：Github 地址：<a target="_blank" rel="noopener" href="https://github.com/twitter-archive/snowflake%E3%80%82">https://github.com/twitter-archive/snowflake。</a><br>**美团的Leaf分布式ID生成系统 **：Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、<br>单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等<br>中间件。感觉还不错。美团技术团队的一篇文章：<a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/04/21/mt-leaf.ht">https://tech.meituan.com/2017/04/21/mt-leaf.ht</a><br>ml</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="MySQL-中有哪几种锁？"><a href="#MySQL-中有哪几种锁？" class="headerlink" title="MySQL 中有哪几种锁？"></a>MySQL 中有哪几种锁？</h2><p>1、表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。<br>2、行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<br>3、页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发<br>度一般</p>
<h2 id="锁的优化策略"><a href="#锁的优化策略" class="headerlink" title="锁的优化策略"></a>锁的优化策略</h2><p>1、读写分离<br>2、分段加锁<br>3、减少锁持有的时间<br>4.多个线程尽量以相同的顺序去获取资源不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放<br>次数过多，反而效率不如一次加一把大锁。</p>
<h1 id="优化数据库"><a href="#优化数据库" class="headerlink" title="优化数据库"></a>优化数据库</h1><p>最好是按照以下顺序优化：<br>1、SQL 语句及索引的优化<br>2、数据库表结构的优化<br>3、系统配置的优化<br>4、硬件的优化</p>
<hr>
<p>1、选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置 NOTNULL，例如’省份’、’性<br>别’最好适用 ENUM<br>2、使用连接(JOIN)来代替子查询<br>3、适用联合(UNION)来代替手动创建的临时表<br>4、事务处理<br>5、锁定表、优化事务处理<br>6、适用外键，优化锁定表<br>7、建立索引<br>8、优化查询语句</p>
<h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><p>1、查询语句中不要使用select *<br>2、尽量减少子查询，使用关联查询（left join,right join,inner join）替代<br>3、减少使用IN或者NOT IN ,使用exists，not exists或者关联查询语句替代<br>4、or 的查询尽量用 union或者union all 代替(在确认没有重复数据或者不用剔除重复数据时，union<br>all会更好)<br>5、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。<br>6、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫<br>描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null<br>值，然后这样查询： select id from t where num=0</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 数据库</a>
          
            <a href="/tags/MySQL/" rel="tag"># MySQL</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/04/16/%E4%B8%AD%E9%97%B4%E4%BB%B6-elasticsearch%E5%AD%A6%E4%B9%A0/" rel="next" title="中间件-elasticsearch基础概念学习">
                <i class="fa fa-chevron-left"></i> 中间件-elasticsearch基础概念学习
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/04/17/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85-rabbitmq%E5%AE%89%E8%A3%85/" rel="prev" title="软件安装-rabbitmq安装">
                软件安装-rabbitmq安装 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <!--<a href="/archives/%7C%7Carchive">-->
                <a href="/archives/">
              
                  <span class="site-state-item-count">80</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuanyayuan" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:liyuan0707@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#SQL%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.</span> <span class="nav-text">SQL语句</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E5%9C%A8MySQL%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="nav-number">1.1.</span> <span class="nav-text">一条SQL语句在MySQL中如何执行的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SELECT-%E5%92%8C-SELECT-%E5%85%A8%E9%83%A8%E5%AD%97%E6%AE%B5%E4%B8%A4%E7%A7%8D%E5%86%99%E6%B3%95%E6%9C%89%E4%BD%95%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.2.</span> <span class="nav-text">SELECT * 和 SELECT 全部字段两种写法有何优缺点?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E8%AF%B4drop%E3%80%81delete%E4%B8%8Etruncate%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.3.</span> <span class="nav-text">简单说一说drop、delete与truncate的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LiKE%E5%A3%B0%E6%98%8E%E4%B8%AD%E7%9A%84%EF%BC%85%E5%92%8C-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="nav-number">1.4.</span> <span class="nav-text">LiKE声明中的％和_是什么意思？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HAVNG-%E5%AD%90%E5%8F%A5-%E5%92%8C-WHERE-%E7%9A%84%E5%BC%82%E5%90%8C%E7%82%B9"><span class="nav-number">1.5.</span> <span class="nav-text">HAVNG 子句 和 WHERE 的异同点?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA-SQL-%E6%89%A7%E8%A1%8C%E7%9A%84%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.6.</span> <span class="nav-text">一个 SQL 执行的很慢的原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E8%81%94%E6%8E%A5%E3%80%81%E5%B7%A6%E5%A4%96%E8%81%94%E6%8E%A5%E3%80%81%E5%8F%B3%E5%A4%96%E8%81%94%E6%8E%A5%EF%BC%9F"><span class="nav-number">1.7.</span> <span class="nav-text">什么是内联接、左外联接、右外联接？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%9A%E7%94%A8-SQL-%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-number">1.8.</span> <span class="nav-text">什么是通用 SQL 函数？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL-%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%EF%BC%9F"><span class="nav-number">1.9.</span> <span class="nav-text">SQL 注入漏洞产生的原因？如何防止？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E5%BD%93%E8%AE%B0%E5%BD%95%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%97%B6insert-%E5%BD%93%E8%AE%B0%E5%BD%95%E5%AD%98%E5%9C%A8%E6%97%B6update%EF%BC%8C%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E5%86%99%EF%BC%9F"><span class="nav-number">1.10.</span> <span class="nav-text">MySQL当记录不存在时insert,当记录存在时update，语句怎么写？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5"><span class="nav-number">2.</span> <span class="nav-text">字段</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#varchar%E4%B8%8Echar%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8Avarchar-50-%E4%B8%AD%E7%9A%8450%E4%BB%A3%E8%A1%A8%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-number">2.1.</span> <span class="nav-text">varchar与char的区别以及varchar(50)中的50代表的含义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FLOAT%E5%92%8CDOUBLE%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.2.</span> <span class="nav-text">FLOAT和DOUBLE的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BLOB%E5%92%8CTEXT%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.3.</span> <span class="nav-text">BLOB和TEXT有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E4%B8%AD-Float%E3%80%81Decimal-%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8%E9%87%91%E9%A2%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.4.</span> <span class="nav-text">MySQL 中 Float、Decimal 类型存储金额的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E4%B8%AD-TIMESTAMP%E5%92%8CDATETIME%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E9%80%89%E6%8B%A9"><span class="nav-number">2.5.</span> <span class="nav-text">MySQL 中 TIMESTAMP和DATETIME的区别以及选择</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8EMySQL%E4%B8%ADtimestamp%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9timestamp%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.5.1.</span> <span class="nav-text">对于MySQL中timestamp数据类型的特点，为什么选择timestamp类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NULL-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="nav-number">2.6.</span> <span class="nav-text">NULL 是什么意思</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%A2%9EID%E9%97%AE%E9%A2%98"><span class="nav-number">2.7.</span> <span class="nav-text">自增ID问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%95%E6%93%8E"><span class="nav-number">3.</span> <span class="nav-text">引擎</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">4.</span> <span class="nav-text">MySQL 支持哪些存储引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%94%AF%E6%8C%81%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="nav-number">4.1.</span> <span class="nav-text">MySQL中哪些存储引擎支持事务？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bmysql%E7%9A%84MVCC%E6%9C%BA%EF%BC%9A"><span class="nav-number">4.2.</span> <span class="nav-text">介绍一下mysql的MVCC机：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB%E4%B8%8EMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.</span> <span class="nav-text">InnoDB与MyISAM的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%8C%83%E5%BC%8F"><span class="nav-number">5.</span> <span class="nav-text">范式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">6.</span> <span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%98%AF%E4%BB%80%E4%B9%88%E7%BB%93%E6%9E%84%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8%E6%AD%A4%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="nav-number">6.1.</span> <span class="nav-text">MySQL 索引底层是什么结构？为什么采用此结构？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%80%82%E7%94%A8-B-%E6%A0%91%EF%BC%9F"><span class="nav-number">6.2.</span> <span class="nav-text">为什么不适用 B 树？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%9F"><span class="nav-number">6.3.</span> <span class="nav-text">为什么不用哈希表？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="nav-number">6.4.</span> <span class="nav-text">为什么不用红黑树？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash%E7%B4%A2%E5%BC%95%E5%92%8CB-%E6%A0%91%E6%89%80%E6%9C%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E6%88%96%E8%80%85%E8%AF%B4%E4%BC%98%E5%8A%A3%E5%91%A2"><span class="nav-number">6.5.</span> <span class="nav-text">Hash索引和B+树所有有什么区别或者说优劣呢?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E6%94%AF%E6%8C%81%E7%9A%84%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">6.6.</span> <span class="nav-text">MySQL 支持的索引类型是哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E5%88%99%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">6.7.</span> <span class="nav-text">建立索引的原则有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="nav-number">6.8.</span> <span class="nav-text">最左匹配原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%BB%BA%E7%AB%8B%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD%E5%90%97"><span class="nav-number">6.9.</span> <span class="nav-text">索引建立越多越好吗?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%BF%99%E4%B9%88%E5%A4%9A%E4%BC%98%E7%82%B9%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AF%B9%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%88%97%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95%E5%91%A2%EF%BC%9F"><span class="nav-number">6.10.</span> <span class="nav-text">索引这么多优点，为什么不对表中的每一个列创建一个索引呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="nav-number">6.11.</span> <span class="nav-text">索引什么时候会失效？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%BF%BD%E9%97%AE"><span class="nav-number">6.11.1.</span> <span class="nav-text">索引追问</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%82%B9%E8%AF%84"><span class="nav-number">6.11.1.1.</span> <span class="nav-text">点评</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">6.12.</span> <span class="nav-text">索引有什么缺点？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%E4%B8%80%E5%AE%9A%E8%83%BD%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%80%A7%E8%83%BD%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-number">6.13.</span> <span class="nav-text">使用索引查询一定能提高查询的性能吗？为什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B4%A2%E5%BC%95%E8%83%BD%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6"><span class="nav-number">6.14.</span> <span class="nav-text">为什么索引能提高查询速度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">7.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E6%97%A5%E5%BF%97%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E8%AF%B4%E5%BE%97%E8%B6%8A%E6%B7%B1%E5%85%A5%E8%B6%8A%E5%A5%BD"><span class="nav-number">7.1.</span> <span class="nav-text">事务是如何通过日志来实现的，说得越深入越好</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="nav-number">7.2.</span> <span class="nav-text">事务有哪些特性？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="nav-number">7.3.</span> <span class="nav-text">并发事务带来哪些问题?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%A6%E8%BF%B0%E4%B8%80%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%BA%A7%E5%88%AB"><span class="nav-number">7.4.</span> <span class="nav-text">详述一下数据库事务隔离的四个级别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E5%BA%A6%E5%92%8C%E5%B9%BB%E8%AF%BB%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">7.4.1.</span> <span class="nav-text">不可重复度和幻读区别：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%A5%E5%BF%97"><span class="nav-number">8.</span> <span class="nav-text">日志</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="nav-number">9.</span> <span class="nav-text">数据库连接池</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="nav-number">10.</span> <span class="nav-text">分库分表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE1"><span class="nav-number">10.1.</span> <span class="nav-text">主从配置1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E9%85%8D%E7%BD%AE"><span class="nav-number">10.1.1.</span> <span class="nav-text">主配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E9%85%8D%E7%BD%AE"><span class="nav-number">10.1.2.</span> <span class="nav-text">从配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE2"><span class="nav-number">10.2.</span> <span class="nav-text">主从配置2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">10.3.</span> <span class="nav-text">主从复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="nav-number">10.4.</span> <span class="nav-text">复制过程：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%90%8E-id-%E4%B8%BB%E9%94%AE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="nav-number">10.5.</span> <span class="nav-text">分库分表之后,id 主键如何处理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">11.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E4%B8%AD%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%94%81%EF%BC%9F"><span class="nav-number">11.1.</span> <span class="nav-text">MySQL 中有哪几种锁？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="nav-number">11.2.</span> <span class="nav-text">锁的优化策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">12.</span> <span class="nav-text">优化数据库</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SQL%E4%BC%98%E5%8C%96"><span class="nav-number">13.</span> <span class="nav-text">SQL优化</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LiYuan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
