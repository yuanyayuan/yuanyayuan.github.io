<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="java,面试,Java基础知识," />










<meta name="description" content="Java 集合框架集合概述Java 集合概览从下图可以看出，在 Java 中除了以 Map 结尾的类之外， 其他类都实现了 Collection 接口。 并且，以 Map 结尾的类都实现了 Map 接口。  Collections类是什么Java.util.Collections是一个工具类仅包含静态方法，它们操作或返回集合。它包含操作集合的多态算法，返回一个由指定集合支持的新集合和其它一些内容。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java集合框架">
<meta property="og:url" content="https://yuanyayuan.github.io/2021/04/13/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/index.html">
<meta property="og:site_name" content="Hikari的Java之路">
<meta property="og:description" content="Java 集合框架集合概述Java 集合概览从下图可以看出，在 Java 中除了以 Map 结尾的类之外， 其他类都实现了 Collection 接口。 并且，以 Map 结尾的类都实现了 Map 接口。  Collections类是什么Java.util.Collections是一个工具类仅包含静态方法，它们操作或返回集合。它包含操作集合的多态算法，返回一个由指定集合支持的新集合和其它一些内容。">
<meta property="og:locale">
<meta property="og:image" content="https://snailclimb.gitee.io/javaguide/docs/java/collection/images/Java-Collections.jpeg">
<meta property="og:image" content="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/%E5%AE%B9%E5%99%A8/image2.png">
<meta property="og:image" content="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/%E5%AE%B9%E5%99%A8/arrayList1.png">
<meta property="og:image" content="https://img1.sycdn.imooc.com/5e6af08a00013e4c16000500.jpg">
<meta property="og:image" content="https://snailclimb.gitee.io/javaguide/docs/java/collection/images/TreeMap继承结构.png">
<meta property="og:image" content="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/%E5%AE%B9%E5%99%A8/image.png">
<meta property="article:published_time" content="2021-04-13T10:47:40.000Z">
<meta property="article:modified_time" content="2021-04-14T13:40:04.099Z">
<meta property="article:author" content="LiYuan">
<meta property="article:tag" content="java">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="Java基础知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://snailclimb.gitee.io/javaguide/docs/java/collection/images/Java-Collections.jpeg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yuanyayuan.github.io/2021/04/13/Java集合框架/"/>





  <title>Java集合框架 | Hikari的Java之路</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hikari的Java之路</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Hello,world</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuanyayuan.github.io/2021/04/13/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hikari的Java之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java集合框架</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-13T18:47:40+08:00">
                2021-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础 - Java知识点</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80-Java%E7%9F%A5%E8%AF%86%E7%82%B9/Java%E5%9F%BA%E7%A1%80-Java%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础 - Java容器</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Java-集合框架"><a href="#Java-集合框架" class="headerlink" title="Java 集合框架"></a>Java 集合框架</h1><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><h3 id="Java-集合概览"><a href="#Java-集合概览" class="headerlink" title="Java 集合概览"></a>Java 集合概览</h3><p>从下图可以看出，在 Java 中除了以 <code>Map</code> 结尾的类之外， 其他类都实现了 <code>Collection</code> 接口。</p>
<p>并且，以 <code>Map</code> 结尾的类都实现了 <code>Map</code> 接口。</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/collection/images/Java-Collections.jpeg" alt="img"></p>
<h3 id="Collections类是什么"><a href="#Collections类是什么" class="headerlink" title="Collections类是什么"></a>Collections类是什么</h3><p>Java.util.Collections是一个工具类仅包含静态方法，它们操作或返回集合。它包含操作集合的多态算法，返回一个由指定集合支持的新集合和其它一些内容。这个类包含集合框架算法的方法，比如折半搜索、排序、混编和逆序等。</p>
<h3 id="说说-List-Set-Map-三者的区别？"><a href="#说说-List-Set-Map-三者的区别？" class="headerlink" title="说说 List,Set,Map 三者的区别？"></a>说说 List,Set,Map 三者的区别？</h3><ul>
<li><code>List</code>(对付顺序的好帮手)： 存储的元素是有序的、可重复的。</li>
<li><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li>
<li><code>Map</code>(用 Key 来搜索的专家): 使用键值对（kye-value）存储，类似于数学上的函数 y=f(x)，“x”代表 key，”y”代表 value，Key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>
</ul>
<h3 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h3><p>先来看一下 <code>Collection</code> 接口下面的集合。</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul>
<li><code>Arraylist</code>： <code>Object[]</code>数组</li>
<li><code>Vector</code>：<code>Object[]</code>数组</li>
<li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>
</ul>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul>
<li><code>HashSet</code>（无序，唯一）: 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li>
<li><code>LinkedHashSet</code>：<code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li>
<li><code>TreeSet</code>（有序，唯一）： 红黑树(自平衡的排序二叉树)</li>
</ul>
<p>再来看看 <code>Map</code> 接口下面的集合。</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul>
<li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8  以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于  64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>
<li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li>
</ul>
<h3 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合?"></a>如何选用集合?</h3><p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>,不需要排序时就选择 <code>HashMap</code>,需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</p>
<p>当我们只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</p>
<h3 id="为什么要使用集合？"><a href="#为什么要使用集合？" class="headerlink" title="为什么要使用集合？"></a>为什么要使用集合？</h3><p>当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端， 因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。</p>
<p>数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。 但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。</p>
<h3 id="List、Set、Map-之间的区别是什么"><a href="#List、Set、Map-之间的区别是什么" class="headerlink" title="List、Set、Map 之间的区别是什么"></a>List、Set、Map 之间的区别是什么</h3><ul>
<li>List 是有序集合，可以有重复元素；<ul>
<li>Set 里面不允许有重复的元素，这里的重复是指两个相等 (注意不是相同) 的对象 ，即 equals () 返回 true。如果 Set 集合 s 中有 A 元素，现在再向 s 集合插入 B 元素，此时 B 元素如果与 A 元素相等，则 B 元素存储不进去（add 方法返回 false）。</li>
</ul>
</li>
<li>Set 集合不能包括重复元素，实现类中 LinkedHashSet 按照插入顺序排序，SortedSet 可排序，HashSet 无序；</li>
<li>Map 存放键值对 (key-value pairs) 映射，映射关系可以是一对一或多对一，key 无序且唯一，value 可重复。实现类中 LinkedHashMap 按照插入顺序排序，SortedMap 可排序，HashMap 无序。</li>
</ul>
<p>共同点</p>
<ul>
<li>迭代过程中，如果数据结构被改变，会快速失败的</li>
<li>线程不安全的，如果需要安全请自行加锁</li>
</ul>
<h3 id="Iterator是什么"><a href="#Iterator是什么" class="headerlink" title="Iterator是什么"></a>Iterator是什么</h3><p>Iterator接口提供遍历任何Collection的接口。我们可以从一个Collection中使用迭代器方法来获取迭代器实例。迭代器取代了Java集合框架中的Enumeration。迭代器允许调用者在迭代过程中移除元素。</p>
<h3 id="迭代器的优点"><a href="#迭代器的优点" class="headerlink" title="迭代器的优点"></a>迭代器的优点</h3><p>如果用的是for循环，就用集合自带的remove(),而这样就改变了集合的Size（）循环的时候会出错。但如果把集合放入迭代器，既iterator迭代可以遍历并选择集合中的每个对象而不改变集合的结构，而把集合放入迭代器，用迭代器的remove（）就不会出现问题</p>
<h3 id="Enumeration和Iterator接口的区别"><a href="#Enumeration和Iterator接口的区别" class="headerlink" title="Enumeration和Iterator接口的区别"></a>Enumeration和Iterator接口的区别</h3><p>Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。</p>
<h3 id="Java集合类中的Iterator和ListIterator的区别？"><a href="#Java集合类中的Iterator和ListIterator的区别？" class="headerlink" title="Java集合类中的Iterator和ListIterator的区别？"></a>Java集合类中的Iterator和ListIterator的区别？</h3><ul>
<li><p>Iterator()方法在set和list接口中都有定义，但是ListIterator()仅存在于list接口中</p>
</li>
<li><p>ListIterator有add()方法，可以向List中添加对象，而Iterator不能；</p>
</li>
<li><p>ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以；</p>
</li>
<li><p>ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能；</p>
</li>
<li><p>都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改.</p>
</li>
</ul>
<h3 id="Java-集合的快速失败（fail-fast）和安全失败（fail-safe）的差别是什么？"><a href="#Java-集合的快速失败（fail-fast）和安全失败（fail-safe）的差别是什么？" class="headerlink" title="Java 集合的快速失败（fail-fast）和安全失败（fail-safe）的差别是什么？"></a>Java 集合的快速失败（fail-fast）和安全失败（fail-safe）的差别是什么？</h3><p>快速失败和安全失败都是 java 集合（Collection）的一种错误机制。单线程情况下，遍历集合时去执行增删等改变集合结构的操作；或者多线程情况下，一个线程遍历集合，另一个线程执行增删等改变集合结构的操作。</p>
<ul>
<li>快速失败，是指失败 / 异常时立即报错，通常会抛出 ConcurrentModificationException 异常，像 java.util 包下面的集合类就是使用这种机制；</li>
<li>安全失败，是指失败 / 异常时直接忽略，java.util.concurrent 包下面的集合类都是使用这种机制。</li>
</ul>
<p><strong>补充</strong></p>
<p>快速失败的原因在于，每当迭代器在进行增删等操作时，会使用 hashNext () /next () 进行元素遍历，而元素遍历之前都会检测  modCount 变量是否为 expectedmodCount 的值，是的话就返回遍历，否则抛出异常  ConcurrentModificationException，终止遍历。</p>
<p>安全失败的处理方式则有两种：一是 CopyOnWriteArrayList/CopyOnWriteArraySet  这类集合，底层增删时会复制数组，如果增删操作前遍历数组，则会遍历复制前的老视图，二者并不冲突；二是 ConcurrentHashMap 这些并发集合，这些集合不存在 expectedmodCount，Iterator  也不会做相应的检查。</p>
<p>目前快速失败 / 安全失败已经不仅限于 JDK 里面的集合操作了，而是作为一种思想在 Java 很多地方都有用到，比如说 RPC  调用框架的不同策略、Web  容器启动等。广义地讲，快速失败是指代码逻辑在碰到潜在问题的时候，尽快返回错误而不是尝试容忍或者解决问题；而安全失败则是采用兜底逻辑来忽略此问题，以便流程可以继续推进。</p>
<h3 id="集合框架中的泛型有什么优点"><a href="#集合框架中的泛型有什么优点" class="headerlink" title="集合框架中的泛型有什么优点"></a>集合框架中的泛型有什么优点</h3><p>Java1.5引入了泛型，所有的集合接口和实现都大量地使用它。</p>
<p>泛型允许我们为集合提供一个可以容纳的对象类型，因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现ClassCastException，因为你将会在编译时得到报错信息。泛型也使得代码整洁，我们不需要使用显式转换和instanceOf操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令。</p>
<h3 id="Java集合框架的基础接口有哪些"><a href="#Java集合框架的基础接口有哪些" class="headerlink" title="Java集合框架的基础接口有哪些"></a>Java集合框架的基础接口有哪些</h3><p>Collection为集合层级的根接口。一个集合代表一组对象，这些对象即为它的元素。Java平台不提供这个接口任何直接的实现。</p>
<p>Set是一个不能包含重复元素的集合。这个接口对数学集合抽象进行建模，被用来代表集合，就如一副牌。</p>
<p>List是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List更像长度动态变换的数组。</p>
<p>Map是一个将key映射到value的对象.一个Map不能包含重复的key：每个key最多只能映射一个value。</p>
<p>一些其它的接口有Queue、Dequeue、SortedSet、SortedMap和ListIterator。</p>
<h3 id="为何Collection不从Cloneable和Serializable接口继承"><a href="#为何Collection不从Cloneable和Serializable接口继承" class="headerlink" title="为何Collection不从Cloneable和Serializable接口继承"></a>为何Collection不从Cloneable和Serializable接口继承</h3><p>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化</p>
<h3 id="哪些集合类是线程安全的"><a href="#哪些集合类是线程安全的" class="headerlink" title="哪些集合类是线程安全的"></a>哪些集合类是线程安全的</h3><p>Vector、HashTable、Properties和Stack是同步类，所以它们是线程安全的，可以在多线程环境下使用。Java1.5并发API包括一些集合类，允许迭代时修改，因为它们都工作在集合的克隆上，所以它们在多线程环境中是安全的。</p>
<h3 id="并发集合类是什么"><a href="#并发集合类是什么" class="headerlink" title="并发集合类是什么"></a>并发集合类是什么</h3><p>Java1.5并发包（java.util.concurrent）包含线程安全集合类，允许在迭代时修改集合。迭代器被设计为fail-fast的，会抛出ConcurrentModificationException。一部分类为：CopyOnWriteArrayList、 ConcurrentHashMap、CopyOnWriteArraySet。</p>
<h3 id="如何保证线程安全又效率高"><a href="#如何保证线程安全又效率高" class="headerlink" title="如何保证线程安全又效率高"></a>如何保证线程安全又效率高</h3><p>Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。</p>
<p>ConcurrentHashMap将整个Map分为N个segment(类似HashTable)，可以提供相同的线程安全，但是效率提升N倍，默认N为16。</p>
<h3 id="怎么确保一个集合不能被修改"><a href="#怎么确保一个集合不能被修改" class="headerlink" title="怎么确保一个集合不能被修改"></a>怎么确保一个集合不能被修改</h3><p>（1）Java中提供final关键字，对基本类型进行修饰，当第一次初始化后，该变量就不可被修改 </p>
<p>（2）Collections`工具类中的UnmodifiableList(不可修改的List、Map、Set等)</p>
<h3 id="哪些集合类提供对元素的随机访问"><a href="#哪些集合类提供对元素的随机访问" class="headerlink" title="哪些集合类提供对元素的随机访问"></a>哪些集合类提供对元素的随机访问</h3><p>ArrayList、HashMap、TreeMap和HashTable类提供对元素的随机访问。</p>
<h3 id="与Java集合框架相关的有哪些最好的实践"><a href="#与Java集合框架相关的有哪些最好的实践" class="headerlink" title="与Java集合框架相关的有哪些最好的实践"></a>与Java集合框架相关的有哪些最好的实践</h3><p>（1）根据需要选择正确的集合类型。比如，如果指定了大小，我们会选用Array而非ArrayList。如果我们想根据插入顺序遍历一个Map，我们需要使用TreeMap。如果我们不想重复，我们应该使用Set。</p>
<p>（2）一些集合类允许指定初始容量，所以如果我们能够估计到存储元素的数量，我们可以使用它，就避免了重新哈希或大小调整。</p>
<p>（3）基于接口编程，而非基于实现编程，它允许我们后来轻易地改变实现。</p>
<p>（4）总是使用类型安全的泛型，避免在运行时出现ClassCastException。</p>
<p>（5）使用JDK提供的不可变类作为Map的key，可以避免自己实现hashCode()和equals()。</p>
<p>（6）尽可能使用Collections工具类，或者获取只读、同步或空的集合，而非编写自己的实现。它将会提供代码重用性，它有着更好的稳定性和可维护性。</p>
<h3 id="集合性能"><a href="#集合性能" class="headerlink" title="集合性能"></a>集合性能</h3><h4 id="批量新增"><a href="#批量新增" class="headerlink" title="批量新增"></a>批量新增</h4><p>在 List 和 Map 大量数据新增的时候，我们不要使用 for 循环 + add/put 方法新增，这样子会有很大的扩容成本，我们应该尽量使用 addAll 和 putAll 方法进行新增</p>
<h4 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h4><p>批量删除 ArrayList 提供了 removeAll 的方法，HashMap 没有提供批量删除的方法</p>
<h3 id="集合使用避坑"><a href="#集合使用避坑" class="headerlink" title="集合使用避坑"></a>集合使用避坑</h3><ol>
<li><p>当集合的元素是自定义类时，自定义类强制实现 equals 和 hashCode 方法，并且两个都要实现。</p>
<p>在集合中，除了 TreeMap 和 TreeSet 是通过比较器比较元素大小外，其余的集合类在判断索引位置和相等时，都会使用到 equals 和 hashCode 方法，</p>
</li>
<li><p>所有集合类，在 for 循环进行删除时，如果直接使用集合类的 remove 方法进行删除，都会快速失败，报 ConcurrentModificationException 的错误，所以在任意循环删除的场景下，都建议使用迭代器进行删除；</p>
</li>
<li><p>我们把数组转化成集合时，常使用 Arrays.asList(array)，这个方法有两个坑</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testArrayToList</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">  List&lt;Integer&gt; list = Arrays.asList(array);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 坑1：修改数组的值，会直接影响原 list</span></span><br><span class="line">  log.info(<span class="string">&quot;数组被修改之前，集合第一个元素为：&#123;&#125;&quot;</span>,list.get(<span class="number">0</span>));</span><br><span class="line">  array[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">  log.info(<span class="string">&quot;数组被修改之前，集合第一个元素为：&#123;&#125;&quot;</span>,list.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 坑2：使用 add、remove 等操作 list 的方法时，</span></span><br><span class="line">  <span class="comment">// 会报 UnsupportedOperationException 异常</span></span><br><span class="line">  list.add(<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line">坑 <span class="number">1</span>：数组被修改后，会直接影响到新 List 的值。</span><br><span class="line">坑 <span class="number">2</span>：不能对新 List 进行 add、remove 等操作，否则运行时会报 UnsupportedOperationException 错误。</span><br></pre></td></tr></table></figure>

<p>​    <img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/%E5%AE%B9%E5%99%A8/image2.png"></p>
<p>Arrays.asList 方法返回的 List 并不是 java.util.ArrayList，而是自己内部的一个静态类，该静态类直接持有数组    的引用，并且没有实现 add、remove 等方法</p>
<ol start="4">
<li>集合 List 转化成数组，我们通常使用 toArray 这个方法，这个方法很危险</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListToArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;()&#123;&#123;</span><br><span class="line">      add(<span class="number">1</span>);</span><br><span class="line">      add(<span class="number">2</span>);</span><br><span class="line">      add(<span class="number">3</span>);</span><br><span class="line">      add(<span class="number">4</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这行被注释的代码这么写是无法转化成数组的，无参 toArray 返回的是 Object[],</span></span><br><span class="line">    <span class="comment">// 无法向下转化成 List&lt;Integer&gt;，编译都无法通过</span></span><br><span class="line">    <span class="comment">// List&lt;Integer&gt; list2 = list.toArray();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示有参 toArray 方法，数组大小不够时，得到数组为 null 情况</span></span><br><span class="line">    Integer[] array0 = <span class="keyword">new</span> Integer[<span class="number">2</span>];</span><br><span class="line">    list.toArray(array0);</span><br><span class="line">    log.info(<span class="string">&quot;toArray 数组大小不够，array0 数组[0] 值是&#123;&#125;,数组[1] 值&#123;&#125;,&quot;</span>,array0[<span class="number">0</span>],array0[<span class="number">1</span>]);</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 演示数组初始化大小正好，正好转化成数组</span></span><br><span class="line">    Integer[] array1 = <span class="keyword">new</span> Integer[list.size()];</span><br><span class="line">    list.toArray(array1);</span><br><span class="line">    log.info(<span class="string">&quot;toArray 数组大小正好，array1 数组[3] 值是&#123;&#125;&quot;</span>,array1[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示数组初始化大小大于实际所需大小，也可以转化成数组</span></span><br><span class="line">    Integer[] array2 = <span class="keyword">new</span> Integer[list.size()+<span class="number">2</span>];</span><br><span class="line">    list.toArray(array2);</span><br><span class="line">    log.info(<span class="string">&quot;toArray 数组大小多了，array2 数组[3] 值是&#123;&#125;，数组[4] 值&#123;&#125;&quot;</span>,array2[<span class="number">3</span>],array2[<span class="number">4</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">19:33:07.687 [main] INFO demo.one.ArrayListDemo - toArray 数组大小不够，array0 数组[0] 值是null,数组[1] 值是null,</span><br><span class="line">19:33:07.697 [main] INFO demo.one.ArrayListDemo - toArray 数组大小正好，array1 数组[3] 值是4</span><br><span class="line">19:33:07.697 [main] INFO demo.one.ArrayListDemo - toArray 数组大小多了，array2 数组[3] 值是4，数组[4] 值是null</span><br></pre></td></tr></table></figure>

<h3 id="Java8对集合的修改"><a href="#Java8对集合的修改" class="headerlink" title="Java8对集合的修改"></a>Java8对集合的修改</h3><h4 id="Java-8-在-List、Map-接口上新增了很多方法，为什么-Java-7-中这些接口的实现者不需要强制实现这些方法呢？"><a href="#Java-8-在-List、Map-接口上新增了很多方法，为什么-Java-7-中这些接口的实现者不需要强制实现这些方法呢？" class="headerlink" title="Java 8 在 List、Map 接口上新增了很多方法，为什么 Java 7 中这些接口的实现者不需要强制实现这些方法呢？"></a>Java 8 在 List、Map 接口上新增了很多方法，为什么 Java 7 中这些接口的实现者不需要强制实现这些方法呢？</h4><p>主要是因为这些新增的方法被 default 关键字修饰了，default 一旦修饰接口上的方法，我们需要在接口的方法中写默认实现，并且子类无需强制实现这些方法，所以 Java 7 接口的实现者无需感知。</p>
<h4 id="Java-8-集合新增了-forEach-方法，和普通的-for-循环有啥不同"><a href="#Java-8-集合新增了-forEach-方法，和普通的-for-循环有啥不同" class="headerlink" title="Java 8 集合新增了 forEach 方法，和普通的 for 循环有啥不同"></a>Java 8 集合新增了 forEach 方法，和普通的 for 循环有啥不同</h4><p>新增的 forEach 方法的入参是函数式的接口，比如说 Consumer 和 BiConsumer，这样子做的好处就是封装了 for  循环的代码，让使用者只需关注实现每次循环的业务逻辑，简化了重复的 for 循环代码，使代码更加简洁，普通的 for 循环，每次都需要写重复的  for 循环代码，forEach 把这种重复的计算逻辑吃掉了，使用起来更加方便。</p>
<h3 id="Java7和Java8-集合上的修改"><a href="#Java7和Java8-集合上的修改" class="headerlink" title="Java7和Java8 集合上的修改"></a>Java7和Java8 集合上的修改</h3><h4 id="通用区别"><a href="#通用区别" class="headerlink" title="通用区别"></a>通用区别</h4><h5 id="所有集合都新增了forEach-方法"><a href="#所有集合都新增了forEach-方法" class="headerlink" title="所有集合都新增了forEach 方法"></a>所有集合都新增了forEach 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testForEach</span><span class="params">()</span></span>&#123;</span><br><span class="line">  List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;()&#123;&#123;</span><br><span class="line">    add(<span class="number">1</span>);</span><br><span class="line">    add(<span class="number">3</span>);</span><br><span class="line">    add(<span class="number">2</span>);</span><br><span class="line">    add(<span class="number">4</span>);</span><br><span class="line">  &#125;&#125;;</span><br><span class="line">  <span class="comment">// value 是每次循环的入参，就是 list 中的每个元素</span></span><br><span class="line">  list.forEach( value-&gt;log.info(<span class="string">&quot;当前值为：&#123;&#125;&quot;</span>,value));</span><br><span class="line">&#125;</span><br><span class="line">输出为：</span><br><span class="line">当前值为：<span class="number">1</span></span><br><span class="line">当前值为：<span class="number">3</span></span><br><span class="line">当前值为：<span class="number">2</span></span><br><span class="line">当前值为：<span class="number">4</span></span><br></pre></td></tr></table></figure>

<h4 id="List区别"><a href="#List区别" class="headerlink" title="List区别"></a>List区别</h4><p>ArrayList 无参初始化时，Java 7 是直接初始化 10 的大小，Java 8 去掉了这个逻辑，初始化时是空数组，在第一次 add 时才开始按照 10 进行扩容</p>
<h4 id="Map区别"><a href="#Map区别" class="headerlink" title="Map区别"></a>Map区别</h4><p>map 还提供了 computeIfPresent 方法，表示只有在 key 存在的时候，才执行计算</p>
<h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><ol>
<li>和 ArrayList 一样，Java 8 中 HashMap 在无参构造器中，丢弃了 Java 7 中直接把数组初始化 16 的做法，而是采用在第一次新增的时候，才开始扩容数组大小；</li>
<li>hash 算法计算公式不同，Java 8 的 hash 算法更加简单，代码更加简洁；</li>
<li>Java 8 中提出了数组 + 链表 + 红黑树的结构</li>
<li>新增了一些好用的方法，</li>
</ol>
<ul>
<li>getOrDefault</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 key 对应的值不存在，返回期望的默认值 defaultValue</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? defaultValue : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>putIfAbsent(K key, V value) 方法，</p>
<p>如果 map 中存在 key 了，那么 value 就不会覆盖，如果不存    在 key ，新增成功。</p>
</li>
<li><p>compute 方法，</p>
<p>允许我们把 key 和 value 的值进行计算后，再 put 到 map 中，为防止 key  值不存    在造成未知错误，</p>
</li>
</ul>
<h5 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h5><p>HashMap 操作数据的方法几乎重写，也使 LinkedHashMap 的实现名称上有所差异，原理上都相同</p>
<h2 id="Collection-子接口之-List"><a href="#Collection-子接口之-List" class="headerlink" title="Collection 子接口之 List"></a>Collection 子接口之 List</h2><h3 id="Arraylist-和-Vector-的区别"><a href="#Arraylist-和-Vector-的区别" class="headerlink" title="Arraylist 和 Vector 的区别?"></a>Arraylist 和 Vector 的区别?</h3><ul>
<li>相同点：</li>
</ul>
<p>（1）两者都是基于索引的，内部由一个数组支持。</p>
<p>（2）两者维护插入的顺序，我们可以根据插入顺序来获取元素。</p>
<p>（3）ArrayList和Vector的迭代器实现都是fail-fast的。</p>
<p>（4）ArrayList和Vector两者允许null值，也可以使用索引值对元素进行随机访问。</p>
<ul>
<li>不同点：</li>
</ul>
<p>（1）Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。</p>
<p>（2）ArrayList比Vector快，它因为有同步，不会过载。</p>
<p>（3）ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</p>
<h3 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a>Arraylist 与 LinkedList 区别?</h3><ol>
<li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>
<li><strong>插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></li>
<li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>
<li><strong>内存空间占用：</strong> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ol>
<h3 id="ArrayList-和-LinkedList-是如何对-null-值进行处理的"><a href="#ArrayList-和-LinkedList-是如何对-null-值进行处理的" class="headerlink" title="ArrayList 和 LinkedList 是如何对 null 值进行处理的"></a>ArrayList 和 LinkedList 是如何对 null 值进行处理的</h3><p>ArrayList 允许 null 值新增，也允许 null 值删除。删除 null 值时，是从头开始，找到第一值是 null 的元素删除；LinkedList 新增删除时对 null 值没有特殊校验，是允许新增和删除的。</p>
<h3 id="数组-Array-和列表-ArrayList-的差别是什么"><a href="#数组-Array-和列表-ArrayList-的差别是什么" class="headerlink" title="数组(Array)和列表(ArrayList)的差别是什么?"></a>数组(Array)和列表(ArrayList)的差别是什么?</h3><ul>
<li>Array可以容纳基本类型和对象，而ArrayList只能容纳对象；</li>
<li>Array 是静态的，一旦创建就无法更改它的大小，ArrayList 是Java集合框架类的一员,可以称它为一个动态数组。</li>
</ul>
<h3 id="ArrayList-和-LinkedList-都不是线程安全的，那有线程安全的-List-类吗"><a href="#ArrayList-和-LinkedList-都不是线程安全的，那有线程安全的-List-类吗" class="headerlink" title="ArrayList 和 LinkedList 都不是线程安全的，那有线程安全的 List 类吗"></a>ArrayList 和 LinkedList 都不是线程安全的，那有线程安全的 List 类吗</h3><p>线程安全 List 类有 Vector 和 CopyOnWriteList。</p>
<ul>
<li>Vector 是通过在其几乎所有方法前加 synchronized 关键字来保证线程安全性；</li>
<li>CopyOnWriteList 则是通过数组复制的方法来保证线程安全的。</li>
</ul>
<p><strong>Vector和CopyOnWriteList都是通过 synchronized 来保证集合的安全性 只不过 Vector 的 synchronized 关键字加在方法外面，Collections.synchronizedList (new ArrayList ()) 的 synchronized 关键字加在方法里面。</strong></p>
<h3 id="ArrayList-和-LinkedList-两者有没有最大容量"><a href="#ArrayList-和-LinkedList-两者有没有最大容量" class="headerlink" title="ArrayList 和 LinkedList 两者有没有最大容量"></a>ArrayList 和 LinkedList 两者有没有最大容量</h3><p>答：ArrayList 有最大容量的，为 Integer  的最大值，大于这个值 JVM 是不会为数组分配内存空间的，LinkedList 底层是双向链表，理论上可以无限大。但源码中，LinkedList 实际大小用的是 int 类型，这也说明了 LinkedList 不能超过 Integer 的最大值，不然会溢出。</p>
<h3 id="ArrayList-和-LinedList-是线程安全的么，为什么？"><a href="#ArrayList-和-LinedList-是线程安全的么，为什么？" class="headerlink" title="ArrayList 和 LinedList 是线程安全的么，为什么？"></a>ArrayList 和 LinedList 是线程安全的么，为什么？</h3><p>答：当两者作为非共享变量时，比如说仅仅是在方法里面的局部变量时，是没有线程安全问题的，只有当两者是共享变量时，才会有线程安全问题。主要的问题点在于多线程环境下，所有线程任何时刻都可对数组和链表进行操作，这会导致值被覆盖，甚至混乱的情况。</p>
<p>如果有线程安全问题，在迭代的过程中，会频繁报 ConcurrentModificationException 的错误，意思是在我当前循环的过程中，数组或链表的结构被其它线程修改了。</p>
<h3 id="ArrayList-无参数构造器构造，现在-add-一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？"><a href="#ArrayList-无参数构造器构造，现在-add-一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？" class="headerlink" title="ArrayList 无参数构造器构造，现在 add 一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？"></a>ArrayList 无参数构造器构造，现在 add 一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？</h3><p>此处数组的大小是 1，下一次扩容前最大可用大小是 10，因为 ArrayList 第一次扩容时，是有默认值的，默认值是 10，在第一次 add 一个值进去时，数组的可用大小被扩容到 10 了。</p>
<h3 id="如果我连续往-list-里面新增值，增加到第-11-个的时候，数组的大小是多少？"><a href="#如果我连续往-list-里面新增值，增加到第-11-个的时候，数组的大小是多少？" class="headerlink" title="如果我连续往 list 里面新增值，增加到第 11 个的时候，数组的大小是多少？"></a>如果我连续往 list 里面新增值，增加到第 11 个的时候，数组的大小是多少？</h3><p>这里的考查点就是扩容的公式，当增加到 11 的时候，此时我们希望数组的大小为 11，但实际上数组的最大容量只有  10，不够了就需要扩容，扩容的公式是：oldCapacity + (oldCapacity&gt;&gt; 1)，oldCapacity  表示数组现有大小，目前场景计算公式是：10 + 10 ／2 = 15，然后我们发现 15 已经够用了，所以数组的大小会被扩容到 15。</p>
<h3 id="数组初始化，被加入一个值后，如果我使用-addAll-方法，一下子加入-15-个值，那么最终数组的大小是多少"><a href="#数组初始化，被加入一个值后，如果我使用-addAll-方法，一下子加入-15-个值，那么最终数组的大小是多少" class="headerlink" title="数组初始化，被加入一个值后，如果我使用 addAll 方法，一下子加入 15 个值，那么最终数组的大小是多少"></a>数组初始化，被加入一个值后，如果我使用 addAll 方法，一下子加入 15 个值，那么最终数组的大小是多少</h3><p>数组在加入一个值后，实际大小是 1，最大可用大小是 10  ，现在需要一下子加入 15 个值，那我们期望数组的大小值就是 16，此时数组最大可用大小只有 10，明显不够，需要扩容，扩容后的大小是：10 + 10 ／2 = 15，这时候发现扩容后的大小仍然不到我们期望的值 16，这时候源码中有一种策略如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newCapacity 本次扩容的大小，minCapacity 我们期望的数组最小大小</span></span><br><span class="line"><span class="comment">// 如果扩容后的值 &lt; 我们的期望值，我们的期望值就等于本次扩容的大小</span></span><br><span class="line"><span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br></pre></td></tr></table></figure>

<p>所以最终数组扩容后的大小为 16。</p>
<h3 id="现在我有一个很大的数组需要拷贝，原数组大小是-5k，请问如何快速拷贝？"><a href="#现在我有一个很大的数组需要拷贝，原数组大小是-5k，请问如何快速拷贝？" class="headerlink" title="现在我有一个很大的数组需要拷贝，原数组大小是 5k，请问如何快速拷贝？"></a>现在我有一个很大的数组需要拷贝，原数组大小是 5k，请问如何快速拷贝？</h3><p>因为原数组比较大，如果新建新数组的时候，不指定数组大小的话，就会频繁扩容，频繁扩容就会有大量拷贝的工作，造成拷贝的性能低下，所以回答说新建数组时，指定新数组的大小为 5k 即可。</p>
<h3 id="为什么说扩容会消耗性能"><a href="#为什么说扩容会消耗性能" class="headerlink" title="为什么说扩容会消耗性能"></a>为什么说扩容会消耗性能</h3><p>扩容底层使用的是 System.arraycopy 方法，会把原数组的数据全部拷贝到新数组上，所以性能消耗比较严重。</p>
<h3 id="源码扩容过程有什么值得借鉴的地方"><a href="#源码扩容过程有什么值得借鉴的地方" class="headerlink" title="源码扩容过程有什么值得借鉴的地方"></a>源码扩容过程有什么值得借鉴的地方</h3><ul>
<li>自动扩容的方式，让使用者不用关心底层数据结构的变化，封装得很好，1.5 倍的扩容速度，可以让扩容速度在前期缓慢上升，在后期增速较快</li>
<li>扩容过程中，有数组大小溢出的意识，比如要求扩容后的数组大小，不能小于 0，不能大于 Integer 的最大值。</li>
</ul>
<h3 id="有一个-ArrayList，数据是-2、3、3、3、4，中间有三个-3，现在我通过-for-int-i-0-i-lt-list-size-i-的方式，想把值是-3-的元素删除，请问可以删除干净么？最终删除的结果是什么，为什么？删除代码如下："><a href="#有一个-ArrayList，数据是-2、3、3、3、4，中间有三个-3，现在我通过-for-int-i-0-i-lt-list-size-i-的方式，想把值是-3-的元素删除，请问可以删除干净么？最终删除的结果是什么，为什么？删除代码如下：" class="headerlink" title="有一个 ArrayList，数据是 2、3、3、3、4，中间有三个 3，现在我通过 for (int i=0;i&lt;list.size ();i++) 的方式，想把值是 3 的元素删除，请问可以删除干净么？最终删除的结果是什么，为什么？删除代码如下："></a>有一个 ArrayList，数据是 2、3、3、3、4，中间有三个 3，现在我通过 for (int i=0;i&lt;list.size ();i++) 的方式，想把值是 3 的元素删除，请问可以删除干净么？最终删除的结果是什么，为什么？删除代码如下：</h3><img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/%E5%AE%B9%E5%99%A8/arrayList1.png" style="zoom: 33%;" />

<p>从图中我们可以看到，每次删除一个元素后，该元素后面的元素就会往前移动，而此时循环的 i 在不断地增长，最终会使每次删除 3 的后一个 3 被遗漏，导致删除不掉。</p>
<h4 id="还是上面的-ArrayList-数组，我们通过增强-for-循环进行删除，可以么"><a href="#还是上面的-ArrayList-数组，我们通过增强-for-循环进行删除，可以么" class="headerlink" title="还是上面的 ArrayList 数组，我们通过增强 for 循环进行删除，可以么"></a>还是上面的 ArrayList 数组，我们通过增强 for 循环进行删除，可以么</h4><p>不可以，会报错。因为增强 for 循环过程其实调用的就是迭代器的 next () 方法，当你调用 list#remove ()  方法进行删除时，modCount 的值会 +1，而这时候迭代器中的 expectedModCount 的值却没有变，导致在迭代器下次执行  next () 方法时，expectedModCount !=  modCount 就会报  ConcurrentModificationException 的错误。</p>
<h4 id="还是上面的数组，如果删除时使用-Iterator-remove-方法可以删除么，为什么"><a href="#还是上面的数组，如果删除时使用-Iterator-remove-方法可以删除么，为什么" class="headerlink" title="还是上面的数组，如果删除时使用 Iterator.remove () 方法可以删除么，为什么"></a>还是上面的数组，如果删除时使用 Iterator.remove () 方法可以删除么，为什么</h4><p>可以的，因为 Iterator.remove () 方法在执行的过程中，会把最新的 modCount 赋值给 expectedModCount，这样在下次循环过程中，modCount 和 expectedModCount 两者就会相等。</p>
<h4 id="以上三个问题对于-LinkedList-也是同样的结果么？"><a href="#以上三个问题对于-LinkedList-也是同样的结果么？" class="headerlink" title="以上三个问题对于 LinkedList 也是同样的结果么？"></a>以上三个问题对于 LinkedList 也是同样的结果么？</h4><p>是的，虽然 LinkedList 底层结构是双向链表，但对于上述三个问题，结果和 ArrayList 是一致的。</p>
<h3 id="ArrayList-和-LinedList-是线程安全的么，为什么？-1"><a href="#ArrayList-和-LinedList-是线程安全的么，为什么？-1" class="headerlink" title="ArrayList 和 LinedList 是线程安全的么，为什么？"></a>ArrayList 和 LinedList 是线程安全的么，为什么？</h3><p>答：当两者作为非共享变量时，比如说仅仅是在方法里面的局部变量时，是没有线程安全问题的，只有当两者是共享变量时，才会有线程安全问题。主要的问题点在于多线程环境下，所有线程任何时刻都可对数组和链表进行操作，这会导致值被覆盖，甚至混乱的情况。</p>
<p>如果有线程安全问题，在迭代的过程中，会频繁报 ConcurrentModificationException 的错误，意思是在我当前循环的过程中，数组或链表的结构被其它线程修改了。</p>
<h3 id="如何解决线程安全问题？"><a href="#如何解决线程安全问题？" class="headerlink" title="如何解决线程安全问题？"></a>如何解决线程安全问题？</h3><p>Java 源码中推荐使用  Collections#synchronizedList 进行解决，Collections#synchronizedList 的返回值是  List 的每个方法都加了 synchronized 锁，保证了在同一时刻，数组和链表只会被一个线程所修改，或者采用  CopyOnWriteArrayList 并发 List 来解决</p>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表中双向的意思是说前后节点之间互相有引用，链表的节点我们称为 Node。Node  有三个属性组成：其前一个节点，本身节点的值，其下一个节点，假设 A、B 节点相邻，A 节点的下一个节点就是 B，B 节点的上一个节点就是  A，两者互相引用，在链表的头部节点，我们称为头节点。头节点的前一个节点是 null，尾部称为尾节点，尾节点的后一个节点是  null，如果链表数据为空的话，头尾节点是同一个节点，本身是 null，指向前后节点的值也是 null。</p>
<h2 id="双向链表的新增和删除"><a href="#双向链表的新增和删除" class="headerlink" title="双向链表的新增和删除"></a>双向链表的新增和删除</h2><p>新增：我们可以选择从链表头新增，也可以选择从链表尾新增，如果是从链表尾新增的话，直接把当前节点追加到尾节点之后，本身节点自动变为尾节点。</p>
<p>删除：把删除节点的后一个节点的 prev 指向其前一个节点，把删除节点的前一个节点的 next 指向其后一个节点，最后把删除的节点置为 null 即可。</p>
<h2 id="Collection-子接口之-Set"><a href="#Collection-子接口之-Set" class="headerlink" title="Collection 子接口之 Set"></a>Collection 子接口之 Set</h2><h3 id="comparable-和-Comparator-的区别"><a href="#comparable-和-Comparator-的区别" class="headerlink" title="comparable 和 Comparator 的区别"></a>comparable 和 Comparator 的区别</h3><ul>
<li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li>
<li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li>
</ul>
<p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code>compareTo()</code>方法和使用自制的<code>Comparator</code>方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code>.</p>
<ul>
<li><strong>相同点</strong></li>
</ul>
<p>都是用于比较两个对象“顺序”的接口</p>
<p>都可以使用Collections.sort()方法来对对象集合进行排序</p>
<ul>
<li><strong>不同点</strong></li>
</ul>
<p>Comparable位于java.lang包下，而Comparator则位于java.util包下</p>
<p>Comparable 是在集合内部定义的方法实现的排序，Comparator 是在集合外部实现的排序</p>
<ul>
<li><strong>总结</strong></li>
</ul>
<p>使用Comparable接口来实现对象之间的比较时，可以使这个类型（设为A）实现Comparable接口，并可以使用Collections.sort()方法来对A类型的List进行排序，之后可以通过a1.comparaTo(a2)来比较两个对象；</p>
<p>当使用Comparator接口来实现对象之间的比较时，只需要创建一个实现Comparator接口的比较器（设为AComparator），并将其传给Collections.sort()方法即可对A类型的List进行排序，之后也可以通过调用比较器AComparator.compare(a1, a2)来比较两个对象。</p>
<p>可以说一个是自己完成比较，一个是外部程序实现比较的差别而已。</p>
<p>用 Comparator 是策略模式（strategy design pattern），就是不改变对象自身，而用一个策略对象（strategy object）来改变它的行为。</p>
<p>比如：你想对整数采用绝对值大小来排序，Integer 是不符合要求的，你不需要去修改 Integer 类（实际上你也不能这么做）去改变它的排序行为，这时候只要（也只有）使用一个实现了 Comparator 接口的对象来实现控制它的排序就行了。</p>
<p>两种方式，各有各的特点：使用Comparable方式比较时，我们将比较的规则写入了比较的类型中，其特点是高内聚。但如果哪天这个规则需要修改，那么我们必须修改这个类型的源代码。如果使用Comparator方式比较，那么我们不需要修改比较的类，其特点是易维护，但需要自定义一个比较器，后续比较规则的修改，仅仅是改这个比较器中的代码即可。</p>
<h4 id="Comparator-定制排序"><a href="#Comparator-定制排序" class="headerlink" title="Comparator 定制排序"></a>Comparator 定制排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">arrayList.add(-<span class="number">1</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(-<span class="number">5</span>);</span><br><span class="line">arrayList.add(<span class="number">7</span>);</span><br><span class="line">arrayList.add(<span class="number">4</span>);</span><br><span class="line">arrayList.add(-<span class="number">9</span>);</span><br><span class="line">arrayList.add(-<span class="number">7</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;原始数组:&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"><span class="comment">// void reverse(List list)：反转</span></span><br><span class="line">Collections.reverse(arrayList);</span><br><span class="line">System.out.println(<span class="string">&quot;Collections.reverse(arrayList):&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// void sort(List list),按自然排序的升序排序</span></span><br><span class="line">Collections.sort(arrayList);</span><br><span class="line">System.out.println(<span class="string">&quot;Collections.sort(arrayList):&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"><span class="comment">// 定制排序的用法</span></span><br><span class="line">Collections.sort(arrayList, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;定制排序后：&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原始数组:</span><br><span class="line">[-1, 3, 3, -5, 7, 4, -9, -7]</span><br><span class="line">Collections.reverse(arrayList):</span><br><span class="line">[-7, -9, 4, 7, -5, 3, 3, -1]</span><br><span class="line">Collections.sort(arrayList):</span><br><span class="line">[-9, -7, -5, -1, 3, 3, 4, 7]</span><br><span class="line">定制排序后：</span><br><span class="line">[7, 4, 3, 3, -1, -5, -7, -9]</span><br></pre></td></tr></table></figure>

<h4 id="重写-compareTo-方法实现按年龄来排序"><a href="#重写-compareTo-方法实现按年龄来排序" class="headerlink" title="重写 compareTo 方法实现按年龄来排序"></a>重写 compareTo 方法实现按年龄来排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span></span><br><span class="line"><span class="comment">// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span></span><br><span class="line"><span class="comment">// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * T重写compareTo方法实现按年龄来排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age &gt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age &lt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Person, String&gt; pdata = <span class="keyword">new</span> TreeMap&lt;Person, String&gt;();</span><br><span class="line">        pdata.put(<span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>), <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        pdata.put(<span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>), <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        pdata.put(<span class="keyword">new</span> Person(<span class="string">&quot;王五&quot;</span>, <span class="number">10</span>), <span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        pdata.put(<span class="keyword">new</span> Person(<span class="string">&quot;小红&quot;</span>, <span class="number">5</span>), <span class="string">&quot;xiaohong&quot;</span>);</span><br><span class="line">        <span class="comment">// 得到key的值的同时得到key所对应的值</span></span><br><span class="line">        Set&lt;Person&gt; keys = pdata.keySet();</span><br><span class="line">        <span class="keyword">for</span> (Person key : keys) &#123;</span><br><span class="line">            System.out.println(key.getAge() + <span class="string">&quot;-&quot;</span> + key.getName());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Output：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5-小红</span><br><span class="line">10-王五</span><br><span class="line">20-李四</span><br><span class="line">30-张三</span><br></pre></td></tr></table></figure>

<h3 id="无序性和不可重复性的含义是什么"><a href="#无序性和不可重复性的含义是什么" class="headerlink" title="无序性和不可重复性的含义是什么"></a>无序性和不可重复性的含义是什么</h3><p>1、什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</p>
<p>2、什么是不可重复性？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</p>
<h3 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><p><code>HashSet</code> 是 <code>Set</code> 接口的主要实现类 ，<code>HashSet</code> 的底层是 <code>HashMap</code>，线程不安全的，可以存储 null 值；</p>
<p><code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，能够按照添加的顺序遍历；</p>
<p><code>TreeSet</code> 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。</p>
<h3 id="EnumSet是什么？"><a href="#EnumSet是什么？" class="headerlink" title="EnumSet是什么？"></a>EnumSet是什么？</h3><p>java.util.EnumSet是使用枚举类型的集合实现。当集合创建时，枚举集合中的所有元素必须来自单个指定的枚举类型，可以是显示的或隐示的。EnumSet是不同步的，不允许值为null的元素</p>
<h3 id="TreeSet-有用过么，平时都在什么场景下使用"><a href="#TreeSet-有用过么，平时都在什么场景下使用" class="headerlink" title="TreeSet 有用过么，平时都在什么场景下使用"></a>TreeSet 有用过么，平时都在什么场景下使用</h3><p>一般都是在需要把元素进行排序的时候使用 TreeSet，使用时需要我们注意元素最好实现 Comparable 接口，这样方便底层的 TreeMap 根据 key 进行排序。</p>
<h4 id="追问，如果我想实现根据-key-的新增顺序进行遍历怎么办"><a href="#追问，如果我想实现根据-key-的新增顺序进行遍历怎么办" class="headerlink" title="追问，如果我想实现根据 key 的新增顺序进行遍历怎么办"></a>追问，如果我想实现根据 key 的新增顺序进行遍历怎么办</h4><p>要按照 key 的新增顺序进行遍历，首先想到的应该就是 LinkedHashMap，而 LinkedHashSet 正好是基于 LinkedHashMap 实现的，所以我们可以选择使用 LinkedHashSet。</p>
<h4 id="追问，如果我想对-key-进行去重，有什么好的办法么？"><a href="#追问，如果我想对-key-进行去重，有什么好的办法么？" class="headerlink" title="追问，如果我想对 key 进行去重，有什么好的办法么？"></a>追问，如果我想对 key 进行去重，有什么好的办法么？</h4><p>我们首先想到的是 TreeSet，TreeSet 底层使用的是 TreeMap，TreeMap 在 put 的时候，如果发现 key 是相同的，会把 value 值进行覆盖，所有不会产生重复的 key ，利用这一特性，使用 TreeSet 正好可以去重。</p>
<h4 id="说说-TreeSet-和-HashSet-两个-Set-的内部实现结构和原理？"><a href="#说说-TreeSet-和-HashSet-两个-Set-的内部实现结构和原理？" class="headerlink" title="说说 TreeSet 和 HashSet 两个 Set 的内部实现结构和原理？"></a>说说 TreeSet 和 HashSet 两个 Set 的内部实现结构和原理？</h4><p>HashSet 底层对 HashMap 的能力进行封装，比如说 add 方法，是直接使用 HashMap 的 put 方法，比较简单，但在初始化的时候，我看源码有一些感悟：说一下 HashSet 小结的四小点。</p>
<p>TreeSet 主要是对 TreeMap 底层能力进行封装复用，我发现了两种非常有意思的复用思路，重复 TreeSet 两种复用思路。</p>
<h2 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h2><h3 id="Map相关类"><a href="#Map相关类" class="headerlink" title="Map相关类"></a>Map相关类</h3><p><img src="https://img1.sycdn.imooc.com/5e6af08a00013e4c16000500.jpg" alt="图片描述"></p>
<h3 id="jdk8中对HashMap做了哪些改变"><a href="#jdk8中对HashMap做了哪些改变" class="headerlink" title="jdk8中对HashMap做了哪些改变?"></a>jdk8中对HashMap做了哪些改变?</h3><ul>
<li><p><code>在java1.7中</code>使用数组+链表在<code>java1.8</code>中改成了数组+链表或红黑树,如果链表的长度超过了8,那么链表将转换为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树)</p>
</li>
<li><p>发生<code>hash</code>碰撞时,<code>java1.7</code>会在链表的头部插入,而<code>java1.8</code>会在链表的尾部插入</p>
</li>
<li><p>在<code>java1.8</code>中,<code>Entry</code>被<code>Node</code>替代(换了一个马甲)。</p>
</li>
<li><p>扩容的时候1.7需要对原数组中的元素进行重新hash定位在新数组的位置，1.8采用更简单的判断逻辑，位置不变或索引+旧容量大小；</p>
</li>
<li><p>在插入时，1.7先判断是否需要扩容，再插入，1.8先进行插入，插入完成再判断是否需要扩容；</p>
</li>
</ul>
<h3 id="为什么JDK1-8使用红黑树？"><a href="#为什么JDK1-8使用红黑树？" class="headerlink" title="为什么JDK1.8使用红黑树？"></a>为什么JDK1.8使用红黑树？</h3><p>比如某些人通过找到你的hash碰撞值，来让你的HashMap不断地产生碰撞，那么相同key位置的链表就会不断增长，当你需要对这个HashMap的相应位置进行查询的时候，就会去循环遍历这个超级大的链表，性能及其地下。java8使用红黑树来替代超过8个节点数的链表后，查询方式性能得到了很好的提升，从原来的是O(n)到O(logn)。</p>
<h3 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h3><ol>
<li><p><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>HashTable</code> 是线程安全的,因为 <code>HashTable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</p>
</li>
<li><p><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>HashTable</code> 效率高一点。另外，<code>HashTable</code> 基本被淘汰，不要在代码中使用它；</p>
</li>
<li><p><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</p>
</li>
<li><p><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> </p>
<p>① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</p>
<p>② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</p>
</li>
<li><p><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p>
</li>
</ol>
<h3 id="HashMap-和-HashSet-区别"><a href="#HashMap-和-HashSet-区别" class="headerlink" title="HashMap 和 HashSet 区别"></a>HashMap 和 HashSet 区别</h3><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：<code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p>
<table>
<thead>
<tr>
<th><code>HashMap</code></th>
<th><code>HashSet</code></th>
</tr>
</thead>
<tbody><tr>
<td>实现了 <code>Map</code> 接口</td>
<td>实现 <code>Set</code> 接口</td>
</tr>
<tr>
<td>存储键值对</td>
<td>仅存储对象</td>
</tr>
<tr>
<td>调用 <code>put()</code>向 map 中添加元素</td>
<td>调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td>
</tr>
<tr>
<td><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td>
<td><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code> equals()</code>方法用来判断对象的相等性</td>
</tr>
</tbody></table>
<h3 id="HashMap-和-TreeMap-区别"><a href="#HashMap-和-TreeMap-区别" class="headerlink" title="HashMap 和 TreeMap 区别"></a>HashMap 和 TreeMap 区别</h3><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p>
<img src="https://snailclimb.gitee.io/javaguide/docs/java/collection/images/TreeMap继承结构.png" alt="img" style="zoom:50%;" />

<p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p>
<p>实现<code>SortMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020年06月15日 17:02:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Person, String&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person person1, Person person2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> num = person1.getAge() - person2.getAge();</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(num, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Person(<span class="number">3</span>), <span class="string">&quot;person1&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Person(<span class="number">18</span>), <span class="string">&quot;person2&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Person(<span class="number">35</span>), <span class="string">&quot;person3&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Person(<span class="number">16</span>), <span class="string">&quot;person4&quot;</span>);</span><br><span class="line">        treeMap.entrySet().stream().forEach(personStringEntry -&gt; &#123;</span><br><span class="line">            System.out.println(personStringEntry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person1</span><br><span class="line">person4</span><br><span class="line">person2</span><br><span class="line">person3</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>TreeMap</code> 中的元素已经是按照 <code>Person</code> 的 age 字段的升序来排列了。</p>
<p>上面，我们是通过传入匿名内部类的方式实现的，你可以将代码替换成 Lambda 表达式实现的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Person, String&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;((person1, person2) -&gt; &#123;</span><br><span class="line">  <span class="keyword">int</span> num = person1.getAge() - person2.getAge();</span><br><span class="line">  <span class="keyword">return</span> Integer.compare(num, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>综上，相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p>
<h3 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复"></a>HashSet 如何检查重复</h3><p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>
<h3 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h3><ul>
<li><p><strong>基础特性不同</strong><br>HashMap 的 key 和 value 可以为 null，ConcurrentHashMap，hashtable 的 key 和 value 不能为 null</p>
<p><strong>hashtable,concurrenthashmap为什么键和值不能为null，而hashmap可以？</strong></p>
<ul>
<li>因为concurrenthashmap它们是用于<strong>多线程</strong>的，<strong>并发的</strong> ，如果map.get(key)得到了null，不能判断到底是映射的value是null,还是因为没有找到对应的key而为空，而用于单线程状态的hashmap却可以用containKey（key） 去判断到底是否包含了这个null。<ul>
<li>concurrenthashmap为什么就不能containKey(key) ？一个线程先get(key)再containKey(key)，这两个方法的中间时刻，其他线程怎么操作这个key都会可能发生，例如删掉这个key</li>
</ul>
</li>
<li>HashMap计算key的hash值时调用单独的方法，在该方法中会判断key是否为null，如果是则返回0；而Hashtable中则直接调用key的hashCode()方法，因此如果key为null，则抛出空指针异常。</li>
</ul>
</li>
<li><p><strong>底层数据结构：</strong> </p>
<ul>
<li>JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 的 <code>ConcurrentHashMap</code>  采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。</li>
<li><code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
</ul>
</li>
<li><p><strong>实现线程安全的方式（重要）：</strong> </p>
<ul>
<li>① <strong>在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。</strong></li>
<li>② <strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
</li>
</ul>
<h3 id="ConcurrentHashMap-和-HashMap-两者区别："><a href="#ConcurrentHashMap-和-HashMap-两者区别：" class="headerlink" title="ConcurrentHashMap 和 HashMap 两者区别："></a>ConcurrentHashMap 和 HashMap 两者区别：</h3><ul>
<li>相同之处：</li>
</ul>
<ol>
<li>数组、链表结构几乎相同，所以底层对数据结构的操作思路是相同的（只是思路相同，底层实现不同）；</li>
<li>都实现了 Map 接口，继承了 AbstractMap 抽象类，所以大多数的方法也都是相同的，HashMap  有的方法，ConcurrentHashMap 几乎都有，所以当我们需要从 HashMap 切换到 ConcurrentHashMap  时，无需关心两者之间的兼容问题。</li>
</ol>
<ul>
<li>不同之处：</li>
</ul>
<ol>
<li>红黑树结构略有不同，HashMap 的红黑树中的节点叫做 TreeNode，TreeNode  不仅仅有属性，还维护着红黑树的结构，比如说查找，新增等等；ConcurrentHashMap 中红黑树被拆分成两块，TreeNode  仅仅维护的属性和查找功能，新增了 TreeBin，来维护红黑树结构，并负责根节点的加锁和解锁；</li>
<li>新增 ForwardingNode （转移）节点，扩容的时候会使用到，通过使用该节点，来保证扩容时的线程安全。</li>
</ol>
<h3 id="为什么-ConcurrentHashMap-可以在高并发的情况下比-HashMap-更为高效"><a href="#为什么-ConcurrentHashMap-可以在高并发的情况下比-HashMap-更为高效" class="headerlink" title="为什么 ConcurrentHashMap 可以在高并发的情况下比 HashMap 更为高效"></a>为什么 ConcurrentHashMap 可以在高并发的情况下比 HashMap 更为高效</h3><ul>
<li>HashTable使用一把锁处理并发问题，当有多个线程访问时，需要多个线程竞争一把锁，导致阻塞</li>
<li>ConcurrentHashMap则使用分段，相当于把一个HashMap分成多个，然后每个部分分配一把锁，这样就可以支持多线程访问</li>
</ul>
<h3 id="HashMap-LinkedHashMap-TreeMap的区别"><a href="#HashMap-LinkedHashMap-TreeMap的区别" class="headerlink" title="HashMap,LinkedHashMap,TreeMap的区别"></a>HashMap,LinkedHashMap,TreeMap的区别</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ol>
<li>三者在特定的情况下，都会使用红黑树；</li>
<li>底层的 hash 算法相同；</li>
<li>在迭代的过程中，如果 Map 的数据结构被改动，都会报 ConcurrentModificationException 的错误。</li>
</ol>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul>
<li>HashMap 数据结构以数组为主，查询非常快，HashMap是无序的；TreeMap 数据结构以红黑树为主，利用了红黑树左小右大的特点，可以实现 key 的排序，LinkedHashMap 在 HashMap 的基础上增加了链表的结构，实现了插入顺序访问和最少访问删除两种策略;</li>
<li>由于三种 Map 底层数据结构的差别，导致了三者的使用场景的不同，TreeMap 适合需要根据 key  进行排序的场景，LinkedHashMap 适合按照插入顺序访问，或需要删除最少访问元素的场景，剩余场景我们使用 HashMap  即可，我们工作中大部分场景基本都在使用 HashMap；</li>
<li>由于三种 map 的底层数据结构的不同，导致上层包装的 api 略有差别。</li>
</ul>
<h3 id="WeakHashMap-ConcurrentHashMap-IdentityHashMap的区别"><a href="#WeakHashMap-ConcurrentHashMap-IdentityHashMap的区别" class="headerlink" title="WeakHashMap,ConcurrentHashMap,IdentityHashMap的区别"></a>WeakHashMap,ConcurrentHashMap,IdentityHashMap的区别</h3><ul>
<li><strong>WeakHashMap</strong>表示<strong>弱键映射</strong>，允许释放映射所指向的对象。这是为了解决某类特殊问题而设计的，如果映射之外没有引用指向某个“键”，则“键”可以被垃圾收集器回收。</li>
<li><strong>ConcurrentHashMap</strong>一种线程安全的Map,它不涉及同步加锁。</li>
<li><strong>IdentityHashMap</strong>使用==代替equals() 对“键”进行比较的散列映射。专为解决特殊问题而设计。</li>
</ul>
<h3 id="WeakHashMap与HashMap的区别是什么"><a href="#WeakHashMap与HashMap的区别是什么" class="headerlink" title="WeakHashMap与HashMap的区别是什么"></a>WeakHashMap与HashMap的区别是什么</h3><p>WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。</p>
<h3 id="TreeMap-整体架构"><a href="#TreeMap-整体架构" class="headerlink" title="TreeMap 整体架构"></a>TreeMap 整体架构</h3><p>TreeMap 底层的数据结构就是红黑树，和 HashMap 的红黑树结构一样。</p>
<p>不同的是，TreeMap 利用了红黑树左节点小，右节点大的性质，根据 key 进行排序，使每个元素能够插入到红黑树大小适当的位置，维护了 key 的大小关系，适用于 key 需要排序的场景。</p>
<p>因为底层使用的是平衡红黑树的结构，所以 containsKey、get、put、remove 等方法的时间复杂度都是 log(n)。</p>
<h4 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h4><p>过程：</p>
<ol>
<li><p>判断红黑树的节点是否为空，为空的话，新增的节点直接作为根节点</p>
</li>
<li><p>根据红黑树左小右大的特性，进行判断，找到应该新增节点的父节点</p>
</li>
<li><p>在父节点的左边或右边插入新增节点</p>
</li>
<li><p>着色旋转，达到平衡</p>
</li>
</ol>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ol>
<li>新增节点时，就是利用了红黑树左小右大的特性，从根节点不断往下查找，直到找到节点是 null 为止，节点为 null 说明到达了叶子结点；</li>
<li>查找过程中，发现 key 值已经存在，直接覆盖；</li>
<li>TreeMap 是禁止 key 是 null 值的。</li>
</ol>
<h3 id="LinkedHashMap-整体架构"><a href="#LinkedHashMap-整体架构" class="headerlink" title="LinkedHashMap 整体架构"></a>LinkedHashMap 整体架构</h3><h4 id="按照插入顺序访问"><a href="#按照插入顺序访问" class="headerlink" title="按照插入顺序访问"></a>按照插入顺序访问</h4><h5 id="LinkedHashMap-链表结构"><a href="#LinkedHashMap-链表结构" class="headerlink" title="LinkedHashMap 链表结构"></a>LinkedHashMap 链表结构</h5><p>LinkedHashMap 的数据结构很像是把 LinkedList 的每个元素换成了 HashMap 的  Node，像是两者的结合体，也正是因为增加了这些结构，从而能把 Map  的元素都串联起来，形成一个链表，而链表就可以保证顺序了，就可以维护元素插入进来的顺序。</p>
<h4 id="如何按照顺序新增"><a href="#如何按照顺序新增" class="headerlink" title="如何按照顺序新增"></a>如何按照顺序新增</h4><p>LinkedHashMap 初始化时，默认 accessOrder 为 false，就是会按照插入顺序提供访问，插入方法使用的是父类  HashMap 的 put 方法，不过覆写了 put 方法执行中调用的 newNode/newTreeNode 和  afterNodeAccess 方法。</p>
<h4 id="按照顺序访问"><a href="#按照顺序访问" class="headerlink" title="按照顺序访问"></a>按照顺序访问</h4><p>LinkedHashMap 只提供了单向访问，即按照插入的顺序从头到尾进行访问，不能像 LinkedList 那样可以双向访问。</p>
<h4 id="访问最少删除策略"><a href="#访问最少删除策略" class="headerlink" title="访问最少删除策略"></a>访问最少删除策略</h4><p>经常访问的元素会被追加到队尾，这样不经常访问的数据自然就靠近队头，然后我们可以通过设置删除策略，比如当 Map 元素个数大于多少时，把头节点删除</p>
<h3 id="为何Map接口不继承Collection接口"><a href="#为何Map接口不继承Collection接口" class="headerlink" title="为何Map接口不继承Collection接口"></a>为何Map接口不继承Collection接口</h3><p>尽管Map接口和它的实现也是集合框架的一部分，但Map不是集合，集合也不是Map。因此，Map继承Collection毫无意义，反之亦然。</p>
<p>如果Map继承Collection接口，那么元素去哪儿？Map包含key-value对，它提供抽取key或value列表集合的方法，但是它不适合“一组对象”规范。</p>
<h3 id="我们能否使用任何类作为Map的key"><a href="#我们能否使用任何类作为Map的key" class="headerlink" title="我们能否使用任何类作为Map的key"></a>我们能否使用任何类作为Map的key</h3><p>我们可以使用任何类作为Map的key，然而在使用它们之前，需要考虑以下几点：</p>
<p>（1）如果类重写了equals()方法，它也应该重写hashCode()方法。</p>
<p>（2）类的所有实例需要遵循与equals()和hashCode()相关的规则。</p>
<p>（3）如果一个类没有使用equals()，你不应该在hashCode()中使用它。</p>
<p>（4）用户自定义key类的最佳实践是使之为不可变的，这样，hashCode()值可以被缓存起来，拥有更好的性能。不可变的类也可以确保hashCode()和equals()在未来不会改变，这样就会解决与可变相关的问题了。</p>
<h3 id="DTO-作为-Map-的-key-时，有无需要注意的点？"><a href="#DTO-作为-Map-的-key-时，有无需要注意的点？" class="headerlink" title="DTO 作为 Map 的 key 时，有无需要注意的点？"></a>DTO 作为 Map 的 key 时，有无需要注意的点？</h3><p>DTO 就是一个数据载体，可以看做拥有很多属性的 Java 类，我们可以对这些属性进行 get、set 操作。</p>
<p>看是什么类型的 Map，如果是 HashMap 的话，一定需要覆写 equals 和 hashCode 方法，因为在 get 和 put  的时候，需要通过 equals 方法进行相等的判断；如果是 TreeMap 的话，DTO 需要实现 Comparable 接口，因为  TreeMap 会使用 Comparable 接口进行判断 key 的大小；如果是 LinkedHashMap 的话，和 HashMap  一样的。</p>
<h3 id="Map接口提供了哪些不同的集合视图"><a href="#Map接口提供了哪些不同的集合视图" class="headerlink" title="Map接口提供了哪些不同的集合视图"></a>Map接口提供了哪些不同的集合视图</h3><p>Map接口提供三个集合视图：</p>
<p>（1）Set  keyset()：返回map中包含的所有key的一个Set视图。集合是受map支持的，map的变化会在集合中反映出来，反之亦然。当一个迭代器正在遍历一个集合时，若map被修改了（除迭代器自身的移除操作以外），迭代器的结果会变为未定义。集合支持通过Iterator的Remove、Set.remove、removeAll、retainAll和clear操作进行元素移除，从map中移除对应的映射。它不支持add和addAll操作。</p>
<p>（2）Collection  values()：返回一个map中包含的所有value的一个Collection视图。这个collection受map支持的，map的变化会在collection中反映出来，反之亦然。当一个迭代器正在遍历一个collection时，若map被修改了（除迭代器自身的移除操作以外），迭代器的结果会变为未定义。集合支持通过Iterator的Remove、Set.remove、removeAll、retainAll和clear操作进行元素移除，从map中移除对应的映射。它不支持add和addAll操作。</p>
<p>（3）Set&lt;Map.Entry&lt;K,V&gt;&gt;  entrySet()：返回一个map钟包含的所有映射的一个集合视图。这个集合受map支持的，map的变化会在collection中反映出来，反之亦然。当一个迭代器正在遍历一个集合时，若map被修改了（除迭代器自身的移除操作，以及对迭代器返回的entry进行setValue外），迭代器的结果会变为未定义。集合支持通过Iterator的Remove、Set.remove、removeAll、retainAll和clear操作进行元素移除，从map中移除对应的映射。它不支持add和addAll操作。</p>
<h3 id="如何决定选用HashMap还是TreeMap"><a href="#如何决定选用HashMap还是TreeMap" class="headerlink" title="如何决定选用HashMap还是TreeMap"></a>如何决定选用HashMap还是TreeMap</h3><p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p>
<h3 id="TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？"><a href="#TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？" class="headerlink" title="TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？"></a>TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</h3><p>reeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java中对函数式编程的支持）。</p>
<h3 id="为解决-hash-冲突，大概有哪些办法"><a href="#为解决-hash-冲突，大概有哪些办法" class="headerlink" title="为解决 hash 冲突，大概有哪些办法"></a>为解决 hash 冲突，大概有哪些办法</h3><p>1：好的 hash 算法，细问的话复述一下上题的 hash 算法;</p>
<p>2：自动扩容，当数组大小快满的时候，采取自动扩容，可以减少 hash 冲突;</p>
<p>3：hash 冲突发生时，采用链表来解决;</p>
<p>4：hash 冲突严重时，链表会自动转化成红黑树，提高遍历速度。</p>
<h3 id="通过以下代码进行删除，是否可行？"><a href="#通过以下代码进行删除，是否可行？" class="headerlink" title="通过以下代码进行删除，是否可行？"></a>通过以下代码进行删除，是否可行？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String,String &gt; map = Maps.newHashMap();</span><br><span class="line">map.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">map.forEach((s, s2) -&gt; map.remove(<span class="string">&quot;1&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>答：不行，会报错误 ConcurrentModificationException，原因如下图：</p>
<img src="https://nexus-oss-blog.oss-cn-beijing.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/%E5%AE%B9%E5%99%A8/image.png" style="zoom:67%;" />

<p>建议使用迭代器的方式进行删除，原理同 ArrayList 迭代器原理</p>
<h3 id="HashMap-在-put-时，如果数组中已经有了这个-key，我不想把-value-覆盖怎么办？取值时，如果得到的-value-是空时，想返回默认值怎么办"><a href="#HashMap-在-put-时，如果数组中已经有了这个-key，我不想把-value-覆盖怎么办？取值时，如果得到的-value-是空时，想返回默认值怎么办" class="headerlink" title="HashMap 在 put 时，如果数组中已经有了这个 key，我不想把 value 覆盖怎么办？取值时，如果得到的 value 是空时，想返回默认值怎么办"></a>HashMap 在 put 时，如果数组中已经有了这个 key，我不想把 value 覆盖怎么办？取值时，如果得到的 value 是空时，想返回默认值怎么办</h3><p>如果数组有了 key，但不想覆盖 value ，可以选择 putIfAbsent 方法，这个方法有个内置变量 onlyIfAbsent，内置是 true ，就不会覆盖，我们平时使用的 put 方法，内置 onlyIfAbsent 为 false，是允许覆盖的。</p>
<p>取值时，如果为空，想返回默认值，可以使用 getOrDefault 方法，方法第一参数为 key，第二个参数为你想返回的默认值，如 map.getOrDefault(“2”,“0”)，当 map 中没有 key 为 2 的值时，会默认返回 0，而不是空。</p>
<h3 id="LinkedHashMap-中的-LRU-是什么意思，是如何实现的。"><a href="#LinkedHashMap-中的-LRU-是什么意思，是如何实现的。" class="headerlink" title="LinkedHashMap 中的 LRU 是什么意思，是如何实现的。"></a>LinkedHashMap 中的 LRU 是什么意思，是如何实现的。</h3><p>LRU ，英文全称：Least recently used，中文叫做最近最少访问，在 LinkedHashMap 中，也叫做最少访问删除策略，我们可以通过 removeEldestEntry 方法设定一定的策略，使最少被访问的元素，在适当的时机被删除，原理是在 put 方法执行的最后，LinkedHashMap 会去检查这种策略，如果满足策略，就删除头节点。</p>
<p>保证头节点就是最少访问的元素的原理是：LinkedHashMap 在 get 的时候，都会把当前访问的节点，移动到链表的尾部，慢慢的，就会使头部的节点都是最少被访问的元素。</p>
<h3 id="为什么推荐-TreeMap-的元素最好都实现-Comparable-接口？但-key-是-String-的时候，我们却没有额外的工作呢？"><a href="#为什么推荐-TreeMap-的元素最好都实现-Comparable-接口？但-key-是-String-的时候，我们却没有额外的工作呢？" class="headerlink" title="为什么推荐 TreeMap 的元素最好都实现 Comparable 接口？但 key 是 String 的时候，我们却没有额外的工作呢？"></a>为什么推荐 TreeMap 的元素最好都实现 Comparable 接口？但 key 是 String 的时候，我们却没有额外的工作呢？</h3><p>答：因为 TreeMap 的底层就是通过排序来比较两个 key 的大小的，所以推荐 key 实现 Comparable 接口，是为了往你希望的排序顺序上发展， 而 String 本身已经实现了 Comparable 接口，所以使用 String 时，我们不需要额外的工作，不仅仅是 String ，其他包装类型也都实现了 Comparable 接口，如 Long、Double、Short 等等。</p>
<h2 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h2><p>Collections 工具类常用方法:</p>
<ol>
<li>排序</li>
<li>查找,替换操作</li>
<li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</li>
</ol>
<h3 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list, Comparator c)</span><span class="comment">//定制排序，由Comparator控制排序逻辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List list, <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List list, <span class="keyword">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</span></span></span><br></pre></td></tr></table></figure>

<h3 id="查找-替换操作"><a href="#查找-替换操作" class="headerlink" title="查找,替换操作"></a>查找,替换操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List list, Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span>, 用新元素替换旧元素</span></span><br></pre></td></tr></table></figure>

<h3 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h3><p><code>Collections</code> 提供了多个<code>synchronizedXxx()</code>方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</p>
<p>我们知道 <code>HashSet</code>，<code>TreeSet</code>，<code>ArrayList</code>,<code>LinkedList</code>,<code>HashMap</code>,<code>TreeMap</code> 都是线程不安全的。<code>Collections</code> 提供了多个静态方法可以把他们包装成线程同步的集合。</p>
<p><strong>最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。</strong></p>
<p>方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronizedCollection(Collection&lt;T&gt;  c) <span class="comment">//返回指定 collection 支持的同步（线程安全的）collection。</span></span><br><span class="line">synchronizedList(List&lt;T&gt; list)<span class="comment">//返回指定列表支持的同步（线程安全的）List。</span></span><br><span class="line">synchronizedMap(Map&lt;K,V&gt; m) <span class="comment">//返回由指定映射支持的同步（线程安全的）Map。</span></span><br><span class="line">synchronizedSet(Set&lt;T&gt; s) <span class="comment">//返回指定 set 支持的同步（线程安全的）set。</span></span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
            <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          
            <a href="/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag"># Java基础知识</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/04/13/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" rel="next" title="网络相关知识">
                <i class="fa fa-chevron-left"></i> 网络相关知识
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/04/13/Java-ArrayList%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" rel="prev" title="Java-ArrayList源码学习">
                Java-ArrayList源码学习 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <!--<a href="/archives/%7C%7Carchive">-->
                <a href="/archives/">
              
                  <span class="site-state-item-count">58</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuanyayuan" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:liyuan0707@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="nav-number">1.</span> <span class="nav-text">Java 集合框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">集合概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E9%9B%86%E5%90%88%E6%A6%82%E8%A7%88"><span class="nav-number">1.1.1.</span> <span class="nav-text">Java 集合概览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Collections%E7%B1%BB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.1.2.</span> <span class="nav-text">Collections类是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-List-Set-Map-%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.3.</span> <span class="nav-text">说说 List,Set,Map 三者的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93"><span class="nav-number">1.1.4.</span> <span class="nav-text">集合框架底层数据结构总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#List"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Set"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">Map</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E7%94%A8%E9%9B%86%E5%90%88"><span class="nav-number">1.1.5.</span> <span class="nav-text">如何选用集合?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%EF%BC%9F"><span class="nav-number">1.1.6.</span> <span class="nav-text">为什么要使用集合？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List%E3%80%81Set%E3%80%81Map-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.1.7.</span> <span class="nav-text">List、Set、Map 之间的区别是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Iterator%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.1.8.</span> <span class="nav-text">Iterator是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">1.1.9.</span> <span class="nav-text">迭代器的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Enumeration%E5%92%8CIterator%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.10.</span> <span class="nav-text">Enumeration和Iterator接口的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%AD%E7%9A%84Iterator%E5%92%8CListIterator%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.11.</span> <span class="nav-text">Java集合类中的Iterator和ListIterator的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E9%9B%86%E5%90%88%E7%9A%84%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%EF%BC%88fail-fast%EF%BC%89%E5%92%8C%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5%EF%BC%88fail-safe%EF%BC%89%E7%9A%84%E5%B7%AE%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.12.</span> <span class="nav-text">Java 集合的快速失败（fail-fast）和安全失败（fail-safe）的差别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9"><span class="nav-number">1.1.13.</span> <span class="nav-text">集合框架中的泛型有什么优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9A%84%E5%9F%BA%E7%A1%80%E6%8E%A5%E5%8F%A3%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.1.14.</span> <span class="nav-text">Java集合框架的基础接口有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BD%95Collection%E4%B8%8D%E4%BB%8ECloneable%E5%92%8CSerializable%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF"><span class="nav-number">1.1.15.</span> <span class="nav-text">为何Collection不从Cloneable和Serializable接口继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E9%9B%86%E5%90%88%E7%B1%BB%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84"><span class="nav-number">1.1.16.</span> <span class="nav-text">哪些集合类是线程安全的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E7%B1%BB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.1.17.</span> <span class="nav-text">并发集合类是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8F%88%E6%95%88%E7%8E%87%E9%AB%98"><span class="nav-number">1.1.18.</span> <span class="nav-text">如何保证线程安全又效率高</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E7%A1%AE%E4%BF%9D%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E4%B8%8D%E8%83%BD%E8%A2%AB%E4%BF%AE%E6%94%B9"><span class="nav-number">1.1.19.</span> <span class="nav-text">怎么确保一个集合不能被修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E9%9B%86%E5%90%88%E7%B1%BB%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%85%83%E7%B4%A0%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE"><span class="nav-number">1.1.20.</span> <span class="nav-text">哪些集合类提供对元素的随机访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8EJava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E6%9C%89%E5%93%AA%E4%BA%9B%E6%9C%80%E5%A5%BD%E7%9A%84%E5%AE%9E%E8%B7%B5"><span class="nav-number">1.1.21.</span> <span class="nav-text">与Java集合框架相关的有哪些最好的实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E6%80%A7%E8%83%BD"><span class="nav-number">1.1.22.</span> <span class="nav-text">集合性能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%B9%E9%87%8F%E6%96%B0%E5%A2%9E"><span class="nav-number">1.1.22.1.</span> <span class="nav-text">批量新增</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4"><span class="nav-number">1.1.22.2.</span> <span class="nav-text">批量删除</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E9%81%BF%E5%9D%91"><span class="nav-number">1.1.23.</span> <span class="nav-text">集合使用避坑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java8%E5%AF%B9%E9%9B%86%E5%90%88%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="nav-number">1.1.24.</span> <span class="nav-text">Java8对集合的修改</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-8-%E5%9C%A8-List%E3%80%81Map-%E6%8E%A5%E5%8F%A3%E4%B8%8A%E6%96%B0%E5%A2%9E%E4%BA%86%E5%BE%88%E5%A4%9A%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88-Java-7-%E4%B8%AD%E8%BF%99%E4%BA%9B%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%80%85%E4%B8%8D%E9%9C%80%E8%A6%81%E5%BC%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%BF%99%E4%BA%9B%E6%96%B9%E6%B3%95%E5%91%A2%EF%BC%9F"><span class="nav-number">1.1.24.1.</span> <span class="nav-text">Java 8 在 List、Map 接口上新增了很多方法，为什么 Java 7 中这些接口的实现者不需要强制实现这些方法呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-8-%E9%9B%86%E5%90%88%E6%96%B0%E5%A2%9E%E4%BA%86-forEach-%E6%96%B9%E6%B3%95%EF%BC%8C%E5%92%8C%E6%99%AE%E9%80%9A%E7%9A%84-for-%E5%BE%AA%E7%8E%AF%E6%9C%89%E5%95%A5%E4%B8%8D%E5%90%8C"><span class="nav-number">1.1.24.2.</span> <span class="nav-text">Java 8 集合新增了 forEach 方法，和普通的 for 循环有啥不同</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java7%E5%92%8CJava8-%E9%9B%86%E5%90%88%E4%B8%8A%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="nav-number">1.1.25.</span> <span class="nav-text">Java7和Java8 集合上的修改</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.25.1.</span> <span class="nav-text">通用区别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E9%9B%86%E5%90%88%E9%83%BD%E6%96%B0%E5%A2%9E%E4%BA%86forEach-%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.25.1.1.</span> <span class="nav-text">所有集合都新增了forEach 方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.25.2.</span> <span class="nav-text">List区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.25.3.</span> <span class="nav-text">Map区别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HashMap"><span class="nav-number">1.1.25.3.1.</span> <span class="nav-text">HashMap</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LinkedHashMap"><span class="nav-number">1.1.25.3.2.</span> <span class="nav-text">LinkedHashMap</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection-%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%B9%8B-List"><span class="nav-number">1.2.</span> <span class="nav-text">Collection 子接口之 List</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Arraylist-%E5%92%8C-Vector-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.1.</span> <span class="nav-text">Arraylist 和 Vector 的区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Arraylist-%E4%B8%8E-LinkedList-%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.2.</span> <span class="nav-text">Arraylist 与 LinkedList 区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-%E5%92%8C-LinkedList-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%B9-null-%E5%80%BC%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86%E7%9A%84"><span class="nav-number">1.2.3.</span> <span class="nav-text">ArrayList 和 LinkedList 是如何对 null 值进行处理的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84-Array-%E5%92%8C%E5%88%97%E8%A1%A8-ArrayList-%E7%9A%84%E5%B7%AE%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.2.4.</span> <span class="nav-text">数组(Array)和列表(ArrayList)的差别是什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-%E5%92%8C-LinkedList-%E9%83%BD%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%8C%E9%82%A3%E6%9C%89%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84-List-%E7%B1%BB%E5%90%97"><span class="nav-number">1.2.5.</span> <span class="nav-text">ArrayList 和 LinkedList 都不是线程安全的，那有线程安全的 List 类吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-%E5%92%8C-LinkedList-%E4%B8%A4%E8%80%85%E6%9C%89%E6%B2%A1%E6%9C%89%E6%9C%80%E5%A4%A7%E5%AE%B9%E9%87%8F"><span class="nav-number">1.2.6.</span> <span class="nav-text">ArrayList 和 LinkedList 两者有没有最大容量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-%E5%92%8C-LinedList-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.2.7.</span> <span class="nav-text">ArrayList 和 LinedList 是线程安全的么，为什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-%E6%97%A0%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0%E5%99%A8%E6%9E%84%E9%80%A0%EF%BC%8C%E7%8E%B0%E5%9C%A8-add-%E4%B8%80%E4%B8%AA%E5%80%BC%E8%BF%9B%E5%8E%BB%EF%BC%8C%E6%AD%A4%E6%97%B6%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%8C%E4%B8%8B%E4%B8%80%E6%AC%A1%E6%89%A9%E5%AE%B9%E5%89%8D%E6%9C%80%E5%A4%A7%E5%8F%AF%E7%94%A8%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="nav-number">1.2.8.</span> <span class="nav-text">ArrayList 无参数构造器构造，现在 add 一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%88%91%E8%BF%9E%E7%BB%AD%E5%BE%80-list-%E9%87%8C%E9%9D%A2%E6%96%B0%E5%A2%9E%E5%80%BC%EF%BC%8C%E5%A2%9E%E5%8A%A0%E5%88%B0%E7%AC%AC-11-%E4%B8%AA%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="nav-number">1.2.9.</span> <span class="nav-text">如果我连续往 list 里面新增值，增加到第 11 个的时候，数组的大小是多少？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E8%A2%AB%E5%8A%A0%E5%85%A5%E4%B8%80%E4%B8%AA%E5%80%BC%E5%90%8E%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%88%91%E4%BD%BF%E7%94%A8-addAll-%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%80%E4%B8%8B%E5%AD%90%E5%8A%A0%E5%85%A5-15-%E4%B8%AA%E5%80%BC%EF%BC%8C%E9%82%A3%E4%B9%88%E6%9C%80%E7%BB%88%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="nav-number">1.2.10.</span> <span class="nav-text">数组初始化，被加入一个值后，如果我使用 addAll 方法，一下子加入 15 个值，那么最终数组的大小是多少</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%B0%E5%9C%A8%E6%88%91%E6%9C%89%E4%B8%80%E4%B8%AA%E5%BE%88%E5%A4%A7%E7%9A%84%E6%95%B0%E7%BB%84%E9%9C%80%E8%A6%81%E6%8B%B7%E8%B4%9D%EF%BC%8C%E5%8E%9F%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F%E6%98%AF-5k%EF%BC%8C%E8%AF%B7%E9%97%AE%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="nav-number">1.2.11.</span> <span class="nav-text">现在我有一个很大的数组需要拷贝，原数组大小是 5k，请问如何快速拷贝？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E6%89%A9%E5%AE%B9%E4%BC%9A%E6%B6%88%E8%80%97%E6%80%A7%E8%83%BD"><span class="nav-number">1.2.12.</span> <span class="nav-text">为什么说扩容会消耗性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%80%BC%E5%BE%97%E5%80%9F%E9%89%B4%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="nav-number">1.2.13.</span> <span class="nav-text">源码扩容过程有什么值得借鉴的地方</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E4%B8%80%E4%B8%AA-ArrayList%EF%BC%8C%E6%95%B0%E6%8D%AE%E6%98%AF-2%E3%80%813%E3%80%813%E3%80%813%E3%80%814%EF%BC%8C%E4%B8%AD%E9%97%B4%E6%9C%89%E4%B8%89%E4%B8%AA-3%EF%BC%8C%E7%8E%B0%E5%9C%A8%E6%88%91%E9%80%9A%E8%BF%87-for-int-i-0-i-lt-list-size-i-%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%83%B3%E6%8A%8A%E5%80%BC%E6%98%AF-3-%E7%9A%84%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4%EF%BC%8C%E8%AF%B7%E9%97%AE%E5%8F%AF%E4%BB%A5%E5%88%A0%E9%99%A4%E5%B9%B2%E5%87%80%E4%B9%88%EF%BC%9F%E6%9C%80%E7%BB%88%E5%88%A0%E9%99%A4%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%E5%88%A0%E9%99%A4%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="nav-number">1.2.14.</span> <span class="nav-text">有一个 ArrayList，数据是 2、3、3、3、4，中间有三个 3，现在我通过 for (int i&#x3D;0;i&lt;list.size ();i++) 的方式，想把值是 3 的元素删除，请问可以删除干净么？最终删除的结果是什么，为什么？删除代码如下：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%98%E6%98%AF%E4%B8%8A%E9%9D%A2%E7%9A%84-ArrayList-%E6%95%B0%E7%BB%84%EF%BC%8C%E6%88%91%E4%BB%AC%E9%80%9A%E8%BF%87%E5%A2%9E%E5%BC%BA-for-%E5%BE%AA%E7%8E%AF%E8%BF%9B%E8%A1%8C%E5%88%A0%E9%99%A4%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%B9%88"><span class="nav-number">1.2.14.1.</span> <span class="nav-text">还是上面的 ArrayList 数组，我们通过增强 for 循环进行删除，可以么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%98%E6%98%AF%E4%B8%8A%E9%9D%A2%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%88%A0%E9%99%A4%E6%97%B6%E4%BD%BF%E7%94%A8-Iterator-remove-%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%88%A0%E9%99%A4%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-number">1.2.14.2.</span> <span class="nav-text">还是上面的数组，如果删除时使用 Iterator.remove () 方法可以删除么，为什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5%E4%B8%8A%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98%E5%AF%B9%E4%BA%8E-LinkedList-%E4%B9%9F%E6%98%AF%E5%90%8C%E6%A0%B7%E7%9A%84%E7%BB%93%E6%9E%9C%E4%B9%88%EF%BC%9F"><span class="nav-number">1.2.14.3.</span> <span class="nav-text">以上三个问题对于 LinkedList 也是同样的结果么？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-%E5%92%8C-LinedList-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F-1"><span class="nav-number">1.2.15.</span> <span class="nav-text">ArrayList 和 LinedList 是线程安全的么，为什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">1.2.16.</span> <span class="nav-text">如何解决线程安全问题？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">1.3.</span> <span class="nav-text">双向链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%96%B0%E5%A2%9E%E5%92%8C%E5%88%A0%E9%99%A4"><span class="nav-number">1.4.</span> <span class="nav-text">双向链表的新增和删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection-%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%B9%8B-Set"><span class="nav-number">1.5.</span> <span class="nav-text">Collection 子接口之 Set</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#comparable-%E5%92%8C-Comparator-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.5.1.</span> <span class="nav-text">comparable 和 Comparator 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Comparator-%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">Comparator 定制排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99-compareTo-%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%8C%89%E5%B9%B4%E9%BE%84%E6%9D%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">重写 compareTo 方法实现按年龄来排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%BA%8F%E6%80%A7%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7%E7%9A%84%E5%90%AB%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.5.2.</span> <span class="nav-text">无序性和不可重复性的含义是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83-HashSet%E3%80%81LinkedHashSet-%E5%92%8C-TreeSet-%E4%B8%89%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">1.5.3.</span> <span class="nav-text">比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EnumSet%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.5.4.</span> <span class="nav-text">EnumSet是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeSet-%E6%9C%89%E7%94%A8%E8%BF%87%E4%B9%88%EF%BC%8C%E5%B9%B3%E6%97%B6%E9%83%BD%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BD%BF%E7%94%A8"><span class="nav-number">1.5.5.</span> <span class="nav-text">TreeSet 有用过么，平时都在什么场景下使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%BD%E9%97%AE%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%88%91%E6%83%B3%E5%AE%9E%E7%8E%B0%E6%A0%B9%E6%8D%AE-key-%E7%9A%84%E6%96%B0%E5%A2%9E%E9%A1%BA%E5%BA%8F%E8%BF%9B%E8%A1%8C%E9%81%8D%E5%8E%86%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">追问，如果我想实现根据 key 的新增顺序进行遍历怎么办</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%BD%E9%97%AE%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%88%91%E6%83%B3%E5%AF%B9-key-%E8%BF%9B%E8%A1%8C%E5%8E%BB%E9%87%8D%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E7%9A%84%E5%8A%9E%E6%B3%95%E4%B9%88%EF%BC%9F"><span class="nav-number">1.5.5.2.</span> <span class="nav-text">追问，如果我想对 key 进行去重，有什么好的办法么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-TreeSet-%E5%92%8C-HashSet-%E4%B8%A4%E4%B8%AA-Set-%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84%E5%92%8C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-number">1.5.5.3.</span> <span class="nav-text">说说 TreeSet 和 HashSet 两个 Set 的内部实现结构和原理？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.6.</span> <span class="nav-text">Map 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Map%E7%9B%B8%E5%85%B3%E7%B1%BB"><span class="nav-number">1.6.1.</span> <span class="nav-text">Map相关类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jdk8%E4%B8%AD%E5%AF%B9HashMap%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E6%94%B9%E5%8F%98"><span class="nav-number">1.6.2.</span> <span class="nav-text">jdk8中对HashMap做了哪些改变?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88JDK1-8%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="nav-number">1.6.3.</span> <span class="nav-text">为什么JDK1.8使用红黑树？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.6.4.</span> <span class="nav-text">HashMap 和 Hashtable 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-%E5%92%8C-HashSet-%E5%8C%BA%E5%88%AB"><span class="nav-number">1.6.5.</span> <span class="nav-text">HashMap 和 HashSet 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-%E5%92%8C-TreeMap-%E5%8C%BA%E5%88%AB"><span class="nav-number">1.6.6.</span> <span class="nav-text">HashMap 和 TreeMap 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashSet-%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E9%87%8D%E5%A4%8D"><span class="nav-number">1.6.7.</span> <span class="nav-text">HashSet 如何检查重复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.6.8.</span> <span class="nav-text">ConcurrentHashMap 和 Hashtable 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap-%E5%92%8C-HashMap-%E4%B8%A4%E8%80%85%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">1.6.9.</span> <span class="nav-text">ConcurrentHashMap 和 HashMap 两者区别：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-ConcurrentHashMap-%E5%8F%AF%E4%BB%A5%E5%9C%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%AF%94-HashMap-%E6%9B%B4%E4%B8%BA%E9%AB%98%E6%95%88"><span class="nav-number">1.6.10.</span> <span class="nav-text">为什么 ConcurrentHashMap 可以在高并发的情况下比 HashMap 更为高效</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-LinkedHashMap-TreeMap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.6.11.</span> <span class="nav-text">HashMap,LinkedHashMap,TreeMap的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="nav-number">1.6.11.1.</span> <span class="nav-text">相同点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="nav-number">1.6.11.2.</span> <span class="nav-text">不同点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WeakHashMap-ConcurrentHashMap-IdentityHashMap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.6.12.</span> <span class="nav-text">WeakHashMap,ConcurrentHashMap,IdentityHashMap的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WeakHashMap%E4%B8%8EHashMap%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.6.13.</span> <span class="nav-text">WeakHashMap与HashMap的区别是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeMap-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="nav-number">1.6.14.</span> <span class="nav-text">TreeMap 整体架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E5%A2%9E%E8%8A%82%E7%82%B9"><span class="nav-number">1.6.14.1.</span> <span class="nav-text">新增节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="nav-number">1.6.14.2.</span> <span class="nav-text">特点：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashMap-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="nav-number">1.6.15.</span> <span class="nav-text">LinkedHashMap 整体架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E7%85%A7%E6%8F%92%E5%85%A5%E9%A1%BA%E5%BA%8F%E8%AE%BF%E9%97%AE"><span class="nav-number">1.6.15.1.</span> <span class="nav-text">按照插入顺序访问</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#LinkedHashMap-%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.6.15.1.1.</span> <span class="nav-text">LinkedHashMap 链表结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8C%89%E7%85%A7%E9%A1%BA%E5%BA%8F%E6%96%B0%E5%A2%9E"><span class="nav-number">1.6.15.2.</span> <span class="nav-text">如何按照顺序新增</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E7%85%A7%E9%A1%BA%E5%BA%8F%E8%AE%BF%E9%97%AE"><span class="nav-number">1.6.15.3.</span> <span class="nav-text">按照顺序访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%9C%80%E5%B0%91%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="nav-number">1.6.15.4.</span> <span class="nav-text">访问最少删除策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BD%95Map%E6%8E%A5%E5%8F%A3%E4%B8%8D%E7%BB%A7%E6%89%BFCollection%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.6.16.</span> <span class="nav-text">为何Map接口不继承Collection接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%91%E4%BB%AC%E8%83%BD%E5%90%A6%E4%BD%BF%E7%94%A8%E4%BB%BB%E4%BD%95%E7%B1%BB%E4%BD%9C%E4%B8%BAMap%E7%9A%84key"><span class="nav-number">1.6.17.</span> <span class="nav-text">我们能否使用任何类作为Map的key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DTO-%E4%BD%9C%E4%B8%BA-Map-%E7%9A%84-key-%E6%97%B6%EF%BC%8C%E6%9C%89%E6%97%A0%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9%EF%BC%9F"><span class="nav-number">1.6.18.</span> <span class="nav-text">DTO 作为 Map 的 key 时，有无需要注意的点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map%E6%8E%A5%E5%8F%A3%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E7%9A%84%E9%9B%86%E5%90%88%E8%A7%86%E5%9B%BE"><span class="nav-number">1.6.19.</span> <span class="nav-text">Map接口提供了哪些不同的集合视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A%E9%80%89%E7%94%A8HashMap%E8%BF%98%E6%98%AFTreeMap"><span class="nav-number">1.6.20.</span> <span class="nav-text">如何决定选用HashMap还是TreeMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeMap%E5%92%8CTreeSet%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%97%B6%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E5%85%83%E7%B4%A0%EF%BC%9FCollections%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B8%AD%E7%9A%84sort-%E6%96%B9%E6%B3%95%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="nav-number">1.6.21.</span> <span class="nav-text">TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E8%A7%A3%E5%86%B3-hash-%E5%86%B2%E7%AA%81%EF%BC%8C%E5%A4%A7%E6%A6%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%9E%E6%B3%95"><span class="nav-number">1.6.22.</span> <span class="nav-text">为解决 hash 冲突，大概有哪些办法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E5%88%A0%E9%99%A4%EF%BC%8C%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A1%8C%EF%BC%9F"><span class="nav-number">1.6.23.</span> <span class="nav-text">通过以下代码进行删除，是否可行？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-%E5%9C%A8-put-%E6%97%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%95%B0%E7%BB%84%E4%B8%AD%E5%B7%B2%E7%BB%8F%E6%9C%89%E4%BA%86%E8%BF%99%E4%B8%AA-key%EF%BC%8C%E6%88%91%E4%B8%8D%E6%83%B3%E6%8A%8A-value-%E8%A6%86%E7%9B%96%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%E5%8F%96%E5%80%BC%E6%97%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%BE%97%E5%88%B0%E7%9A%84-value-%E6%98%AF%E7%A9%BA%E6%97%B6%EF%BC%8C%E6%83%B3%E8%BF%94%E5%9B%9E%E9%BB%98%E8%AE%A4%E5%80%BC%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">1.6.24.</span> <span class="nav-text">HashMap 在 put 时，如果数组中已经有了这个 key，我不想把 value 覆盖怎么办？取值时，如果得到的 value 是空时，想返回默认值怎么办</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashMap-%E4%B8%AD%E7%9A%84-LRU-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%8C%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E3%80%82"><span class="nav-number">1.6.25.</span> <span class="nav-text">LinkedHashMap 中的 LRU 是什么意思，是如何实现的。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90-TreeMap-%E7%9A%84%E5%85%83%E7%B4%A0%E6%9C%80%E5%A5%BD%E9%83%BD%E5%AE%9E%E7%8E%B0-Comparable-%E6%8E%A5%E5%8F%A3%EF%BC%9F%E4%BD%86-key-%E6%98%AF-String-%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8D%B4%E6%B2%A1%E6%9C%89%E9%A2%9D%E5%A4%96%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%91%A2%EF%BC%9F"><span class="nav-number">1.6.26.</span> <span class="nav-text">为什么推荐 TreeMap 的元素最好都实现 Comparable 接口？但 key 是 String 的时候，我们却没有额外的工作呢？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collections-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">1.7.</span> <span class="nav-text">Collections 工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C"><span class="nav-number">1.7.1.</span> <span class="nav-text">排序操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE-%E6%9B%BF%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="nav-number">1.7.2.</span> <span class="nav-text">查找,替换操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6"><span class="nav-number">1.7.3.</span> <span class="nav-text">同步控制</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LiYuan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
